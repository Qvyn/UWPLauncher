# Set settings['xbox_notifications_debug']=True to log raw Xbox notification lines into the log viewer.

# === UWPLauncher_MONO.py (safe-embedded) ===
# Single-file bundle generated from your originals without changing flow.
# It registers each helper module in sys.modules under its original name,
# then executes the main script at top-level.
import sys, types
import base64

# Simple local obfuscation for Steam API key in steam.json.
# NOTE: This is *not* strong cryptography. It only prevents casual snooping
# (e.g. somebody opening the file in Notepad). Anyone with this file and the
# UWPLauncher executable could in theory reverse it.
_STEAM_SECRET = b"UWPLauncherSteamKey"

def _steam_encrypt(plaintext: str) -> str:
    if not plaintext:
        return ""
    data = plaintext.encode("utf-8", errors="ignore")
    key = _STEAM_SECRET
    out = bytes(b ^ key[i % len(key)] for i, b in enumerate(data))
    return base64.b64encode(out).decode("ascii", errors="ignore")

def _steam_decrypt(ciphertext: str) -> str:
    if not ciphertext:
        return ""
    try:
        raw = base64.b64decode(ciphertext.encode("ascii", errors="ignore"))
    except Exception:
        return ""
    key = _STEAM_SECRET
    out = bytes(b ^ key[i % len(key)] for i, b in enumerate(raw))
    try:
        return out.decode("utf-8")
    except Exception:
        return ""


# --- ADD-ONLY: Steam artwork helpers (auto-fetch, cached once) ---
_STEAM_ARTWORK_NEG_CACHE = set()

def _steam_artwork_path(appid: str):
    """Return Path for cached Steam artwork: config/artwork/<appid>.jpg"""
    try:
        # Use the same CONFIG_DIR/BASE_DIR logic as the rest of the launcher.
        # ARTWORK_DIR is created at startup alongside CONFIG_DIR.
        p = os.path.join(ARTWORK_DIR, f"{appid}.jpg")
        return p
    except Exception:
        # Fallback: relative file name if anything goes wrong.
        return os.path.join("config", "artwork", f"{appid}.jpg")


def _steam_artwork_ensure_cached(appid: str):
    """
    Best-effort download of Steam library artwork for a given appid.
    - Downloads only once per appid (cached on disk).
    - Safe to fail silently if offline or Steam has no image.
    Also prints lightweight debug info to stdout so the user can see what happens.
    """
    if not appid:
        return
    try:
        from pathlib import Path as _Path
        import requests

        appid = str(appid).strip()
        if not appid:
            return

        # If we've already tried and failed to fetch this appid's artwork,
        # don't hammer the CDN again. This keeps UI operations like the
        # library refresh and slider from triggering repeated 404 fetches.
        try:
            if appid in _STEAM_ARTWORK_NEG_CACHE:
                return
        except Exception:
            pass

        p = _steam_artwork_path(appid)
        # If we already have artwork, do nothing (download-once semantics)
        try:
            if hasattr(p, "is_file"):
                if p.is_file():
                    return
            else:
                import os as _os
                if _os.path.isfile(p):
                    return
        except Exception:
            pass

        # Try a couple of known Steam CDN patterns.
        urls = [
            f"https://steamcdn-a.akamaihd.net/steam/apps/{appid}/library_600x900.jpg",
            f"https://steamcdn-a.akamaihd.net/steam/apps/{appid}/header.jpg",
        ]

        for url in urls:
            try:
                print(f"[ART] fetching {url} ...")
                resp = requests.get(url, timeout=2)
            except Exception as e:
                print(f"[ART] request error for appid {appid}: {e}")
                continue
            status = getattr(resp, "status_code", None)
            if status != 200:
                print(f"[ART] HTTP {status} for appid {appid} at {url}")
                continue
            content = getattr(resp, "content", None)
            if not content:
                print(f"[ART] empty content for appid {appid} at {url}")
                continue

            # Write bytes to disk (best-effort)
            try:
                if hasattr(p, "write_bytes"):
                    p.write_bytes(content)
                else:
                    with open(p, "wb") as f:
                        f.write(content)
                print(f"[ART] saved artwork for appid {appid} -> {p}")
                break
            except Exception as e:
                print(f"[ART] failed to write artwork for appid {appid}: {e}")
                # try next URL if any
                continue
    except Exception as e:
        # Completely best-effort; never crash the launcher over artwork
        print(f"[ART] fatal error for appid {appid}: {e}")
        pass




# Optional: faux "xbl" package so imports like "from xbl import ..." work
if "xbl" not in sys.modules:
    xbl_pkg = types.ModuleType("xbl")
    xbl_pkg.__path__ = []
    sys.modules["xbl"] = xbl_pkg

def _register_module(name: str, code: str, virtual_file: str):
    """
    Load an embedded helper module from a trusted source string.

    code always comes from our own embedded mapping, never from user input.
    """
    mod = types.ModuleType(name)
    mod.__file__ = virtual_file
    sys.modules[name] = mod
    exec(compile(code, virtual_file, "exec"), mod.__dict__)  # nosec B102: trusted, embedded code only
    return mod

# === BEGIN EMBED: ensure nonuwp.launcher (base64) ===
import sys as _sys, types as _types, base64 as _b64
if "nonuwp" not in _sys.modules:
    _pkg = _types.ModuleType("nonuwp"); _pkg.__path__ = []; _sys.modules["nonuwp"] = _pkg
try:
    _src = _b64.b64decode("aW1wb3J0IHJlCiMgVW5pdmVyc2FsIFVXUCBHYW1lIExhdW5jaGVyIChzaW5nbGUgZmlsZSkKIyBMYXVuY2hlcyBVV1AgYXBwcyBieSBBVU1JRCB2aWEgSUFwcGxpY2F0aW9uQWN0aXZhdGlvbk1hbmFnZXIsIHBhc3NlcyBhcmd1bWVudHMsCiMgdGhlbiBhcHBsaWVzIHBlci10aXRsZSBDUFUgYWZmaW5pdHkgYW5kIHByb2Nlc3MgcHJpb3JpdHkuIEluY2x1ZGVzIGEgc2ltcGxlIFVJCiMgdG8gYWRkL2VkaXQgdGl0bGVzIGFuZCBvcHRpb25hbGx5IGNyZWF0ZSBhIGRlc2t0b3AgLmxuayB0aGF0IGNhbGxzIHRoaXMgc2NyaXB0LgoKaW1wb3J0IG9zLCBzeXMsIGpzb24sIHRpbWUsIHN1YnByb2Nlc3MsIGN0eXBlcywgcGxhdGZvcm0sIHRyYWNlYmFjawpmcm9tIHBhdGhsaWIgaW1wb3J0IFBhdGgKZnJvbSB0eXBpbmcgaW1wb3J0IE9wdGlvbmFsLCBEaWN0LCBBbnksIExpc3QsIFR1cGxlCmltcG9ydCB3ZWJicm93c2VyCmZyb20gaHR0cC5zZXJ2ZXIgaW1wb3J0IEhUVFBTZXJ2ZXIsIEJhc2VIVFRQUmVxdWVzdEhhbmRsZXIKZnJvbSB1cmxsaWIucGFyc2UgaW1wb3J0IHVybGVuY29kZSwgdXJscGFyc2UsIHBhcnNlX3FzCmZyb20gdXJsbGliLnJlcXVlc3QgaW1wb3J0IHVybG9wZW4sIFJlcXVlc3QKaW1wb3J0IHRocmVhZGluZywgc29ja2V0CgojIFRoaXJkLXBhcnR5IGRlcHMgKGluc3RhbGw6IHBpcCBpbnN0YWxsIFB5UXQ2IHBzdXRpbCBjb210eXBlcykKdHJ5OgogICAgaW1wb3J0IHBzdXRpbAogICAgaW1wb3J0IGNvbXR5cGVzCiAgICBpbXBvcnQgY29tdHlwZXMuY2xpZW50IGFzIGNjCiAgICBmcm9tIGNvbXR5cGVzIGltcG9ydCBHVUlELCBIUkVTVUxULCBJVW5rbm93biwgQ09NTUVUSE9ECiAgICBmcm9tIGN0eXBlcyBpbXBvcnQgd2ludHlwZXMKZXhjZXB0IEltcG9ydEVycm9yIGFzIGU6CiAgICBwcmludCgiTWlzc2luZyBkZXBlbmRlbmN5OiIsIGUpCiAgICBwcmludCgiSW5zdGFsbCB3aXRoOiBwaXAgaW5zdGFsbCBQeVF0NiBwc3V0aWwgY29tdHlwZXMiKQogICAgc3lzLmV4aXQoMSkKCiMgUXQKZnJvbSBQeVF0NiBpbXBvcnQgUXRXaWRnZXRzLCBRdENvcmUsIFF0R3VpCgojIC0tLSBQbGF0Zm9ybSBndWFyZCAtLS0KaWYgcGxhdGZvcm0uc3lzdGVtKCkgIT0gIldpbmRvd3MiOgogICAgcHJpbnQoIlRoaXMgdG9vbCByZXF1aXJlcyBXaW5kb3dzLiIpCiAgICBzeXMuZXhpdCgxKQoKIyA9PT09PSBXaW4zMiAvIENPTSBjb25zdGFudHMgPT09PT0KIyBQcmlvcml0eSBjbGFzc2VzCkFCT1ZFX05PUk1BTF9QUklPUklUWV9DTEFTUyA9IDB4MDAwMDgwMDAKSElHSF9QUklPUklUWV9DTEFTUyAgICAgICAgID0gMHgwMDAwMDA4MApOT1JNQUxfUFJJT1JJVFlfQ0xBU1MgICAgICAgPSAweDAwMDAwMDIwClJFQUxUSU1FX1BSSU9SSVRZX0NMQVNTICAgICA9IDB4MDAwMDAxMDAKQkVMT1dfTk9STUFMX1BSSU9SSVRZX0NMQVNTID0gMHgwMDAwNDAwMAoKUFJJT1JJVFlfTUFQID0gewogICAgIk5vcm1hbCI6IE5PUk1BTF9QUklPUklUWV9DTEFTUywKICAgICJBYm92ZSBOb3JtYWwiOiBBQk9WRV9OT1JNQUxfUFJJT1JJVFlfQ0xBU1MsCiAgICAiSGlnaCI6IEhJR0hfUFJJT1JJVFlfQ0xBU1MsCiAgICAiUmVhbHRpbWUgKGNhcmVmdWwpIjogUkVBTFRJTUVfUFJJT1JJVFlfQ0xBU1MsCiAgICAiQmVsb3cgTm9ybWFsIjogQkVMT1dfTk9STUFMX1BSSU9SSVRZX0NMQVNTCn0KCiMgSUFwcGxpY2F0aW9uQWN0aXZhdGlvbk1hbmFnZXIKQ0xTSURfQXBwbGljYXRpb25BY3RpdmF0aW9uTWFuYWdlciA9IEdVSUQoIns0NUJBMTI3RC0xMEE4LTQ2RUEtOEFCNy01NkVBOTA3ODk0M0N9IikKSUlEX0lBcHBsaWNhdGlvbkFjdGl2YXRpb25NYW5hZ2VyICA9IEdVSUQoInsyRTk0MTE0MS03Rjk3LTQ3NTYtQkExRC05REVDREU4OTRBM0R9IikKCiMgQWN0aXZhdGVPcHRpb25zCkFPX05PTkUgICAgICAgICAgICA9IDB4MApBT19OT0VSUk9SVUkgICAgICAgPSAweDEKQU9fTk9TUExBU0hTQ1JFRU4gID0gMHgyCgprZXJuZWwzMiA9IGN0eXBlcy53aW5kbGwua2VybmVsMzIKdXNlcjMyICAgPSBjdHlwZXMud2luZGxsLnVzZXIzMgpBU0ZXX0FOWSA9IC0xICAjIEFsbG93U2V0Rm9yZWdyb3VuZFdpbmRvdwoKIyAtLS0tLSBDT00gaW50ZXJmYWNlIGRlZmluaXRpb24gLS0tLS0KY2xhc3MgSUFwcGxpY2F0aW9uQWN0aXZhdGlvbk1hbmFnZXIoSVVua25vd24pOgogICAgX2lpZF8gPSBJSURfSUFwcGxpY2F0aW9uQWN0aXZhdGlvbk1hbmFnZXIKICAgIF9tZXRob2RzXyA9IFsKICAgICAgICBDT01NRVRIT0QoCiAgICAgICAgICAgIFtdLCBIUkVTVUxULCAnQWN0aXZhdGVBcHBsaWNhdGlvbicsCiAgICAgICAgICAgIChbJ2luJ10sICBjdHlwZXMuY193Y2hhcl9wLCAnYXBwVXNlck1vZGVsSWQnKSwKICAgICAgICAgICAgKFsnaW4nXSwgIGN0eXBlcy5jX3djaGFyX3AsICdhcmd1bWVudHMnKSwKICAgICAgICAgICAgKFsnaW4nXSwgIGN0eXBlcy5jX3VpbnQsICAgICdvcHRpb25zJyksCiAgICAgICAgICAgIChbJ291dCddLCBjdHlwZXMuUE9JTlRFUih3aW50eXBlcy5EV09SRCksICdwcm9jZXNzSWQnKQogICAgICAgICksCiAgICAgICAgIyBTdHVicyAodW51c2VkIGJ1dCBrZWVwIHZ0YWJsZSBsYXlvdXQpCiAgICAgICAgQ09NTUVUSE9EKFtdLCBIUkVTVUxULCAnQWN0aXZhdGVGb3JGaWxlJywKICAgICAgICAgICAgICAgICAgKFsnaW4nXSwgY3R5cGVzLmNfdm9pZF9wLCAnaXRlbUFycmF5JyksCiAgICAgICAgICAgICAgICAgIChbJ2luJ10sIGN0eXBlcy5jX3djaGFyX3AsICd2ZXJiJyksCiAgICAgICAgICAgICAgICAgIChbJ291dCddLCBjdHlwZXMuUE9JTlRFUih3aW50eXBlcy5EV09SRCksICdwcm9jZXNzSWQnKSksCiAgICAgICAgQ09NTUVUSE9EKFtdLCBIUkVTVUxULCAnQWN0aXZhdGVGb3JQcm90b2NvbCcsCiAgICAgICAgICAgICAgICAgIChbJ2luJ10sIGN0eXBlcy5jX3ZvaWRfcCwgJ2l0ZW1BcnJheScpLAogICAgICAgICAgICAgICAgICAoWydpbiddLCBjdHlwZXMuY193Y2hhcl9wLCAndmVyYicpLAogICAgICAgICAgICAgICAgICAoWydvdXQnXSwgY3R5cGVzLlBPSU5URVIod2ludHlwZXMuRFdPUkQpLCAncHJvY2Vzc0lkJykpLAogICAgXQoKZGVmIF9jcmVhdGVfYWN0aXZhdGlvbl9tYW5hZ2VyKCkgLT4gSUFwcGxpY2F0aW9uQWN0aXZhdGlvbk1hbmFnZXI6CiAgICAjIEluaXRpYWxpemUgQ09NIGFuZCBhbGxvdyBmb3JlZ3JvdW5kCiAgICBjb210eXBlcy5Db0luaXRpYWxpemUoKQogICAgdXNlcjMyLkFsbG93U2V0Rm9yZWdyb3VuZFdpbmRvdyhBU0ZXX0FOWSkKICAgICMgQ3JlYXRlIHRoZSBDT00gb2JqZWN0IChMb2NhbCBTZXJ2ZXIgY29udGV4dCkKICAgIHJldHVybiBjYy5DcmVhdGVPYmplY3QoCiAgICAgICAgQ0xTSURfQXBwbGljYXRpb25BY3RpdmF0aW9uTWFuYWdlciwKICAgICAgICBpbnRlcmZhY2U9SUFwcGxpY2F0aW9uQWN0aXZhdGlvbk1hbmFnZXIsCiAgICAgICAgY2xzY3R4PWNvbXR5cGVzLkNMU0NUWF9MT0NBTF9TRVJWRVIKICAgICkKCiMgPT09PT0gSGVscGVycyA9PT09PQojID09PT09IFN0ZWFtIFZhbGlkYXRpb24gSGVscGVycyA9PT09PQpkZWYgX2dldF9zdGVhbV9yb290KCkgLT4gT3B0aW9uYWxbUGF0aF06CiAgICAiIiJMb2NhdGUgU3RlYW0gcm9vdCB2aWEgcmVnaXN0cnkgb3IgZGVmYXVsdHMuIiIiCiAgICB0cnk6CiAgICAgICAgaW1wb3J0IHdpbnJlZwogICAgICAgIHdpdGggd2lucmVnLk9wZW5LZXkod2lucmVnLkhLRVlfQ1VSUkVOVF9VU0VSLCByIlNvZnR3YXJlXFZhbHZlXFN0ZWFtIikgYXMgazoKICAgICAgICAgICAgdmFsLCBfID0gd2lucmVnLlF1ZXJ5VmFsdWVFeChrLCAiU3RlYW1QYXRoIikKICAgICAgICAgICAgaWYgdmFsOgogICAgICAgICAgICAgICAgcCA9IFBhdGgodmFsKQogICAgICAgICAgICAgICAgcmV0dXJuIHAgaWYgcC5leGlzdHMoKSBlbHNlIE5vbmUKICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgcGFzcwogICAgIyBjb21tb24gZGVmYXVsdAogICAgZm9yIGd1ZXNzIGluIFtQYXRoKHIiQzpcUHJvZ3JhbSBGaWxlcyAoeDg2KVxTdGVhbSIpLCBQYXRoKHIiQzpcUHJvZ3JhbSBGaWxlc1xTdGVhbSIpXToKICAgICAgICBpZiBndWVzcy5leGlzdHMoKToKICAgICAgICAgICAgcmV0dXJuIGd1ZXNzCiAgICByZXR1cm4gTm9uZQoKZGVmIF9zdGVhbV9jb250ZW50X2xvZ19wYXRoKCkgLT4gT3B0aW9uYWxbUGF0aF06CiAgICByb290ID0gX2dldF9zdGVhbV9yb290KCkKICAgIGlmIG5vdCByb290OgogICAgICAgIHJldHVybiBOb25lCiAgICBsb2cgPSByb290IC8gImxvZ3MiIC8gImNvbnRlbnRfbG9nLnR4dCIKICAgIHJldHVybiBsb2cgaWYgbG9nLmV4aXN0cygpIGVsc2UgbG9nICAjIHJldHVybiBwYXRoIGFueXdheTsgaXQgbWF5IGJlIGNyZWF0ZWQgb24gZmlyc3Qgd3JpdGUKCmRlZiBfb3Blbl9zdGVhbV91cmwodXJsOiBzdHIpIC0+IGJvb2w6CiAgICAiIiJPcGVuIGEgc3RlYW06Ly8gVVJMIHdpdGhvdXQgYmxvY2tpbmcuIiIiCiAgICB0cnk6CiAgICAgICAgIyBvcy5zdGFydGZpbGUgc3VwcG9ydHMgcHJvdG9jb2wgaGFuZGxlcnMgb24gV2luZG93cwogICAgICAgIG9zLnN0YXJ0ZmlsZSh1cmwpCiAgICAgICAgcmV0dXJuIFRydWUKICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgdHJ5OgogICAgICAgICAgICBzdWJwcm9jZXNzLlBvcGVuKFsnY21kJywgJy9jJywgJ3N0YXJ0JywgJycsIHVybF0sIGNyZWF0aW9uZmxhZ3M9c3VicHJvY2Vzcy5DUkVBVEVfTk9fV0lORE9XKQogICAgICAgICAgICByZXR1cm4gVHJ1ZQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgIHJldHVybiBGYWxzZQoKCgojID09PT09IFN0ZWFtIE9wZW5JRCBMb2dpbiAoZm9yIGxhdW5jaGVyIGF1dGgpID09PT09CmRlZiBfZmluZF9mcmVlX3BvcnQoc3RhcnQ9MzQxMjMsIGVuZD0zNDIyMyk6CiAgICBmb3IgcG9ydCBpbiByYW5nZShzdGFydCwgZW5kKToKICAgICAgICB3aXRoIHNvY2tldC5zb2NrZXQoc29ja2V0LkFGX0lORVQsIHNvY2tldC5TT0NLX1NUUkVBTSkgYXMgc286CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIHNvLmJpbmQoKCIxMjcuMC4wLjEiLCBwb3J0KSkKICAgICAgICAgICAgICAgIHJldHVybiBwb3J0CiAgICAgICAgICAgIGV4Y2VwdCBPU0Vycm9yOgogICAgICAgICAgICAgICAgY29udGludWUKICAgIHJldHVybiBOb25lCgpkZWYgX3ZlcmlmeV9vcGVuaWRfd2l0aF9zdGVhbShwYXJhbXM6IERpY3Rbc3RyLCBBbnldKSAtPiBib29sOgogICAgdmVyaWZ5X3BhcmFtcyA9IHBhcmFtcy5jb3B5KCkKICAgIHZlcmlmeV9wYXJhbXNbJ29wZW5pZC5tb2RlJ10gPSAnY2hlY2tfYXV0aGVudGljYXRpb24nCiAgICBkYXRhID0gdXJsZW5jb2RlKHZlcmlmeV9wYXJhbXMpLmVuY29kZSgndXRmLTgnKQogICAgdHJ5OgogICAgICAgIHJlcSA9IFJlcXVlc3QoImh0dHBzOi8vc3RlYW1jb21tdW5pdHkuY29tL29wZW5pZC9sb2dpbiIsIGRhdGE9ZGF0YSwgbWV0aG9kPSJQT1NUIikKICAgICAgICB3aXRoIHVybG9wZW4ocmVxLCB0aW1lb3V0PTEwKSBhcyByZXNwOgogICAgICAgICAgICBib2R5ID0gcmVzcC5yZWFkKCkuZGVjb2RlKCd1dGYtOCcsIGVycm9ycz0naWdub3JlJykKICAgICAgICAgICAgcmV0dXJuICdpc192YWxpZDp0cnVlJyBpbiBib2R5CiAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgIHJldHVybiBGYWxzZQoKZGVmIHN0ZWFtX29wZW5pZF9sb2dpbih0aW1lb3V0PTE4MCkgLT4gT3B0aW9uYWxbc3RyXToKICAgIHBvcnQgPSBfZmluZF9mcmVlX3BvcnQoKQogICAgaWYgbm90IHBvcnQ6CiAgICAgICAgcmV0dXJuIE5vbmUKICAgIHJlc3VsdCA9IHsic3RlYW1pZCI6IE5vbmV9CiAgICBkb25lID0gdGhyZWFkaW5nLkV2ZW50KCkKCiAgICBjbGFzcyBIYW5kbGVyKEJhc2VIVFRQUmVxdWVzdEhhbmRsZXIpOgogICAgICAgIGRlZiBkb19HRVQoc2VsZik6CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIHEgPSB1cmxwYXJzZShzZWxmLnBhdGgpCiAgICAgICAgICAgICAgICBpZiBxLnBhdGggIT0gIi9jYWxsYmFjayI6CiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZW5kX3Jlc3BvbnNlKDQwNCk7IHNlbGYuZW5kX2hlYWRlcnMoKTsgcmV0dXJuCiAgICAgICAgICAgICAgICBwYXJhbXMgPSB7azogdlswXSBmb3IgaywgdiBpbiBwYXJzZV9xcyhxLnF1ZXJ5KS5pdGVtcygpfQogICAgICAgICAgICAgICAgb2sgPSBfdmVyaWZ5X29wZW5pZF93aXRoX3N0ZWFtKHBhcmFtcykKICAgICAgICAgICAgICAgIGNsYWltZWQgPSBwYXJhbXMuZ2V0KCJvcGVuaWQuY2xhaW1lZF9pZCIsIiIpCiAgICAgICAgICAgICAgICBzdGVhbWlkID0gIiIKICAgICAgICAgICAgICAgIGlmIGNsYWltZWQgYW5kIGNsYWltZWQucnNwbGl0KCIvIiwgMSlbLTFdLmlzZGlnaXQoKToKICAgICAgICAgICAgICAgICAgICBzdGVhbWlkID0gY2xhaW1lZC5yc3BsaXQoIi8iLCAxKVstMV0KICAgICAgICAgICAgICAgIGlmIG9rIGFuZCBzdGVhbWlkOgogICAgICAgICAgICAgICAgICAgIHJlc3VsdFsic3RlYW1pZCJdID0gc3RlYW1pZAogICAgICAgICAgICAgICAgICAgIGJvZHkgPSBmIjxodG1sPjxib2R5PjxoMz5Mb2dpbiBzdWNjZXNzZnVsLiBZb3UgY2FuIGNsb3NlIHRoaXMgd2luZG93LjwvaDM+PHA+U3RlYW1JRDoge3N0ZWFtaWR9PC9wPjwvYm9keT48L2h0bWw+Ii5lbmNvZGUoInV0Zi04IikKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgYm9keSA9IGIiPGh0bWw+PGJvZHk+PGgzPkxvZ2luIGZhaWxlZCBvciBjYW5jZWxlZC4gUGxlYXNlIGNsb3NlIHRoaXMgd2luZG93LjwvaDM+PC9ib2R5PjwvaHRtbD4iCiAgICAgICAgICAgICAgICBzZWxmLnNlbmRfcmVzcG9uc2UoMjAwKTsgc2VsZi5zZW5kX2hlYWRlcigiQ29udGVudC1UeXBlIiwidGV4dC9odG1sIik7IHNlbGYuZW5kX2hlYWRlcnMoKTsgc2VsZi53ZmlsZS53cml0ZShib2R5KQogICAgICAgICAgICAgICAgZG9uZS5zZXQoKQogICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgIHNlbGYuc2VuZF9yZXNwb25zZSg1MDApOyBzZWxmLmVuZF9oZWFkZXJzKCkKICAgICAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgICAgICAgICAgcGFzcwogICAgICAgICAgICAgICAgZG9uZS5zZXQoKQogICAgICAgIGRlZiBsb2dfbWVzc2FnZShzZWxmLCBmb3JtYXQsICphcmdzKTogCiAgICAgICAgICAgIHJldHVybgoKICAgIGh0dHBkID0gSFRUUFNlcnZlcigoIjEyNy4wLjAuMSIsIHBvcnQpLCBIYW5kbGVyKQogICAgdGggPSB0aHJlYWRpbmcuVGhyZWFkKHRhcmdldD1odHRwZC5zZXJ2ZV9mb3JldmVyLCBkYWVtb249VHJ1ZSkKICAgIHRoLnN0YXJ0KCkKCiAgICByZWFsbSA9IGYiaHR0cDovLzEyNy4wLjAuMTp7cG9ydH0iCiAgICByZXR1cm5fdG8gPSBmIntyZWFsbX0vY2FsbGJhY2siCiAgICBvcGVuaWRfcGFyYW1zID0gewogICAgICAgICJvcGVuaWQubnMiOiAiaHR0cDovL3NwZWNzLm9wZW5pZC5uZXQvYXV0aC8yLjAiLAogICAgICAgICJvcGVuaWQubW9kZSI6ICJjaGVja2lkX3NldHVwIiwKICAgICAgICAib3BlbmlkLnJldHVybl90byI6IHJldHVybl90bywKICAgICAgICAib3BlbmlkLnJlYWxtIjogcmVhbG0sCiAgICAgICAgIm9wZW5pZC5pZGVudGl0eSI6ICJodHRwOi8vc3BlY3Mub3BlbmlkLm5ldC9hdXRoLzIuMC9pZGVudGlmaWVyX3NlbGVjdCIsCiAgICAgICAgIm9wZW5pZC5jbGFpbWVkX2lkIjogImh0dHA6Ly9zcGVjcy5vcGVuaWQubmV0L2F1dGgvMi4wL2lkZW50aWZpZXJfc2VsZWN0IiwKICAgIH0KICAgIHVybCA9ICJodHRwczovL3N0ZWFtY29tbXVuaXR5LmNvbS9vcGVuaWQvbG9naW4/IiArIHVybGVuY29kZShvcGVuaWRfcGFyYW1zKQogICAgd2ViYnJvd3Nlci5vcGVuKHVybCkKCiAgICBpZiBub3QgZG9uZS53YWl0KHRpbWVvdXQpOgogICAgICAgIHRyeTogaHR0cGQuc2h1dGRvd24oKQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb246IHBhc3MKICAgICAgICByZXR1cm4gTm9uZQogICAgdHJ5OiBodHRwZC5zaHV0ZG93bigpCiAgICBleGNlcHQgRXhjZXB0aW9uOiBwYXNzCiAgICByZXR1cm4gcmVzdWx0WyJzdGVhbWlkIl0KCmRlZiBzeW5jX3N0ZWFtX2xpYnJhcnkoc3RlYW1pZDogc3RyLCBhcGlfa2V5OiBPcHRpb25hbFtzdHJdKSAtPiBUdXBsZVtib29sLCBzdHIsIE9wdGlvbmFsW2RpY3RdXToKICAgIGlmIG5vdCBzdGVhbWlkIG9yIG5vdCBzdGVhbWlkLmlzZGlnaXQoKToKICAgICAgICByZXR1cm4gKEZhbHNlLCAiTm8gdmFsaWQgU3RlYW1JRC4iLCBOb25lKQogICAgaWYgbm90IGFwaV9rZXk6CiAgICAgICAgcmV0dXJuIChGYWxzZSwgIk5vIFN0ZWFtIFdlYiBBUEkga2V5IHNldC4gQWRkIG9uZSB0byBTZXR0aW5ncyB0byBzeW5jIGZ1bGwgbGlicmFyeS4iLCBOb25lKQogICAgdHJ5OgogICAgICAgIHFzID0gdXJsZW5jb2RlKHsia2V5IjogYXBpX2tleSwgInN0ZWFtaWQiOiBzdGVhbWlkLCAiaW5jbHVkZV9hcHBpbmZvIjogMSwgImluY2x1ZGVfcGxheWVkX2ZyZWVfZ2FtZXMiOiAxfSkKICAgICAgICB1cmwgPSAiaHR0cHM6Ly9hcGkuc3RlYW1wb3dlcmVkLmNvbS9JUGxheWVyU2VydmljZS9HZXRPd25lZEdhbWVzL3YxLz8iICsgcXMKICAgICAgICB3aXRoIHVybG9wZW4odXJsLCB0aW1lb3V0PTE1KSBhcyByZXNwOgogICAgICAgICAgICBpbXBvcnQganNvbiBhcyBfanNvbgogICAgICAgICAgICBkYXRhID0gX2pzb24ubG9hZHMocmVzcC5yZWFkKCkuZGVjb2RlKCJ1dGYtOCIsIGVycm9ycz0iaWdub3JlIikpCiAgICAgICAgICAgIHJldHVybiAoVHJ1ZSwgZiJGZXRjaGVkIHtsZW4oZGF0YS5nZXQoJ3Jlc3BvbnNlJyx7fSkuZ2V0KCdnYW1lcycsIFtdKSl9IGdhbWVzLiIsIGRhdGEpCiAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgcmV0dXJuIChGYWxzZSwgZiJGYWlsZWQgdG8gZmV0Y2ggbGlicmFyeToge2V9IiwgTm9uZSkKZGVmIHN0ZWFtX3ZhbGlkYXRlX2FuZF93YWl0KGFwcGlkOiBzdHIsIHRpbWVvdXRfczogaW50ID0gMTgwMCwgcG9sbF9pbnRlcnZhbDogZmxvYXQgPSAxLjAsIGZhbGxiYWNrX3dhaXRfczogaW50ID0gNjApOgogICAgIiIiCiAgICBUcmlnZ2VyIFN0ZWFtIHZhbGlkYXRpb24gKHN0ZWFtOi8vdmFsaWRhdGUvPGFwcGlkPikgYW5kIHdhaXQgdW50aWwgaXQncyAqbGlrZWx5KiBkb25lLgogICAgUHJpb3JpdHkgMTogd2F0Y2ggU3RlYW0gd2luZG93IHRpdGxlcyBmb3IgYW55IG9mOiAnVmFsaWRhdGluZycsICdWZXJpZnlpbmcnLCAnVXBkYXRpbmcnLgogICAgICAgICAgICAgICAgT25jZSBzZWVuIGF0IGxlYXN0IG9uY2UgYW5kIHRoZW4gYWJzZW50IGZvciB+NXMsIGNvbnNpZGVyIGl0IGZpbmlzaGVkLgogICAgUHJpb3JpdHkgMjogaWYgd2UgbmV2ZXIgc2VlIHRob3NlIHRpdGxlcyBhdCBhbGwsIGZhbGwgYmFjayB0byBhIGZpeGVkIHdhaXQgKGBmYWxsYmFja193YWl0X3NgKS4KICAgIE5vIGxvZyBwYXJzaW5nLiBObyBmaWxlIEkvTy4KICAgICIiIgogICAgYXBwaWQgPSBzdHIoYXBwaWQpLnN0cmlwKCkKICAgIGlmIG5vdCBhcHBpZC5pc2RpZ2l0KCk6CiAgICAgICAgcmV0dXJuIEZhbHNlLCBmIlt4XSBJbnZhbGlkIFN0ZWFtIEFwcElEOiB7YXBwaWR9IgoKICAgIF9vcGVuX3N0ZWFtX3VybChmInN0ZWFtOi8vdmFsaWRhdGUve2FwcGlkfSIpCgogICAgaW1wb3J0IHRpbWUKICAgIHN0YXJ0X3RzID0gdGltZS50aW1lKCkKICAgIGxhc3Rfc2VlbiA9IDAuMAogICAgc2Vlbl9hbnkgPSBGYWxzZQogICAgZ3JhY2VfYWZ0ZXJfaGlkZSA9IDUuMAogICAga2V5d29yZHMgPSAoIlZhbGlkYXRpbmciLCAiVmVyaWZ5aW5nIiwgIlVwZGF0aW5nIikKCiAgICB3aGlsZSAodGltZS50aW1lKCkgLSBzdGFydF90cykgPCB0aW1lb3V0X3M6CiAgICAgICAgdHJ5OgogICAgICAgICAgICBpZiBhbnkoX3N0ZWFtX3dpbmRvd190aXRsZV9oYXMoaykgZm9yIGsgaW4ga2V5d29yZHMpOgogICAgICAgICAgICAgICAgc2Vlbl9hbnkgPSBUcnVlCiAgICAgICAgICAgICAgICBsYXN0X3NlZW4gPSB0aW1lLnRpbWUoKQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgIHBhc3MKCiAgICAgICAgaWYgc2Vlbl9hbnkgYW5kICh0aW1lLnRpbWUoKSAtIGxhc3Rfc2VlbikgPj0gZ3JhY2VfYWZ0ZXJfaGlkZToKICAgICAgICAgICAgcmV0dXJuIFRydWUsIGYiW+Kck10gU3RlYW0gdmFsaWRhdGlvbiBmaW5pc2hlZCBmb3IgQXBwSUQge2FwcGlkfS4iCgogICAgICAgICMgRmFsbGJhY2sgcGF0aDogbmV2ZXIgc2F3IGEgJ3ZhbGlkYXRpbmcnIGtpbmQgb2YgdGl0bGUgYXQgYWxsIOKAlCBqdXN0IHdhaXQgb3V0IGEgc2hvcnQgd2luZG93CiAgICAgICAgaWYgKG5vdCBzZWVuX2FueSkgYW5kICh0aW1lLnRpbWUoKSAtIHN0YXJ0X3RzKSA+PSBmYWxsYmFja193YWl0X3M6CiAgICAgICAgICAgIHJldHVybiBUcnVlLCBmIlt+XSBQcm9jZWVkaW5nIGFmdGVyIGZhbGxiYWNrIHdhaXQgKHtmYWxsYmFja193YWl0X3N9cykgZm9yIEFwcElEIHthcHBpZH0uIgoKICAgICAgICB0aW1lLnNsZWVwKHBvbGxfaW50ZXJ2YWwpCgogICAgcmV0dXJuIEZhbHNlLCBmIlshXSBUaW1lZCBvdXQgd2FpdGluZyBmb3IgU3RlYW0gdmFsaWRhdGlvbiBvZiBBcHBJRCB7YXBwaWR9IGFmdGVyIHt0aW1lb3V0X3N9cy4iCmRlZiBzZXRfcHJpb3JpdHlfYW5kX2FmZmluaXR5KHBpZDogaW50LCBwcmlvcml0eV9jb25zdDogaW50LCBtYXNrOiBPcHRpb25hbFtpbnRdKSAtPiBUdXBsZVtib29sLCBzdHJdOgogICAgIiIiQXBwbHkgcHJpb3JpdHkgYW5kIG9wdGlvbmFsIENQVSBhZmZpbml0eSB0byBhIHByb2Nlc3MuIiIiCiAgICB0cnk6CiAgICAgICAgUFJPQ0VTU19TRVRfSU5GT1JNQVRJT04gPSAweDAyMDAKICAgICAgICBQUk9DRVNTX1FVRVJZX0xJTUlURURfSU5GT1JNQVRJT04gPSAweDEwMDAKICAgICAgICBQUk9DRVNTX1NFVF9BRkZJTklUWSA9IDB4MDEwMAogICAgICAgIGRlc2lyZWQgPSBQUk9DRVNTX1NFVF9JTkZPUk1BVElPTiB8IFBST0NFU1NfUVVFUllfTElNSVRFRF9JTkZPUk1BVElPTiB8IFBST0NFU1NfU0VUX0FGRklOSVRZCiAgICAgICAgaGFuZGxlID0ga2VybmVsMzIuT3BlblByb2Nlc3MoZGVzaXJlZCwgRmFsc2UsIHBpZCkKICAgICAgICBpZiBub3QgaGFuZGxlOgogICAgICAgICAgICByZXR1cm4gRmFsc2UsIGYiT3BlblByb2Nlc3MgZmFpbGVkIChQSUQge3BpZH0pLiBUcnkgcnVubmluZyBhcyBBZG1pbmlzdHJhdG9yLiIKCiAgICAgICAgaWYgbm90IGtlcm5lbDMyLlNldFByaW9yaXR5Q2xhc3MoaGFuZGxlLCBwcmlvcml0eV9jb25zdCk6CiAgICAgICAgICAgIGtlcm5lbDMyLkNsb3NlSGFuZGxlKGhhbmRsZSkKICAgICAgICAgICAgcmV0dXJuIEZhbHNlLCBmIlNldFByaW9yaXR5Q2xhc3MgZmFpbGVkIGZvciBQSUQge3BpZH0uIFRyeSBBZG1pbi4iCgogICAgICAgIGlmIG1hc2sgaXMgbm90IE5vbmU6CiAgICAgICAgICAgIHBtYXNrID0gY3R5cGVzLmNfc2l6ZV90KG1hc2spCiAgICAgICAgICAgIGlmIG5vdCBrZXJuZWwzMi5TZXRQcm9jZXNzQWZmaW5pdHlNYXNrKGhhbmRsZSwgcG1hc2spOgogICAgICAgICAgICAgICAga2VybmVsMzIuQ2xvc2VIYW5kbGUoaGFuZGxlKQogICAgICAgICAgICAgICAgcmV0dXJuIEZhbHNlLCBmIlNldFByb2Nlc3NBZmZpbml0eU1hc2sgZmFpbGVkIGZvciBQSUQge3BpZH0uIE1hc2s9MHh7bWFzazpYfS4gVHJ5IEFkbWluLiIKCiAgICAgICAga2VybmVsMzIuQ2xvc2VIYW5kbGUoaGFuZGxlKQogICAgICAgIHJldHVybiBUcnVlLCAiQXBwbGllZCBwcmlvcml0eXt9LiIuZm9ybWF0KCIgKyBhZmZpbml0eSIgaWYgbWFzayBpcyBub3QgTm9uZSBlbHNlICIiKQogICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgIHJldHVybiBGYWxzZSwgZiJXaW4zMiBlcnJvcjoge2V9IgoKZGVmIGNwdV9jb3VudF9sb2dpY2FsKCkgLT4gaW50OgogICAgcmV0dXJuIG9zLmNwdV9jb3VudCgpIG9yIDgKCmRlZiBtYXNrX2FsbF9idXRfY3B1MCgpIC0+IGludDoKICAgIG4gPSBjcHVfY291bnRfbG9naWNhbCgpCiAgICByZXR1cm4gKCgxIDw8IG4pIC0gMSkgJiB+MHgxIGlmIG4gPiAxIGVsc2UgMQoKZGVmIHBhcnNlX2hleF9tYXNrKHM6IHN0cikgLT4gT3B0aW9uYWxbaW50XToKICAgIHMgPSAocyBvciAiIikuc3RyaXAoKQogICAgaWYgbm90IHM6CiAgICAgICAgcmV0dXJuIE5vbmUKICAgIGlmIHMubG93ZXIoKS5zdGFydHN3aXRoKCIweCIpOgogICAgICAgIHMgPSBzWzI6XQogICAgdHJ5OgogICAgICAgIHZhbCA9IGludChzLCAxNikKICAgICAgICByZXR1cm4gdmFsIGlmIHZhbCA+IDAgZWxzZSBOb25lCiAgICBleGNlcHQgVmFsdWVFcnJvcjoKICAgICAgICByZXR1cm4gTm9uZQoKIyA9PT09PSBTdG9yYWdlID09PT09CkFQUERBVEFfRElSID0gUGF0aChvcy5nZXRlbnYoIkFQUERBVEEiLCBzdHIoUGF0aC5ob21lKCkgLyAiQXBwRGF0YSIgLyAiUm9hbWluZyIpKSkgLyAiVW5pdmVyc2FsVVdQTGF1bmNoZXIiClNDUklQVF9ESVIgPSBQYXRoKF9fZmlsZV9fKS5yZXNvbHZlKCkucGFyZW50CkxPQ0FMX1NFVFRJTkdTID0gU0NSSVBUX0RJUiAvICJzZXR0aW5ncy5qc29uIgpBUFBEQVRBX0RJUi5ta2RpcihwYXJlbnRzPVRydWUsIGV4aXN0X29rPVRydWUpCkdBTUVTX1BBVEggPSBBUFBEQVRBX0RJUiAvICJnYW1lcy5qc29uIgpTRVRUSU5HU19QQVRIID0gTE9DQUxfU0VUVElOR1MgaWYgTE9DQUxfU0VUVElOR1MuZXhpc3RzKCkgZWxzZSAoQVBQREFUQV9ESVIgLyAic2V0dGluZ3MuanNvbiIpCgpERUZBVUxUX1NFVFRJTkdTID0gewogICAgImRlZmF1bHRfd2FpdCI6IDQ1LAogICAgImRlZmF1bHRfcHJpb3JpdHkiOiAiSGlnaCIsCn0KCmRlZiBfcmVhZF9qc29uKHBhdGg6IFBhdGgsIGRlZmF1bHQpOgogICAgaWYgbm90IHBhdGguZXhpc3RzKCk6CiAgICAgICAgcmV0dXJuIGRlZmF1bHQKICAgIHRyeToKICAgICAgICByZXR1cm4ganNvbi5sb2FkcyhwYXRoLnJlYWRfdGV4dChlbmNvZGluZz0idXRmLTgiKSkKICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgcmV0dXJuIGRlZmF1bHQKCmRlZiBfd3JpdGVfanNvbihwYXRoOiBQYXRoLCBvYmopIC0+IE5vbmU6CiAgICBwYXRoLndyaXRlX3RleHQoanNvbi5kdW1wcyhvYmosIGluZGVudD0yKSwgZW5jb2Rpbmc9InV0Zi04IikKCmRlZiBsb2FkX2dhbWVzKCkgLT4gRGljdFtzdHIsIEFueV06CiAgICBkYXRhID0gX3JlYWRfanNvbihHQU1FU19QQVRILCB7ImdhbWVzIjogW119KQogICAgaWYgbm90IGlzaW5zdGFuY2UoZGF0YS5nZXQoImdhbWVzIiksIGxpc3QpOgogICAgICAgIGRhdGFbImdhbWVzIl0gPSBbXQogICAgcmV0dXJuIGRhdGEKCmRlZiBzYXZlX2dhbWVzKGRhdGE6IERpY3Rbc3RyLCBBbnldKSAtPiBOb25lOgogICAgX3dyaXRlX2pzb24oR0FNRVNfUEFUSCwgZGF0YSkKCmRlZiBsb2FkX3NldHRpbmdzKCkgLT4gRGljdFtzdHIsIEFueV06CiAgICBzID0gX3JlYWRfanNvbihTRVRUSU5HU19QQVRILCBERUZBVUxUX1NFVFRJTkdTLmNvcHkoKSkKICAgIGZvciBrLCB2IGluIERFRkFVTFRfU0VUVElOR1MuaXRlbXMoKToKICAgICAgICBzLnNldGRlZmF1bHQoaywgdikKICAgIHJldHVybiBzCgpkZWYgc2F2ZV9zZXR0aW5ncyhzOiBEaWN0W3N0ciwgQW55XSkgLT4gTm9uZToKICAgIF93cml0ZV9qc29uKFNFVFRJTkdTX1BBVEgsIHMpCgojID09PT09IFVXUCBkaXNjb3ZlcnkgdmlhIFBvd2VyU2hlbGwgPT09PT0KZGVmIGxpc3RfdXdwX2FwcHMoKSAtPiBMaXN0W1R1cGxlW3N0ciwgc3RyXV06CiAgICAiIiJSZXR1cm4gKE5hbWUsIEFwcElEKSB1c2luZyBQb3dlclNoZWxsIEdldC1TdGFydEFwcHMuIiIiCiAgICB0cnk6CiAgICAgICAgY21kID0gWwogICAgICAgICAgICAicG93ZXJzaGVsbCIsICItTm9Qcm9maWxlIiwgIi1FeGVjdXRpb25Qb2xpY3kiLCAiQnlwYXNzIiwKICAgICAgICAgICAgIkdldC1TdGFydEFwcHMgfCBTZWxlY3QtT2JqZWN0IE5hbWUsQXBwSUQgfCBDb252ZXJ0VG8tSnNvbiAtRGVwdGggMiIKICAgICAgICBdCiAgICAgICAgb3V0ID0gc3VicHJvY2Vzcy5jaGVja19vdXRwdXQoY21kLCBjcmVhdGlvbmZsYWdzPXN1YnByb2Nlc3MuQ1JFQVRFX05PX1dJTkRPVykuZGVjb2RlKCJ1dGYtOCIsIGVycm9ycz0iaWdub3JlIikuc3RyaXAoKQogICAgICAgIGlmIG5vdCBvdXQ6CiAgICAgICAgICAgIHJldHVybiBbXQogICAgICAgIGRhdGEgPSBqc29uLmxvYWRzKG91dCkKICAgICAgICBpdGVtcyA9IGRhdGEgaWYgaXNpbnN0YW5jZShkYXRhLCBsaXN0KSBlbHNlIFtkYXRhXQogICAgICAgIGFwcHMgPSBbKGl0LmdldCgiTmFtZSIsIiIpLCBpdC5nZXQoIkFwcElEIiwiIikpIGZvciBpdCBpbiBpdGVtcyBpZiBpdCBhbmQgaXQuZ2V0KCJOYW1lIikgYW5kIGl0LmdldCgiQXBwSUQiKV0KICAgICAgICBhcHBzLnNvcnQoa2V5PWxhbWJkYSB4OiB4WzBdLmxvd2VyKCkpCiAgICAgICAgcmV0dXJuIGFwcHMKICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgcmV0dXJuIFtdCgojID09PT09IERlc2t0b3Agc2hvcnRjdXQgaGVscGVyIChvcHRpb25hbCkgPT09PT0KZGVmIG1ha2Vfd2luZG93c19zaG9ydGN1dCh0YXJnZXRfZXhlOiBzdHIsIGFyZ3M6IHN0ciwgb3V0X3BhdGg6IFBhdGgsIGljb25fcGF0aDogT3B0aW9uYWxbc3RyXSA9IE5vbmUpIC0+IFR1cGxlW2Jvb2wsIHN0cl06CiAgICB0cnk6CiAgICAgICAgb3V0X3BhdGggPSBvdXRfcGF0aC53aXRoX3N1ZmZpeCgiLmxuayIpCiAgICAgICAgb3V0X2VzYyAgID0gc3RyKG91dF9wYXRoKS5yZXBsYWNlKCInIiwgIicnIikKICAgICAgICB0Z3RfZXNjICAgPSB0YXJnZXRfZXhlLnJlcGxhY2UoIiciLCAiJyciKQogICAgICAgIGFyZ3NfZXNjICA9IGFyZ3MucmVwbGFjZSgiJyIsICInJyIpCiAgICAgICAgd29ya2RpciAgID0gc3RyKFBhdGgodGFyZ2V0X2V4ZSkucGFyZW50KS5yZXBsYWNlKCInIiwgIicnIikKCiAgICAgICAgcHMgID0gIiRXc2hTaGVsbCA9IE5ldy1PYmplY3QgLUNvbU9iamVjdCBXU2NyaXB0LlNoZWxsXG4iCiAgICAgICAgcHMgKz0gIiRTaG9ydGN1dCA9ICRXc2hTaGVsbC5DcmVhdGVTaG9ydGN1dCgne30nKVxuIi5mb3JtYXQob3V0X2VzYykKICAgICAgICBwcyArPSAiJFNob3J0Y3V0LlRhcmdldFBhdGggPSAne30nXG4iLmZvcm1hdCh0Z3RfZXNjKQogICAgICAgIHBzICs9ICIkU2hvcnRjdXQuQXJndW1lbnRzICA9ICd7fSdcbiIuZm9ybWF0KGFyZ3NfZXNjKQogICAgICAgIHBzICs9ICIkU2hvcnRjdXQuV29ya2luZ0RpcmVjdG9yeSA9ICd7fSdcbiIuZm9ybWF0KHdvcmtkaXIpCiAgICAgICAgaWYgaWNvbl9wYXRoOgogICAgICAgICAgICBwcyArPSAiJFNob3J0Y3V0Lkljb25Mb2NhdGlvbiA9ICd7fSdcbiIuZm9ybWF0KGljb25fcGF0aC5yZXBsYWNlKCInIiwgIicnIikpCiAgICAgICAgcHMgKz0gIiRTaG9ydGN1dC5TYXZlKClcbiIKCiAgICAgICAgc3VicHJvY2Vzcy5jaGVja19jYWxsKFsicG93ZXJzaGVsbCIsIi1Ob1Byb2ZpbGUiLCItRXhlY3V0aW9uUG9saWN5IiwiQnlwYXNzIiwgcHNdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGlvbmZsYWdzPXN1YnByb2Nlc3MuQ1JFQVRFX05PX1dJTkRPVykKICAgICAgICByZXR1cm4gVHJ1ZSwgc3RyKG91dF9wYXRoKQogICAgZXhjZXB0IHN1YnByb2Nlc3MuQ2FsbGVkUHJvY2Vzc0Vycm9yIGFzIGU6CiAgICAgICAgcmV0dXJuIEZhbHNlLCBmIlBvd2VyU2hlbGwgZmFpbGVkOiB7ZX0iCiAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgcmV0dXJuIEZhbHNlLCBmIlNob3J0Y3V0IGVycm9yOiB7ZX0iCgpkZWYgdGhpc19weXRob25fZXhlY3V0YWJsZSgpIC0+IHN0cjoKICAgIHJldHVybiBzeXMuZXhlY3V0YWJsZQoKIyA9PT09PSBXb3JrZXI6IEFjdGl2YXRlICsgdHVuZSA9PT09PQpjbGFzcyBMYXVuY2hXb3JrZXIoUXRDb3JlLlFUaHJlYWQpOgogICAgbG9nX3NpZ25hbCAgPSBRdENvcmUucHlxdFNpZ25hbChzdHIsIHN0cikKICAgIGRvbmVfc2lnbmFsID0gUXRDb3JlLnB5cXRTaWduYWwoYm9vbCwgc3RyKQoKICAgIGRlZiBfX2luaXRfXyhzZWxmLCBjZmc6IERpY3Rbc3RyLCBBbnldKToKICAgICAgICBzdXBlcigpLl9faW5pdF9fKCkKICAgICAgICBzZWxmLmNmZyA9IGNmZwoKICAgIGRlZiBsb2coc2VsZiwgbXNnOiBzdHIsIGxldmVsOiBzdHIgPSAiaW5mbyIpOgogICAgICAgIHNlbGYubG9nX3NpZ25hbC5lbWl0KGxldmVsLCBtc2cpCgogICAgZGVmIHJ1bihzZWxmKToKICAgICAgICB0cnk6CiAgICAgICAgICAgIHNlbGYuX3J1bl9pbXBsKCkKICAgICAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgICAgIHNlbGYubG9nKCJFUlJPUjogIiArICIiLmpvaW4odHJhY2ViYWNrLmZvcm1hdF9leGNlcHRpb24oZSkpLCAiZXJyb3IiKQogICAgICAgICAgICBzZWxmLmRvbmVfc2lnbmFsLmVtaXQoRmFsc2UsIHN0cihlKSkKCiAgICBkZWYgX3J1bl9pbXBsKHNlbGYpOgogICAgICAgICMgT3B0aW9uYWw6IFN0ZWFtIHZhbGlkYXRpb24KICAgICAgICB2YWxpZGF0ZV9vbmx5ID0gYm9vbChzZWxmLmNmZy5nZXQoInZhbGlkYXRlX29ubHkiLCBGYWxzZSkpCiAgICAgICAgYXBwaWQgPSBzdHIoc2VsZi5jZmcuZ2V0KCJzdGVhbV9hcHBpZCIsICIiKSBvciAiIikuc3RyaXAoKQogICAgICAgIGlmICh2YWxpZGF0ZV9vbmx5IG9yIGJvb2woc2VsZi5jZmcuZ2V0KCJ2YWxpZGF0ZV9zdGVhbSIsIEZhbHNlKSkpIGFuZCBhcHBpZC5pc2RpZ2l0KCk6CiAgICAgICAgICAgIHRpbWVvdXRfcyA9IGludChzZWxmLmNmZy5nZXQoInZhbGlkYXRlX3RpbWVvdXQiLCA5MDApIG9yIDkwMCkKICAgICAgICAgICAgb2ssIG1zZyA9IHN0ZWFtX3ZhbGlkYXRlX2FuZF93YWl0KGFwcGlkLCB0aW1lb3V0X3M9dGltZW91dF9zKQogICAgICAgICAgICBzZWxmLmxvZyhtc2csICJpbmZvIiBpZiBvayBlbHNlICJ3YXJuIikKICAgICAgICAgICAgaWYgdmFsaWRhdGVfb25seToKICAgICAgICAgICAgICAgIHNlbGYuZG9uZV9zaWduYWwuZW1pdChvaywgbXNnKQogICAgICAgICAgICAgICAgcmV0dXJuCgogICAgICAgIGF1bWlkID0gKHNlbGYuY2ZnLmdldCgiYXVtaWQiKSBvciAiIikuc3RyaXAoKQogICAgICAgIGlmIG5vdCBhdW1pZDoKICAgICAgICAgICAgc2VsZi5kb25lX3NpZ25hbC5lbWl0KEZhbHNlLCAiTWlzc2luZyBBVU1JRCIpCiAgICAgICAgICAgIHJldHVybgoKICAgICAgICBhcmdzID0gKHNlbGYuY2ZnLmdldCgiZmxhZ3MiKSBvciAiIikuc3RyaXAoKQogICAgICAgIGV4ZV9uYW1lID0gKHNlbGYuY2ZnLmdldCgiZXhlX25hbWUiKSBvciAiIikuc3RyaXAoKQogICAgICAgIHdhaXRfcyA9IGludChzZWxmLmNmZy5nZXQoIndhaXRfc2Vjb25kcyIpIG9yIDQ1KQogICAgICAgIHByaW9yaXR5X2Nob2ljZSA9IHNlbGYuY2ZnLmdldCgicHJpb3JpdHkiKSBvciAiSGlnaCIKICAgICAgICBwcmlvcml0eV9jb25zdCAgPSBQUklPUklUWV9NQVAuZ2V0KHByaW9yaXR5X2Nob2ljZSwgSElHSF9QUklPUklUWV9DTEFTUykKCiAgICAgICAgIyBBZmZpbml0eQogICAgICAgIGFmZmluaXR5X2hleCA9IChzZWxmLmNmZy5nZXQoImFmZmluaXR5X2hleCIpIG9yICIiKS5zdHJpcCgpCiAgICAgICAgaWYgc2VsZi5jZmcuZ2V0KCJhdXRvX2FmZmluaXR5IiwgVHJ1ZSkgYW5kIG5vdCBhZmZpbml0eV9oZXg6CiAgICAgICAgICAgIG1hc2sgPSBtYXNrX2FsbF9idXRfY3B1MCgpCiAgICAgICAgICAgIG1hc2tfbm90ZSA9ICJhdXRvIChhbGwgYnV0IENQVTApIDB4ezpYfSIuZm9ybWF0KG1hc2spCiAgICAgICAgZWxzZToKICAgICAgICAgICAgbWFzayA9IHBhcnNlX2hleF9tYXNrKGFmZmluaXR5X2hleCkKICAgICAgICAgICAgbWFza19ub3RlID0gIjB4ezpYfSIuZm9ybWF0KG1hc2spIGlmIG1hc2sgaXMgbm90IE5vbmUgZWxzZSAiTm9uZSIKCiAgICAgICAgc2VsZi5sb2coZiJBY3RpdmF0ZSBBVU1JRDoge2F1bWlkfSIpCiAgICAgICAgc2VsZi5sb2coZiJBcmdzOiB7YXJncyBvciAnKG5vbmUpJ30gfCBFWEU6IHtleGVfbmFtZSBvciAnKGF1dG8tZGV0ZWN0KSd9IikKICAgICAgICBzZWxmLmxvZyhmIldhaXQ6IHt3YWl0X3N9cyB8IFByaW9yaXR5OiB7cHJpb3JpdHlfY2hvaWNlfSB8IEFmZmluaXR5OiB7bWFza19ub3RlfSIpCgogICAgICAgICMgU25hcHNob3QgYmVmb3JlIGxhdW5jaCAob3B0aW1pemU6IHN0b3JlIHNldCBmb3IgTygxKSBtZW1iZXJzaGlwKQogICAgICAgIGJlZm9yZV9waWRzID0gc2V0KHBzdXRpbC5waWRzKCkpCgoKICAgICAgICAjIEFjdGl2YXRlIChBVU1JRCB2cyBwcm90b2NvbCBVUkwpCiAgICAgICAgcm9vdF9waWQgPSAwCiAgICAgICAgaWYgIjovLyIgaW4gYXVtaWQ6CiAgICAgICAgICAgIGlmIG5vdCBfb3Blbl9zdGVhbV91cmwoYXVtaWQpOgogICAgICAgICAgICAgICAgc2VsZi5kb25lX3NpZ25hbC5lbWl0KEZhbHNlLCAiRmFpbGVkIHRvIG9wZW4gVVJMOiAiICsgYXVtaWQpCiAgICAgICAgICAgICAgICByZXR1cm4KICAgICAgICAgICAgc2VsZi5sb2coIkFjdGl2YXRlZCB2aWEgVVJMIHByb3RvY29sIChubyByb290IFBJRCkuIikKICAgICAgICBlbHNlOgogICAgICAgICAgICBhYW0gPSBfY3JlYXRlX2FjdGl2YXRpb25fbWFuYWdlcigpCiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIHJlc3VsdCA9IGFhbS5BY3RpdmF0ZUFwcGxpY2F0aW9uKGF1bWlkLCBhcmdzLCBBT19OT05FKQogICAgICAgICAgICAgICAgcm9vdF9waWQgPSBpbnQocmVzdWx0WzBdKSBpZiBpc2luc3RhbmNlKHJlc3VsdCwgdHVwbGUpIGVsc2UgaW50KHJlc3VsdCkKICAgICAgICAgICAgZXhjZXB0IGNvbXR5cGVzLkNPTUVycm9yIGFzIGU6CiAgICAgICAgICAgICAgICBzZWxmLmRvbmVfc2lnbmFsLmVtaXQoRmFsc2UsICJBY3RpdmF0ZUFwcGxpY2F0aW9uIGZhaWxlZDogSFJFU1VMVCAweHs6MDhYfSIuZm9ybWF0KGUuaHJlc3VsdCAmIDB4RkZGRkZGRkYpKQogICAgICAgICAgICAgICAgcmV0dXJuCgogICAgICAgICAgICAgICAgc2VsZi5sb2coZiJBY3RpdmF0ZWQsIHJvb3QgUElEOiB7cm9vdF9waWR9IikKCiAgICAgICAgICAgICAgICBpZ25vcmVfc3Vic3RyaW5ncyA9ICgiZXhwbG9yZXIiLCAiY29uaG9zdCIsICJwb3dlcnNoZWxsIikKCiAgICAgICAgICAgICAgICBkZWYgY2FuZGlkYXRlX2NoaWxkcmVuKCkgLT4gTGlzdFtpbnRdOgogICAgICAgICAgICAgICAgICAgICMgUHJlZmVyIGNoaWxkcmVuIG9mIHRoZSBhY3RpdmF0aW9uIHJvb3Q7IGZhbGwgYmFjayB0byDigJxuZXcgc2luY2Ugc25hcHNob3TigJ0KICAgICAgICAgICAgICAgICAgICBvdXQgPSBbXQogICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgZm9yIGMgaW4gcHN1dGlsLlByb2Nlc3Mocm9vdF9waWQpLmNoaWxkcmVuKHJlY3Vyc2l2ZT1UcnVlKToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBubSA9IChjLm5hbWUoKSBvciAiIikubG93ZXIoKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIGFsbCh4IG5vdCBpbiBubSBmb3IgeCBpbiBpZ25vcmVfc3Vic3RyaW5ncyk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dC5hcHBlbmQoYy5waWQpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQgcHN1dGlsLkVycm9yOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgICAgICAgICBleGNlcHQgcHN1dGlsLkVycm9yOgogICAgICAgICAgICAgICAgICAgICAgICBwYXNzCiAgICAgICAgICAgICAgICAgICAgaWYgbm90IG91dDoKICAgICAgICAgICAgICAgICAgICAgICAgbm93X3NldCA9IHNldChwc3V0aWwucGlkcygpKQogICAgICAgICAgICAgICAgICAgICAgICBmb3IgcGlkIGluIG5vd19zZXQgLSBiZWZvcmVfcGlkczoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBubSA9IHBzdXRpbC5Qcm9jZXNzKHBpZCkubmFtZSgpLmxvd2VyKCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBhbGwoeCBub3QgaW4gbm0gZm9yIHggaW4gaWdub3JlX3N1YnN0cmluZ3MpOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQuYXBwZW5kKHBpZCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdCBwc3V0aWwuRXJyb3I6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzcwogICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXQKCiAgICAgICAgICAgICAgICBkZWYgdHJ5X21hdGNoX2J5X25hbWUobmFtZTogc3RyKSAtPiBMaXN0W2ludF06CiAgICAgICAgICAgICAgICAgICAgaWYgbm90IG5hbWU6CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXQogICAgICAgICAgICAgICAgICAgIG5hbWVfbCA9IG5hbWUubG93ZXIoKQogICAgICAgICAgICAgICAgICAgIG91dCA9IFtdCiAgICAgICAgICAgICAgICAgICAgIyBvcHRpbWl6ZTogc2luZ2xlIHBhc3Mgb3ZlciBwcm9jZXNzZXMgd2l0aCBjYWNoZWQgYXR0cnMKICAgICAgICAgICAgICAgICAgICBmb3IgcCBpbiBwc3V0aWwucHJvY2Vzc19pdGVyKFsicGlkIiwgIm5hbWUiXSk6CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwLmluZm8uZ2V0KCJuYW1lIikgb3IgIiIpLmxvd2VyKCkgPT0gbmFtZV9sOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0LmFwcGVuZChwLmluZm9bInBpZCJdKQogICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXQKCiAgICAgICAgICAgICAgICAjIFBvbGwgZm9yIHRoZSBnYW1lIHByb2Nlc3MKICAgICAgICAgICAgICAgIGRlYWRsaW5lID0gdGltZS50aW1lKCkgKyBtYXgoNSwgd2FpdF9zKQogICAgICAgICAgICAgICAgdGFyZ2V0X3BpZHM6IExpc3RbaW50XSA9IFtdCiAgICAgICAgICAgICAgICB3aGlsZSB0aW1lLnRpbWUoKSA8IGRlYWRsaW5lIGFuZCBub3QgdGFyZ2V0X3BpZHM6CiAgICAgICAgICAgICAgICAgICAgdGltZS5zbGVlcCgwLjQpICAjIHNsaWdodGx5IGZhc3RlciB0aGFuIDAuNXMgd2l0aG91dCBiZWluZyBidXN5CiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0X3BpZHMgPSB0cnlfbWF0Y2hfYnlfbmFtZShleGVfbmFtZSkgaWYgZXhlX25hbWUgZWxzZSBbXQogICAgICAgICAgICAgICAgICAgIGlmIG5vdCB0YXJnZXRfcGlkczoKICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0X3BpZHMgPSBjYW5kaWRhdGVfY2hpbGRyZW4oKQoKICAgICAgICAgICAgICAgIGlmIG5vdCB0YXJnZXRfcGlkczoKICAgICAgICAgICAgICAgICAgICBzZWxmLmxvZyhmIlRpbWVvdXQ6IGRpZG7igJl0IHNlZSB0YXJnZXQgcHJvY2VzcyB3aXRoaW4ge3dhaXRfc31zLiIsICJ3YXJuIikKICAgICAgICAgICAgICAgICAgICBzZWxmLmRvbmVfc2lnbmFsLmVtaXQoRmFsc2UsICJUYXJnZXQgRVhFIG5vdCBmb3VuZCIpCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuCgogICAgICAgICAgICAgICAgIyBBcHBseSB0dW5pbmcKICAgICAgICAgICAgICAgIG9rX2NvdW50ID0gMAogICAgICAgICAgICAgICAgZm9yIHBpZCBpbiB0YXJnZXRfcGlkczoKICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgIG5tID0gcHN1dGlsLlByb2Nlc3MocGlkKS5uYW1lKCkKICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5sb2coZiJBcHBseWluZyB0byBQSUQge3BpZH0gKHtubX0pIOKApiIpCiAgICAgICAgICAgICAgICAgICAgICAgIG9rLCBtc2cgPSBzZXRfcHJpb3JpdHlfYW5kX2FmZmluaXR5KHBpZCwgcHJpb3JpdHlfY29uc3QsIG1hc2spCiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubG9nKCgiICDinJMgIiBpZiBvayBlbHNlICIgIOKclyAiKSArIG1zZywgIm9rIiBpZiBvayBlbHNlICJ3YXJuIikKICAgICAgICAgICAgICAgICAgICAgICAgaWYgb2s6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBva19jb3VudCArPSAxCiAgICAgICAgICAgICAgICAgICAgZXhjZXB0IHBzdXRpbC5Ob1N1Y2hQcm9jZXNzOgogICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmxvZyhmIlBJRCB7cGlkfSB2YW5pc2hlZC4iLCAid2FybiIpCiAgICAgICAgICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmxvZyhmIkVycm9yIG9uIFBJRCB7cGlkfToge2V9IiwgImVycm9yIikKCiAgICAgICAgICAgICAgICBzZWxmLmRvbmVfc2lnbmFsLmVtaXQob2tfY291bnQgPiAwLCAoIlVwZGF0ZWQge30gcHJvY2VzcyhlcykiLmZvcm1hdChva19jb3VudCkgaWYgb2tfY291bnQgZWxzZSAiTm8gcHJvY2Vzc2VzIHVwZGF0ZWQiKSkKCiMgPT09PT0gQWRkL0VkaXQgZGlhbG9nID09PT09CmNsYXNzIEdhbWVEaWFsb2coUXRXaWRnZXRzLlFEaWFsb2cpOgogICAgZGVmIF9faW5pdF9fKHNlbGYsIHBhcmVudCwgc2V0dGluZ3M6IERpY3Rbc3RyLCBBbnldLCBkYXRhOiBPcHRpb25hbFtEaWN0W3N0ciwgQW55XV0gPSBOb25lKToKICAgICAgICBzdXBlcigpLl9faW5pdF9fKHBhcmVudCkKICAgICAgICBzZWxmLnNldFdpbmRvd1RpdGxlKCJBZGQgLyBFZGl0IFVXUCBHYW1lIikKICAgICAgICBzZWxmLnJlc2l6ZSg2MDAsIDQxMCkKICAgICAgICBzZWxmLnNldHRpbmdzID0gc2V0dGluZ3MKICAgICAgICBzZWxmLmRhdGEgPSBkYXRhIG9yIHt9CgogICAgICAgIGxheW91dCA9IFF0V2lkZ2V0cy5RVkJveExheW91dChzZWxmKQoKICAgICAgICAjIFVXUCBhcHBzCiAgICAgICAgcm93X2FwcCA9IFF0V2lkZ2V0cy5RSEJveExheW91dCgpCiAgICAgICAgc2VsZi5hcHBfY29tYm8gPSBRdFdpZGdldHMuUUNvbWJvQm94KCkKICAgICAgICBzZWxmLmFwcF9jb21iby5hZGRJdGVtKCLigJQgKG1hbnVhbCBBVU1JRCkg4oCUIiwgIiIpCiAgICAgICAgc2VsZi5idG5fcmVmcmVzaCA9IFF0V2lkZ2V0cy5RUHVzaEJ1dHRvbigiUmVmcmVzaCBVV1AgQXBwcyIpCiAgICAgICAgc2VsZi5idG5fcmVmcmVzaC5jbGlja2VkLmNvbm5lY3Qoc2VsZi5fbG9hZF91d3BfbGlzdCkKICAgICAgICByb3dfYXBwLmFkZFdpZGdldChRdFdpZGdldHMuUUxhYmVsKCJJbnN0YWxsZWQgVVdQIEFwcHMiKSkKICAgICAgICByb3dfYXBwLmFkZFdpZGdldChzZWxmLmFwcF9jb21ibywgMSkKICAgICAgICByb3dfYXBwLmFkZFdpZGdldChzZWxmLmJ0bl9yZWZyZXNoKQoKICAgICAgICAjIEZvcm0KICAgICAgICBmb3JtID0gUXRXaWRnZXRzLlFGb3JtTGF5b3V0KCkKICAgICAgICBzZWxmLmF1bWlkX2VkaXQgPSBRdFdpZGdldHMuUUxpbmVFZGl0KHNlbGYuZGF0YS5nZXQoImF1bWlkIiwgIiIpKQogICAgICAgIHNlbGYubmFtZV9lZGl0ICA9IFF0V2lkZ2V0cy5RTGluZUVkaXQoc2VsZi5kYXRhLmdldCgibmFtZSIsICIiKSkKICAgICAgICBzZWxmLm5hbWVfZWRpdC5zZXRQbGFjZWhvbGRlclRleHQoIkRpc3BsYXkgbmFtZSBpbiBsYXVuY2hlciIpCiAgICAgICAgc2VsZi5mbGFnc19lZGl0ID0gUXRXaWRnZXRzLlFMaW5lRWRpdChzZWxmLmRhdGEuZ2V0KCJmbGFncyIsICIiKSkKICAgICAgICBzZWxmLmZsYWdzX2VkaXQuc2V0UGxhY2Vob2xkZXJUZXh0KCJBcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBhcHAiKQogICAgICAgIHNlbGYuZXhlX2VkaXQgICA9IFF0V2lkZ2V0cy5RTGluZUVkaXQoc2VsZi5kYXRhLmdldCgiZXhlX25hbWUiLCAiIikpCiAgICAgICAgc2VsZi5leGVfZWRpdC5zZXRQbGFjZWhvbGRlclRleHQoIkV4YWN0IHRhcmdldCBFWEUgKG9wdGlvbmFsLCBpbXByb3ZlcyBtYXRjaGluZykiKQoKICAgICAgICBzZWxmLndhaXRfc3BpbiAgPSBRdFdpZGdldHMuUVNwaW5Cb3goKTsgc2VsZi53YWl0X3NwaW4uc2V0UmFuZ2UoNSwgNjAwKTsgc2VsZi53YWl0X3NwaW4uc2V0VmFsdWUoaW50KHNlbGYuZGF0YS5nZXQoIndhaXRfc2Vjb25kcyIsIHNlbGYuc2V0dGluZ3MuZ2V0KCJkZWZhdWx0X3dhaXQiLCA0NSkpKSkKICAgICAgICBzZWxmLnByaW9fY29tYm8gPSBRdFdpZGdldHMuUUNvbWJvQm94KCk7IHNlbGYucHJpb19jb21iby5hZGRJdGVtcyhsaXN0KFBSSU9SSVRZX01BUC5rZXlzKCkpKTsgc2VsZi5wcmlvX2NvbWJvLnNldEN1cnJlbnRUZXh0KHNlbGYuZGF0YS5nZXQoInByaW9yaXR5Iiwgc2VsZi5zZXR0aW5ncy5nZXQoImRlZmF1bHRfcHJpb3JpdHkiLCAiSGlnaCIpKSkKICAgICAgICBzZWxmLmF1dG9fYWZmICAgPSBRdFdpZGdldHMuUUNoZWNrQm94KCJBdXRvIGFmZmluaXR5IChhbGwgYnV0IENQVTApIik7IHNlbGYuYXV0b19hZmYuc2V0Q2hlY2tlZChib29sKHNlbGYuZGF0YS5nZXQoImF1dG9fYWZmaW5pdHkiLCBUcnVlKSkpCiAgICAgICAgc2VsZi5hZmZfaGV4ICAgID0gUXRXaWRnZXRzLlFMaW5lRWRpdChzZWxmLmRhdGEuZ2V0KCJhZmZpbml0eV9oZXgiLCAiIikpOyBzZWxmLmFmZl9oZXguc2V0UGxhY2Vob2xkZXJUZXh0KCJIZXggbWFzayAoZS5nLiwgMHhGRSkgaWYgbm90IHVzaW5nIEF1dG8iKQoKICAgICAgICBmb3JtLmFkZFJvdygiRGlzcGxheSBOYW1lIiwgc2VsZi5uYW1lX2VkaXQpCiAgICAgICAgZm9ybS5hZGRSb3coIkFVTUlEIChBcHBJRCkiLCBzZWxmLmF1bWlkX2VkaXQpCiAgICAgICAgZm9ybS5hZGRSb3coIkFyZ3VtZW50cyIsIHNlbGYuZmxhZ3NfZWRpdCkKICAgICAgICBmb3JtLmFkZFJvdygiVGFyZ2V0IEVYRSIsIHNlbGYuZXhlX2VkaXQpCiAgICAgICAgc2VsZi5zdGVhbV9hcHBpZF9lZGl0ID0gUXRXaWRnZXRzLlFMaW5lRWRpdChzZWxmLmRhdGEuZ2V0KCJzdGVhbV9hcHBpZCIsICIiKSkKICAgICAgICBzZWxmLnN0ZWFtX2FwcGlkX2VkaXQuc2V0UGxhY2Vob2xkZXJUZXh0KCJlLmcuIDEyMzQ1NiAob3B0aW9uYWwpIikKICAgICAgICBzZWxmLnZhbGlkYXRlX2NiID0gUXRXaWRnZXRzLlFDaGVja0JveCgiVmFsaWRhdGUgdmlhIFN0ZWFtIGJlZm9yZSBsYXVuY2giKQogICAgICAgIHNlbGYudmFsaWRhdGVfY2Iuc2V0Q2hlY2tlZChib29sKHNlbGYuZGF0YS5nZXQoInZhbGlkYXRlX3N0ZWFtIiwgRmFsc2UpKSkKICAgICAgICBzZWxmLnZhbGlkYXRlX3RpbWVvdXQgPSBRdFdpZGdldHMuUVNwaW5Cb3goKQogICAgICAgIHNlbGYudmFsaWRhdGVfdGltZW91dC5zZXRSYW5nZSg2MCwgNzIwMCkKICAgICAgICBzZWxmLnZhbGlkYXRlX3RpbWVvdXQuc2V0VmFsdWUoaW50KHNlbGYuZGF0YS5nZXQoInZhbGlkYXRlX3RpbWVvdXQiLCA5MDApKSkKICAgICAgICBmb3JtLmFkZFJvdygiU3RlYW0gQXBwSUQiLCBzZWxmLnN0ZWFtX2FwcGlkX2VkaXQpCiAgICAgICAgZm9ybS5hZGRSb3coIiIsIHNlbGYudmFsaWRhdGVfY2IpCiAgICAgICAgZm9ybS5hZGRSb3coIlZhbGlkYXRpb24gdGltZW91dCAocykiLCBzZWxmLnZhbGlkYXRlX3RpbWVvdXQpCiAgICAgICAgZm9ybS5hZGRSb3coIldhaXQgKHMpIiwgc2VsZi53YWl0X3NwaW4pCiAgICAgICAgZm9ybS5hZGRSb3coIlByaW9yaXR5Iiwgc2VsZi5wcmlvX2NvbWJvKQoKICAgICAgICAjIEFmZmluaXR5IHJvdwogICAgICAgIGFmZl9yb3cgPSBRdFdpZGdldHMuUUhCb3hMYXlvdXQoKQogICAgICAgIGFmZl9yb3cuYWRkV2lkZ2V0KHNlbGYuYXV0b19hZmYpCiAgICAgICAgYWZmX3Jvdy5hZGRTcGFjaW5nKDEwKQogICAgICAgIGFmZl9yb3cuYWRkV2lkZ2V0KFF0V2lkZ2V0cy5RTGFiZWwoIkFmZmluaXR5IChoZXgpIikpCiAgICAgICAgYWZmX3Jvdy5hZGRXaWRnZXQoc2VsZi5hZmZfaGV4LCAxKQoKICAgICAgICAjIEJ1dHRvbnMKICAgICAgICBidG5zID0gUXRXaWRnZXRzLlFEaWFsb2dCdXR0b25Cb3goUXRXaWRnZXRzLlFEaWFsb2dCdXR0b25Cb3guU3RhbmRhcmRCdXR0b24uT2sgfCBRdFdpZGdldHMuUURpYWxvZ0J1dHRvbkJveC5TdGFuZGFyZEJ1dHRvbi5DYW5jZWwpCgogICAgICAgIGxheW91dC5hZGRMYXlvdXQocm93X2FwcCkKICAgICAgICBsYXlvdXQuYWRkTGF5b3V0KGZvcm0pCiAgICAgICAgbGF5b3V0LmFkZExheW91dChhZmZfcm93KQogICAgICAgIGxheW91dC5hZGRXaWRnZXQoYnRucykKCiAgICAgICAgYnRucy5hY2NlcHRlZC5jb25uZWN0KHNlbGYuYWNjZXB0KQogICAgICAgIGJ0bnMucmVqZWN0ZWQuY29ubmVjdChzZWxmLnJlamVjdCkKCiAgICAgICAgc2VsZi5fbG9hZF91d3BfbGlzdCgpCiAgICAgICAgaWYgc2VsZi5hdW1pZF9lZGl0LnRleHQoKToKICAgICAgICAgICAgZm9yIGkgaW4gcmFuZ2Uoc2VsZi5hcHBfY29tYm8uY291bnQoKSk6CiAgICAgICAgICAgICAgICBpZiBzZWxmLmFwcF9jb21iby5pdGVtRGF0YShpKSA9PSBzZWxmLmF1bWlkX2VkaXQudGV4dCgpOgogICAgICAgICAgICAgICAgICAgIHNlbGYuYXBwX2NvbWJvLnNldEN1cnJlbnRJbmRleChpKQogICAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgc2VsZi5hcHBfY29tYm8uY3VycmVudEluZGV4Q2hhbmdlZC5jb25uZWN0KHNlbGYuX2NvbWJvX2NoYW5nZWQpCgogICAgZGVmIF9jb21ib19jaGFuZ2VkKHNlbGYsIGlkeDogaW50KToKICAgICAgICBhdW1pZCA9IHNlbGYuYXBwX2NvbWJvLml0ZW1EYXRhKGlkeCkKICAgICAgICBuYW1lICA9IHNlbGYuYXBwX2NvbWJvLmN1cnJlbnRUZXh0KCkKICAgICAgICBpZiBhdW1pZDoKICAgICAgICAgICAgc2VsZi5hdW1pZF9lZGl0LnNldFRleHQoYXVtaWQpCiAgICAgICAgICAgIGlmIG5vdCBzZWxmLm5hbWVfZWRpdC50ZXh0KCkuc3RyaXAoKToKICAgICAgICAgICAgICAgIHNlbGYubmFtZV9lZGl0LnNldFRleHQobmFtZSkKCiAgICBkZWYgX2xvYWRfdXdwX2xpc3Qoc2VsZik6CiAgICAgICAgc2VsZi5hcHBfY29tYm8uYmxvY2tTaWduYWxzKFRydWUpCiAgICAgICAgd2hpbGUgc2VsZi5hcHBfY29tYm8uY291bnQoKSA+IDE6CiAgICAgICAgICAgIHNlbGYuYXBwX2NvbWJvLnJlbW92ZUl0ZW0oMSkKICAgICAgICBhcHBzID0gbGlzdF91d3BfYXBwcygpCiAgICAgICAgaWYgbm90IGFwcHM6CiAgICAgICAgICAgIHNlbGYuYXBwX2NvbWJvLmFkZEl0ZW0oIihObyBhcHBzIGRldGVjdGVkKSIsICIiKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIGZvciBubSwgYWlkIGluIGFwcHM6CiAgICAgICAgICAgICAgICBzZWxmLmFwcF9jb21iby5hZGRJdGVtKG5tLCBhaWQpCiAgICAgICAgc2VsZi5hcHBfY29tYm8uYmxvY2tTaWduYWxzKEZhbHNlKQoKICAgIGRlZiByZXN1bHRfZGF0YShzZWxmKSAtPiBPcHRpb25hbFtEaWN0W3N0ciwgQW55XV06CiAgICAgICAgbmFtZSA9IHNlbGYubmFtZV9lZGl0LnRleHQoKS5zdHJpcCgpCiAgICAgICAgYXVtaWQgPSBzZWxmLmF1bWlkX2VkaXQudGV4dCgpLnN0cmlwKCkKICAgICAgICBpZiBub3QgbmFtZSBvciBub3QgYXVtaWQ6CiAgICAgICAgICAgIHJldHVybiBOb25lCiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgIm5hbWUiOiBuYW1lLAogICAgICAgICAgICAiYXVtaWQiOiBhdW1pZCwKICAgICAgICAgICAgImZsYWdzIjogc2VsZi5mbGFnc19lZGl0LnRleHQoKS5zdHJpcCgpLAogICAgICAgICAgICAiZXhlX25hbWUiOiBzZWxmLmV4ZV9lZGl0LnRleHQoKS5zdHJpcCgpLAogICAgICAgICAgICAic3RlYW1fYXBwaWQiOiBzZWxmLnN0ZWFtX2FwcGlkX2VkaXQudGV4dCgpLnN0cmlwKCksCiAgICAgICAgICAgICJ2YWxpZGF0ZV9zdGVhbSI6IHNlbGYudmFsaWRhdGVfY2IuaXNDaGVja2VkKCksCiAgICAgICAgICAgICJ2YWxpZGF0ZV90aW1lb3V0IjogaW50KHNlbGYudmFsaWRhdGVfdGltZW91dC52YWx1ZSgpKSwKICAgICAgICAgICAgIndhaXRfc2Vjb25kcyI6IHNlbGYud2FpdF9zcGluLnZhbHVlKCksCiAgICAgICAgICAgICJwcmlvcml0eSI6IHNlbGYucHJpb19jb21iby5jdXJyZW50VGV4dCgpLAogICAgICAgICAgICAiYXV0b19hZmZpbml0eSI6IHNlbGYuYXV0b19hZmYuaXNDaGVja2VkKCksCiAgICAgICAgICAgICJhZmZpbml0eV9oZXgiOiBzZWxmLmFmZl9oZXgudGV4dCgpLnN0cmlwKCkKICAgICAgICB9CgojID09PT09IE1haW4gV2luZG93ID09PT09CgojID09PT09IFNpbXBsZSBTZXR0aW5ncyBkaWFsb2cgPT09PT0KY2xhc3MgU2V0dGluZ3NEaWFsb2coUXRXaWRnZXRzLlFEaWFsb2cpOgogICAgZGVmIF9faW5pdF9fKHNlbGYsIHNldHRpbmdzOiBEaWN0W3N0ciwgQW55XSwgcGFyZW50PU5vbmUpOgogICAgICAgIHN1cGVyKCkuX19pbml0X18ocGFyZW50KQogICAgICAgIHNlbGYuc2V0V2luZG93VGl0bGUoIlNldHRpbmdzIikKICAgICAgICBzZWxmLnNldHRpbmdzID0gc2V0dGluZ3MKICAgICAgICBsYXkgPSBRdFdpZGdldHMuUVZCb3hMYXlvdXQoc2VsZikKCiAgICAgICAgZm9ybSA9IFF0V2lkZ2V0cy5RRm9ybUxheW91dCgpCiAgICAgICAgc2VsZi5hcGlfZWRpdCA9IFF0V2lkZ2V0cy5RTGluZUVkaXQoc2VsZi5zZXR0aW5ncy5nZXQoInN0ZWFtX2FwaV9rZXkiLCIiKSkKICAgICAgICBzZWxmLmFwaV9lZGl0LnNldFBsYWNlaG9sZGVyVGV4dCgiUGFzdGUgeW91ciBTdGVhbSBXZWIgQVBJIGtleSIpCiAgICAgICAgc2VsZi5hcGlfZWRpdC5zZXRFY2hvTW9kZShRdFdpZGdldHMuUUxpbmVFZGl0LkVjaG9Nb2RlLk5vcm1hbCkKICAgICAgICBmb3JtLmFkZFJvdygiU3RlYW0gV2ViIEFQSSBLZXkiLCBzZWxmLmFwaV9lZGl0KQoKICAgICAgICBzZWxmLmlkX2xhYmVsID0gUXRXaWRnZXRzLlFMYWJlbChzZWxmLnNldHRpbmdzLmdldCgic3RlYW1pZDY0IiwgIihub3Qgc2lnbmVkIGluKSIpKQogICAgICAgIGZvcm0uYWRkUm93KCJTaWduZWQgaW4gYXMgKFN0ZWFtSUQ2NCkiLCBzZWxmLmlkX2xhYmVsKQoKICAgICAgICBsYXkuYWRkTGF5b3V0KGZvcm0pCiAgICAgICAgYnRucyA9IFF0V2lkZ2V0cy5RRGlhbG9nQnV0dG9uQm94KFF0V2lkZ2V0cy5RRGlhbG9nQnV0dG9uQm94LlN0YW5kYXJkQnV0dG9uLk9rIHwgUXRXaWRnZXRzLlFEaWFsb2dCdXR0b25Cb3guU3RhbmRhcmRCdXR0b24uQ2FuY2VsKQogICAgICAgIGxheS5hZGRXaWRnZXQoYnRucykKICAgICAgICBidG5zLmFjY2VwdGVkLmNvbm5lY3Qoc2VsZi5hY2NlcHQpCiAgICAgICAgYnRucy5yZWplY3RlZC5jb25uZWN0KHNlbGYucmVqZWN0KQoKICAgIGRlZiBhcHBseShzZWxmKToKICAgICAgICBzZWxmLnNldHRpbmdzWyJzdGVhbV9hcGlfa2V5Il0gPSBzZWxmLmFwaV9lZGl0LnRleHQoKS5zdHJpcCgpCiAgICAgICAgcmV0dXJuIHNlbGYuc2V0dGluZ3MKCmNsYXNzIE1haW5XaW5kb3coUXRXaWRnZXRzLlFXaWRnZXQpOgogICAgZGVmIF9faW5pdF9fKHNlbGYpOgogICAgICAgIHN1cGVyKCkuX19pbml0X18oKQogICAgICAgIHNlbGYuc2V0V2luZG93VGl0bGUoIlVuaXZlcnNhbCBVV1AgTGF1bmNoZXIiKQogICAgICAgIHNlbGYucmVzaXplKDEwNjAsIDY4MCkKCiAgICAgICAgc2VsZi5zZXR0aW5ncyA9IGxvYWRfc2V0dGluZ3MoKQogICAgICAgIHNlbGYuZ2FtZXNfZGIgPSBsb2FkX2dhbWVzKCkgICAjIHsiZ2FtZXMiOiBbIHsuLi59IF19CiAgICAgICAgc2VsZi53b3JrZXI6IE9wdGlvbmFsW0xhdW5jaFdvcmtlcl0gPSBOb25lCgogICAgICAgIHNlbGYuX2J1aWxkX3VpKCkKICAgICAgICBzZWxmLl9yZWZyZXNoX2xpc3QoKQoKICAgIGRlZiBfYnVpbGRfdWkoc2VsZik6CiAgICAgICAgbGF5b3V0ID0gUXRXaWRnZXRzLlFIQm94TGF5b3V0KHNlbGYpCgogICAgICAgICMgTGVmdDogbGlzdAogICAgICAgIGxlZnQgPSBRdFdpZGdldHMuUVZCb3hMYXlvdXQoKQogICAgICAgIHNlbGYubGlzdF93aWRnZXQgPSBRdFdpZGdldHMuUUxpc3RXaWRnZXQoKQogICAgICAgIHNlbGYubGlzdF93aWRnZXQuY3VycmVudFJvd0NoYW5nZWQuY29ubmVjdChzZWxmLl9zaG93X3NlbGVjdGVkKQogICAgICAgIGxlZnQuYWRkV2lkZ2V0KFF0V2lkZ2V0cy5RTGFiZWwoIkdhbWVzIikpCiAgICAgICAgbGVmdC5hZGRXaWRnZXQoc2VsZi5saXN0X3dpZGdldCwgMSkKCiAgICAgICAgYnRuX3JvdyA9IFF0V2lkZ2V0cy5RSEJveExheW91dCgpCiAgICAgICAgc2VsZi5idG5fYWRkID0gUXRXaWRnZXRzLlFQdXNoQnV0dG9uKCJBZGQgR2FtZSIpCiAgICAgICAgc2VsZi5idG5fZWRpdCA9IFF0V2lkZ2V0cy5RUHVzaEJ1dHRvbigiRWRpdCIpCiAgICAgICAgc2VsZi5idG5fZGVsID0gUXRXaWRnZXRzLlFQdXNoQnV0dG9uKCJSZW1vdmUiKQogICAgICAgIGJ0bl9yb3cuYWRkV2lkZ2V0KHNlbGYuYnRuX2FkZCk7IGJ0bl9yb3cuYWRkV2lkZ2V0KHNlbGYuYnRuX2VkaXQpOyBidG5fcm93LmFkZFdpZGdldChzZWxmLmJ0bl9kZWwpCiAgICAgICAgbGVmdC5hZGRMYXlvdXQoYnRuX3JvdykKCiAgICAgICAgIyBSaWdodDogZGV0YWlscyArIGFjdGlvbnMKICAgICAgICByaWdodCA9IFF0V2lkZ2V0cy5RVkJveExheW91dCgpCiAgICAgICAgZm9ybSA9IFF0V2lkZ2V0cy5RRm9ybUxheW91dCgpCiAgICAgICAgc2VsZi5uYW1lX3ZhbCAgPSBRdFdpZGdldHMuUUxhYmVsKCItIikKICAgICAgICBzZWxmLmF1bWlkX3ZhbCA9IFF0V2lkZ2V0cy5RTGFiZWwoIi0iKQogICAgICAgIHNlbGYuZmxhZ3NfdmFsID0gUXRXaWRnZXRzLlFMYWJlbCgiLSIpCiAgICAgICAgc2VsZi5leGVfdmFsICAgPSBRdFdpZGdldHMuUUxhYmVsKCItIikKICAgICAgICBzZWxmLndhaXRfdmFsICA9IFF0V2lkZ2V0cy5RTGFiZWwoIi0iKQogICAgICAgIHNlbGYucHJpb192YWwgID0gUXRXaWRnZXRzLlFMYWJlbCgiLSIpCiAgICAgICAgc2VsZi5hZmZfdmFsICAgPSBRdFdpZGdldHMuUUxhYmVsKCItIikKCiAgICAgICAgZm9yIGxhYiBpbiAoc2VsZi5uYW1lX3ZhbCwgc2VsZi5hdW1pZF92YWwsIHNlbGYuZmxhZ3NfdmFsLCBzZWxmLmV4ZV92YWwsIHNlbGYud2FpdF92YWwsIHNlbGYucHJpb192YWwsIHNlbGYuYWZmX3ZhbCk6CiAgICAgICAgICAgIGxhYi5zZXRUZXh0Rm9ybWF0KFF0Q29yZS5RdC5UZXh0Rm9ybWF0LlBsYWluVGV4dCkKCiAgICAgICAgZm9ybS5hZGRSb3coIk5hbWUiLCBzZWxmLm5hbWVfdmFsKQogICAgICAgIGZvcm0uYWRkUm93KCJBVU1JRCIsIHNlbGYuYXVtaWRfdmFsKQogICAgICAgIGZvcm0uYWRkUm93KCJBcmd1bWVudHMiLCBzZWxmLmZsYWdzX3ZhbCkKICAgICAgICBmb3JtLmFkZFJvdygiVGFyZ2V0IEVYRSIsIHNlbGYuZXhlX3ZhbCkKICAgICAgICBzZWxmLnN0ZWFtX3ZhbCA9IFF0V2lkZ2V0cy5RTGFiZWwoIi0iKQogICAgICAgIHNlbGYudmFsaWRhdGVfdmFsID0gUXRXaWRnZXRzLlFMYWJlbCgiLSIpCiAgICAgICAgZm9ybS5hZGRSb3coIlN0ZWFtIEFwcElEIiwgc2VsZi5zdGVhbV92YWwpCiAgICAgICAgZm9ybS5hZGRSb3coIlN0ZWFtIFZhbGlkYXRlIiwgc2VsZi52YWxpZGF0ZV92YWwpCiAgICAgICAgZm9ybS5hZGRSb3coIldhaXQgKHMpIiwgc2VsZi53YWl0X3ZhbCkKICAgICAgICBmb3JtLmFkZFJvdygiUHJpb3JpdHkiLCBzZWxmLnByaW9fdmFsKQogICAgICAgIGZvcm0uYWRkUm93KCJBZmZpbml0eSIsIHNlbGYuYWZmX3ZhbCkKCiAgICAgICAgIyBBY3Rpb25zCiAgICAgICAgYWN0X3JvdzEgPSBRdFdpZGdldHMuUUhCb3hMYXlvdXQoKQogICAgICAgIHNlbGYuYnRuX2xhdW5jaCA9IFF0V2lkZ2V0cy5RUHVzaEJ1dHRvbigiTEFVTkNIIikKICAgICAgICBzZWxmLmJ0bl9sYXVuY2guc2V0TWluaW11bUhlaWdodCg0MikKICAgICAgICBzZWxmLmJ0bl9sYXVuY2guc2V0U3R5bGVTaGVldCgiZm9udC13ZWlnaHQ6NzAwO2ZvbnQtc2l6ZToxNnB4OyIpCiAgICAgICAgc2VsZi5idG5fc2hvcnRjdXQgPSBRdFdpZGdldHMuUVB1c2hCdXR0b24oIkNyZWF0ZSBEZXNrdG9wIFNob3J0Y3V0ICgubG5rKSIpCiAgICAgICAgYWN0X3JvdzEuYWRkV2lkZ2V0KHNlbGYuYnRuX2xhdW5jaCkKICAgICAgICBzZWxmLmJ0bl92YWxpZGF0ZSA9IFF0V2lkZ2V0cy5RUHVzaEJ1dHRvbigiVmFsaWRhdGUgdmlhIFN0ZWFtIikKICAgICAgICBhY3Rfcm93MS5hZGRXaWRnZXQoc2VsZi5idG5fdmFsaWRhdGUpCiAgICAgICAgc2VsZi5idG5fc3RlYW1fbG9naW4gPSBRdFdpZGdldHMuUVB1c2hCdXR0b24oIlNpZ24gaW50byBTdGVhbSIpCiAgICAgICAgYWN0X3JvdzEuYWRkV2lkZ2V0KHNlbGYuYnRuX3N0ZWFtX2xvZ2luKQogICAgICAgIHNlbGYuYnRuX3N5bmNfbGliID0gUXRXaWRnZXRzLlFQdXNoQnV0dG9uKCJTeW5jIFN0ZWFtIExpYnJhcnkiKQogICAgICAgIGFjdF9yb3cxLmFkZFdpZGdldChzZWxmLmJ0bl9zeW5jX2xpYikKICAgICAgICBhY3Rfcm93MS5hZGRXaWRnZXQoc2VsZi5idG5fc2hvcnRjdXQpCiAgICAgICAgc2VsZi5idG5fc2V0dGluZ3MgPSBRdFdpZGdldHMuUVB1c2hCdXR0b24oIlNldHRpbmdz4oCmIikKICAgICAgICBhY3Rfcm93MS5hZGRXaWRnZXQoc2VsZi5idG5fc2V0dGluZ3MpCgogICAgICAgICMgTG9ncwogICAgICAgIHNlbGYubG9nX2JveCA9IFF0V2lkZ2V0cy5RUGxhaW5UZXh0RWRpdCgpOyBzZWxmLmxvZ19ib3guc2V0UmVhZE9ubHkoVHJ1ZSk7IHNlbGYubG9nX2JveC5zZXRNYXhpbXVtQmxvY2tDb3VudCgyMDAwKQogICAgICAgIHNlbGYubG9nX2JveC5zZXRQbGFjZWhvbGRlclRleHQoIkxvZ3Mgd2lsbCBhcHBlYXIgaGVyZS4uLiIpCgogICAgICAgICMgRGVmYXVsdHMKICAgICAgICBkZWZfcm93ID0gUXRXaWRnZXRzLlFIQm94TGF5b3V0KCkKICAgICAgICBzZWxmLndhaXRfc3Bpbl9kZWYgPSBRdFdpZGdldHMuUVNwaW5Cb3goKTsgc2VsZi53YWl0X3NwaW5fZGVmLnNldFJhbmdlKDUsIDYwMCk7IHNlbGYud2FpdF9zcGluX2RlZi5zZXRWYWx1ZShpbnQoc2VsZi5zZXR0aW5ncy5nZXQoImRlZmF1bHRfd2FpdCIsIDQ1KSkpCiAgICAgICAgc2VsZi5wcmlvX2RlZiA9IFF0V2lkZ2V0cy5RQ29tYm9Cb3goKTsgc2VsZi5wcmlvX2RlZi5hZGRJdGVtcyhsaXN0KFBSSU9SSVRZX01BUC5rZXlzKCkpKTsgc2VsZi5wcmlvX2RlZi5zZXRDdXJyZW50VGV4dChzZWxmLnNldHRpbmdzLmdldCgiZGVmYXVsdF9wcmlvcml0eSIsIkhpZ2giKSkKICAgICAgICBzZWxmLmJ0bl9zYXZlX3NldHRpbmdzID0gUXRXaWRnZXRzLlFQdXNoQnV0dG9uKCJTYXZlIERlZmF1bHRzIikKICAgICAgICAjIFNhZmUtY29ubmVjdDogaWYgX3NhdmVfZGVmYXVsdHMgaXMgbWlzc2luZywgZmFsbCBiYWNrIHRvIHNhdmluZyBzZXR0aW5ncyBkaXJlY3RseQogICAgICAgIGhhbmRsZXIgPSBnZXRhdHRyKHNlbGYsICJfc2F2ZV9kZWZhdWx0cyIsIE5vbmUpCiAgICAgICAgaWYgaGFuZGxlciBpcyBOb25lOgogICAgICAgICAgICBkZWYgaGFuZGxlcigpOgogICAgICAgICAgICAgICAgc2F2ZV9zZXR0aW5ncyhzZWxmLnNldHRpbmdzKQogICAgICAgICAgICAgICAgc2VsZi5fbG9nKCJb4pyTXSBEZWZhdWx0cyBzYXZlZC4iLCAib2siKQogICAgICAgIHNlbGYuYnRuX3NhdmVfc2V0dGluZ3MuY2xpY2tlZC5jb25uZWN0KGhhbmRsZXIpCiAgICAgICAgZGVmX3Jvdy5hZGRXaWRnZXQoUXRXaWRnZXRzLlFMYWJlbCgiRGVmYXVsdCBXYWl0IChzKSIpKTsgZGVmX3Jvdy5hZGRXaWRnZXQoc2VsZi53YWl0X3NwaW5fZGVmKQogICAgICAgIGRlZl9yb3cuYWRkU3BhY2luZygxMikKICAgICAgICBkZWZfcm93LmFkZFdpZGdldChRdFdpZGdldHMuUUxhYmVsKCJEZWZhdWx0IFByaW9yaXR5IikpOyBkZWZfcm93LmFkZFdpZGdldChzZWxmLnByaW9fZGVmKQogICAgICAgIGRlZl9yb3cuYWRkU3RyZXRjaCgxKQogICAgICAgIGRlZl9yb3cuYWRkV2lkZ2V0KHNlbGYuYnRuX3NhdmVfc2V0dGluZ3MpCgogICAgICAgICMgQXNzZW1ibGUgcmlnaHQKICAgICAgICByaWdodC5hZGRMYXlvdXQoZm9ybSkKICAgICAgICByaWdodC5hZGRTcGFjaW5nKDYpCiAgICAgICAgcmlnaHQuYWRkTGF5b3V0KGFjdF9yb3cxKQogICAgICAgIHJpZ2h0LmFkZFdpZGdldChzZWxmLmxvZ19ib3gsIDEpCiAgICAgICAgcmlnaHQuYWRkTGF5b3V0KGRlZl9yb3cpCgogICAgICAgIGxheW91dC5hZGRMYXlvdXQobGVmdCwgMSkKICAgICAgICBsYXlvdXQuYWRkTGF5b3V0KHJpZ2h0LCAyKQoKICAgICAgICAjIFdpcmUgYnV0dG9ucwogICAgICAgIHNlbGYuYnRuX2FkZC5jbGlja2VkLmNvbm5lY3Qoc2VsZi5fYWRkX2dhbWUpCiAgICAgICAgc2VsZi5idG5fZWRpdC5jbGlja2VkLmNvbm5lY3Qoc2VsZi5fZWRpdF9nYW1lKQogICAgICAgIHNlbGYuYnRuX2RlbC5jbGlja2VkLmNvbm5lY3Qoc2VsZi5fcmVtb3ZlX2dhbWUpCiAgICAgICAgc2VsZi5idG5fbGF1bmNoLmNsaWNrZWQuY29ubmVjdChzZWxmLl9sYXVuY2hfc2VsZWN0ZWQpCiAgICAgICAgc2VsZi5idG5fdmFsaWRhdGUuY2xpY2tlZC5jb25uZWN0KHNlbGYuX3ZhbGlkYXRlX3NlbGVjdGVkKQogICAgICAgIHNlbGYuYnRuX3N0ZWFtX2xvZ2luLmNsaWNrZWQuY29ubmVjdChzZWxmLl9zaWduX2ludG9fc3RlYW0pCiAgICAgICAgc2VsZi5idG5fc3luY19saWIuY2xpY2tlZC5jb25uZWN0KHNlbGYuX3N5bmNfc3RlYW1fbGlicmFyeSkKICAgICAgICBzZWxmLmJ0bl9zaG9ydGN1dC5jbGlja2VkLmNvbm5lY3Qoc2VsZi5fbWFrZV9zaG9ydGN1dF9zZWxlY3RlZCkKICAgICAgICBzZWxmLmJ0bl9zZXR0aW5ncy5jbGlja2VkLmNvbm5lY3Qoc2VsZi5fb3Blbl9zZXR0aW5ncykKCiAgICAgICAgIyBTaW1wbGUgZGFyayB0aGVtZQogICAgICAgIGFwcCA9IFF0V2lkZ2V0cy5RQXBwbGljYXRpb24uaW5zdGFuY2UoKQogICAgICAgIGFwcC5zZXRTdHlsZSgiRnVzaW9uIikKICAgICAgICBwYWwgPSBhcHAucGFsZXR0ZSgpCiAgICAgICAgcGFsLnNldENvbG9yKFF0R3VpLlFQYWxldHRlLkNvbG9yUm9sZS5CYXNlLCBRdEd1aS5RQ29sb3IoMzIsMzIsMzIpKQogICAgICAgIHBhbC5zZXRDb2xvcihRdEd1aS5RUGFsZXR0ZS5Db2xvclJvbGUuVGV4dCwgUXRHdWkuUUNvbG9yKDIzMCwyMzAsMjMwKSkKICAgICAgICBwYWwuc2V0Q29sb3IoUXRHdWkuUVBhbGV0dGUuQ29sb3JSb2xlLldpbmRvdywgUXRHdWkuUUNvbG9yKDQwLDQwLDQwKSkKICAgICAgICBwYWwuc2V0Q29sb3IoUXRHdWkuUVBhbGV0dGUuQ29sb3JSb2xlLkJ1dHRvbiwgUXRHdWkuUUNvbG9yKDYwLDYwLDYwKSkKICAgICAgICBhcHAuc2V0UGFsZXR0ZShwYWwpCgogICAgIyA9PT09PSBMaXN0IG1hbmFnZW1lbnQgPT09PT0KICAgIGRlZiBfcmVmcmVzaF9saXN0KHNlbGYpOgogICAgICAgIHNlbGYubGlzdF93aWRnZXQuY2xlYXIoKQogICAgICAgIGZvciBnIGluIHNlbGYuZ2FtZXNfZGJbImdhbWVzIl06CiAgICAgICAgICAgIHNlbGYubGlzdF93aWRnZXQuYWRkSXRlbShnLmdldCgibmFtZSIsICIodW5uYW1lZCkiKSkKICAgICAgICBpZiBzZWxmLmxpc3Rfd2lkZ2V0LmNvdW50KCkgPiAwOgogICAgICAgICAgICBzZWxmLmxpc3Rfd2lkZ2V0LnNldEN1cnJlbnRSb3coMCkKICAgICAgICBlbHNlOgogICAgICAgICAgICBzZWxmLl9zaG93X2dhbWUoTm9uZSkKCiAgICBkZWYgX2N1cnJlbnRfZ2FtZShzZWxmKSAtPiBPcHRpb25hbFtEaWN0W3N0ciwgQW55XV06CiAgICAgICAgcm93ID0gc2VsZi5saXN0X3dpZGdldC5jdXJyZW50Um93KCkKICAgICAgICBpZiByb3cgPCAwIG9yIHJvdyA+PSBsZW4oc2VsZi5nYW1lc19kYlsiZ2FtZXMiXSk6CiAgICAgICAgICAgIHJldHVybiBOb25lCiAgICAgICAgcmV0dXJuIHNlbGYuZ2FtZXNfZGJbImdhbWVzIl1bcm93XQoKICAgIGRlZiBfc2hvd19zZWxlY3RlZChzZWxmLCBpZHg6IGludCk6CiAgICAgICAgc2VsZi5fc2hvd19nYW1lKHNlbGYuX2N1cnJlbnRfZ2FtZSgpKQoKICAgIGRlZiBfc2hvd19nYW1lKHNlbGYsIGc6IE9wdGlvbmFsW0RpY3Rbc3RyLCBBbnldXSk6CiAgICAgICAgaWYgbm90IGc6CiAgICAgICAgICAgIHNlbGYubmFtZV92YWwuc2V0VGV4dCgiLSIpOyBzZWxmLmF1bWlkX3ZhbC5zZXRUZXh0KCItIik7IHNlbGYuZmxhZ3NfdmFsLnNldFRleHQoIi0iKTsgc2VsZi5leGVfdmFsLnNldFRleHQoIi0iKQogICAgICAgICAgICBzZWxmLndhaXRfdmFsLnNldFRleHQoIi0iKTsgc2VsZi5wcmlvX3ZhbC5zZXRUZXh0KCItIik7IHNlbGYuYWZmX3ZhbC5zZXRUZXh0KCItIikKICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgc2VsZi5uYW1lX3ZhbC5zZXRUZXh0KGcuZ2V0KCJuYW1lIiwiLSIpKQogICAgICAgIHNlbGYuYXVtaWRfdmFsLnNldFRleHQoZy5nZXQoImF1bWlkIiwiLSIpKQogICAgICAgIHNlbGYuZmxhZ3NfdmFsLnNldFRleHQoZy5nZXQoImZsYWdzIiwiLSIpKQogICAgICAgIHNlbGYuZXhlX3ZhbC5zZXRUZXh0KGcuZ2V0KCJleGVfbmFtZSIsIi0iKSkKICAgICAgICBzZWxmLnN0ZWFtX3ZhbC5zZXRUZXh0KHN0cihnLmdldCgic3RlYW1fYXBwaWQiLCItIikpIG9yICItIikKICAgICAgICBzZWxmLnZhbGlkYXRlX3ZhbC5zZXRUZXh0KCJZZXMiIGlmIGcuZ2V0KCJ2YWxpZGF0ZV9zdGVhbSIpIGVsc2UgIk5vIikKICAgICAgICBzZWxmLndhaXRfdmFsLnNldFRleHQoc3RyKGcuZ2V0KCJ3YWl0X3NlY29uZHMiLCBzZWxmLnNldHRpbmdzLmdldCgiZGVmYXVsdF93YWl0Iiw0NSkpKSkKICAgICAgICBzZWxmLnByaW9fdmFsLnNldFRleHQoZy5nZXQoInByaW9yaXR5Iiwgc2VsZi5zZXR0aW5ncy5nZXQoImRlZmF1bHRfcHJpb3JpdHkiLCJIaWdoIikpKQogICAgICAgIGFmZiA9ICJhdXRvIChhbGwgYnV0IENQVTApIiBpZiBnLmdldCgiYXV0b19hZmZpbml0eSIsIFRydWUpIGFuZCBub3QgZy5nZXQoImFmZmluaXR5X2hleCIpIGVsc2UgKGcuZ2V0KCJhZmZpbml0eV9oZXgiKSBvciAiTm9uZSIpCiAgICAgICAgc2VsZi5hZmZfdmFsLnNldFRleHQoYWZmKQoKICAgICMgPT09PT0gQWRkL0VkaXQvUmVtb3ZlID09PT09CiAgICBkZWYgX2FkZF9nYW1lKHNlbGYpOgogICAgICAgIGRsZyA9IEdhbWVEaWFsb2coc2VsZiwgc2VsZi5zZXR0aW5ncykKICAgICAgICBpZiBkbGcuZXhlYygpID09IFF0V2lkZ2V0cy5RRGlhbG9nLkRpYWxvZ0NvZGUuQWNjZXB0ZWQ6CiAgICAgICAgICAgIGRhdGEgPSBkbGcucmVzdWx0X2RhdGEoKQogICAgICAgICAgICBpZiBub3QgZGF0YToKICAgICAgICAgICAgICAgIHNlbGYuX2xvZygiW3hdIE5hbWUgJiBBVU1JRCByZXF1aXJlZC4iLCAiZXJyb3IiKTsgcmV0dXJuCiAgICAgICAgICAgIHNlbGYuZ2FtZXNfZGJbImdhbWVzIl0uYXBwZW5kKGRhdGEpCiAgICAgICAgICAgIHNhdmVfZ2FtZXMoc2VsZi5nYW1lc19kYikKICAgICAgICAgICAgc2VsZi5fcmVmcmVzaF9saXN0KCkKICAgICAgICAgICAgc2VsZi5fbG9nKGYiW+Kck10gQWRkZWQgJ3tkYXRhWyduYW1lJ119Jy4iLCAib2siKQoKICAgIGRlZiBfZWRpdF9nYW1lKHNlbGYpOgogICAgICAgIGcgPSBzZWxmLl9jdXJyZW50X2dhbWUoKQogICAgICAgIGlmIG5vdCBnOgogICAgICAgICAgICByZXR1cm4KICAgICAgICBkbGcgPSBHYW1lRGlhbG9nKHNlbGYsIHNlbGYuc2V0dGluZ3MsIGRhdGE9ZykKICAgICAgICBpZiBkbGcuZXhlYygpID09IFF0V2lkZ2V0cy5RRGlhbG9nLkRpYWxvZ0NvZGUuQWNjZXB0ZWQ6CiAgICAgICAgICAgIGRhdGEgPSBkbGcucmVzdWx0X2RhdGEoKQogICAgICAgICAgICBpZiBub3QgZGF0YToKICAgICAgICAgICAgICAgIHNlbGYuX2xvZygiW3hdIE5hbWUgJiBBVU1JRCByZXF1aXJlZC4iLCAiZXJyb3IiKTsgcmV0dXJuCiAgICAgICAgICAgIGlkeCA9IHNlbGYubGlzdF93aWRnZXQuY3VycmVudFJvdygpCiAgICAgICAgICAgIHNlbGYuZ2FtZXNfZGJbImdhbWVzIl1baWR4XSA9IGRhdGEKICAgICAgICAgICAgc2F2ZV9nYW1lcyhzZWxmLmdhbWVzX2RiKQogICAgICAgICAgICBzZWxmLl9yZWZyZXNoX2xpc3QoKQogICAgICAgICAgICBzZWxmLl9sb2coZiJb4pyTXSBVcGRhdGVkICd7ZGF0YVsnbmFtZSddfScuIiwgIm9rIikKCiAgICBkZWYgX3JlbW92ZV9nYW1lKHNlbGYpOgogICAgICAgIGcgPSBzZWxmLl9jdXJyZW50X2dhbWUoKQogICAgICAgIGlmIG5vdCBnOgogICAgICAgICAgICByZXR1cm4KICAgICAgICBpZHggPSBzZWxmLmxpc3Rfd2lkZ2V0LmN1cnJlbnRSb3coKQogICAgICAgIG5hbWUgPSBnLmdldCgibmFtZSIsIih1bm5hbWVkKSIpCiAgICAgICAgZGVsIHNlbGYuZ2FtZXNfZGJbImdhbWVzIl1baWR4XQogICAgICAgIHNhdmVfZ2FtZXMoc2VsZi5nYW1lc19kYikKICAgICAgICBzZWxmLl9yZWZyZXNoX2xpc3QoKQogICAgICAgIHNlbGYuX2xvZyhmIlshXSBSZW1vdmVkICd7bmFtZX0nLiIsICJ3YXJuIikKCiAgICBkZWYgX3NpZ25faW50b19zdGVhbShzZWxmKToKICAgICAgICAiIiJTaWduIHRoZSB1c2VyIGludG8gU3RlYW0gKE9wZW5JRCkgc28gdGhlIGxhdW5jaGVyIGNhbiBhY2Nlc3MgdGhlaXIgbGlicmFyeS4iIiIKICAgICAgICBzZWxmLl9sb2coIltpXSBTdGFydGluZyBTdGVhbSBzaWduLWluIChsYXVuY2hlcinigKYiLCAiaW5mbyIpCiAgICAgICAgc3RlYW1pZCA9IHN0ZWFtX29wZW5pZF9sb2dpbih0aW1lb3V0PTE4MCkKICAgICAgICBpZiBzdGVhbWlkOgogICAgICAgICAgICBzZWxmLnNldHRpbmdzWyJzdGVhbWlkNjQiXSA9IHN0ZWFtaWQKICAgICAgICAgICAgc2F2ZV9zZXR0aW5ncyhzZWxmLnNldHRpbmdzKQogICAgICAgICAgICBzZWxmLl9sb2coZiJb4pyTXSBTaWduZWQgaW4gYXMgU3RlYW1JRDY0OiB7c3RlYW1pZH0iLCAib2siKQogICAgICAgICAgICBhcGlfa2V5ID0gc2VsZi5zZXR0aW5ncy5nZXQoInN0ZWFtX2FwaV9rZXkiKQogICAgICAgICAgICBpZiBhcGlfa2V5OgogICAgICAgICAgICAgICAgb2ssIG1zZywgXyA9IHN5bmNfc3RlYW1fbGlicmFyeShzdGVhbWlkLCBhcGlfa2V5KQogICAgICAgICAgICAgICAgaWYgb2s6CiAgICAgICAgICAgICAgICAgICAgc2VsZi5fbG9nKGYiW+Kck10ge21zZ30iLCAib2siKQogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICBzZWxmLl9sb2coZiJbfl0ge21zZ30iLCAid2FybiIpCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBzZWxmLl9sb2coIlt+XSBUaXA6IGFkZCAnc3RlYW1fYXBpX2tleScgaW4gc2V0dGluZ3MgSlNPTiB0byBlbmFibGUgZnVsbCBsaWJyYXJ5IHN5bmMuIiwgIndhcm4iKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHNlbGYuX2xvZygiW3hdIFN0ZWFtIHNpZ24taW4gZmFpbGVkIG9yIHRpbWVkIG91dC4iLCAiZXJyb3IiKQoKICAgIAogICAgZGVmIF9vcGVuX3NldHRpbmdzKHNlbGYpOgogICAgICAgIGRsZyA9IFNldHRpbmdzRGlhbG9nKHNlbGYuc2V0dGluZ3MsIHNlbGYpCiAgICAgICAgaWYgZGxnLmV4ZWMoKSA9PSBRdFdpZGdldHMuUURpYWxvZy5EaWFsb2dDb2RlLkFjY2VwdGVkOgogICAgICAgICAgICBkbGcuYXBwbHkoKQogICAgICAgICAgICBzYXZlX3NldHRpbmdzKHNlbGYuc2V0dGluZ3MpCiAgICAgICAgICAgIHNlbGYuX2xvZygiW+Kck10gU2V0dGluZ3Mgc2F2ZWQuIiwgIm9rIikKCiAgICBkZWYgX3N5bmNfc3RlYW1fbGlicmFyeShzZWxmKToKICAgICAgICBzdGVhbWlkID0gc2VsZi5zZXR0aW5ncy5nZXQoInN0ZWFtaWQ2NCIsIiIpCiAgICAgICAgaWYgbm90IHN0ZWFtaWQ6CiAgICAgICAgICAgIHNlbGYuX2xvZygiW3hdIE5vdCBzaWduZWQgaW50byBTdGVhbSB5ZXQuIENsaWNrICdTaWduIGludG8gU3RlYW0nIGZpcnN0LiIsICJlcnJvciIpCiAgICAgICAgICAgIHJldHVybgogICAgICAgIGFwaV9rZXkgPSBzZWxmLnNldHRpbmdzLmdldCgic3RlYW1fYXBpX2tleSIpCiAgICAgICAgb2ssIG1zZywgcGF5bG9hZCA9IHN5bmNfc3RlYW1fbGlicmFyeShzdGVhbWlkLCBhcGlfa2V5KQogICAgICAgIGlmIG9rOgogICAgICAgICAgICBzZWxmLl9sb2coZiJb4pyTXSB7bXNnfSIsICJvayIpCiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIGFkZGVkLCBza2lwcGVkID0gaW1wb3J0X293bmVkX2dhbWVzX3RvX2RiKHNlbGYuZ2FtZXNfZGIsIHBheWxvYWQsIGluc3RhbGxlZF9vbmx5PVRydWUpCiAgICAgICAgICAgICAgICBpZiBhZGRlZDoKICAgICAgICAgICAgICAgICAgICBzYXZlX2dhbWVzKHNlbGYuZ2FtZXNfZGIpCiAgICAgICAgICAgICAgICAgICAgc2VsZi5fcmVmcmVzaF9saXN0KCkKICAgICAgICAgICAgICAgIHNlbGYuX2xvZyhmIltpXSBJbXBvcnRlZCB7YWRkZWR9IG5ldyB0aXRsZXMgKHtza2lwcGVkfSBza2lwcGVkKS4iLCAiaW5mbyIpCiAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICAgICAgICAgIHNlbGYuX2xvZyhmIlt+XSBTeW5jZWQgYnV0IGZhaWxlZCB0byBpbXBvcnQgaW50byBsaXN0OiB7ZX0iLCAid2FybiIpCiAgICAgICAgZWxzZToKICAgICAgICAgICAgc2VsZi5fbG9nKGYiW35dIHttc2d9IiwgIndhcm4iKQoKICAgIGRlZiBfdmFsaWRhdGVfc2VsZWN0ZWQoc2VsZik6CiAgICAgICAgZyA9IHNlbGYuX2N1cnJlbnRfZ2FtZSgpCiAgICAgICAgaWYgbm90IGc6CiAgICAgICAgICAgIHJldHVybgogICAgICAgIGFwcGlkID0gc3RyKGcuZ2V0KCJzdGVhbV9hcHBpZCIsIiIgKSkuc3RyaXAoKQogICAgICAgIGlmIG5vdCBhcHBpZC5pc2RpZ2l0KCk6CiAgICAgICAgICAgIHNlbGYuX2xvZygiW3hdIE5vIHZhbGlkIFN0ZWFtIEFwcElEIHNldCBmb3IgdGhpcyB0aXRsZS4iLCAiZXJyb3IiKQogICAgICAgICAgICByZXR1cm4KICAgICAgICBzZWxmLl9sb2coZiJbaV0gVmFsaWRhdGluZyB2aWEgU3RlYW0gZm9yIEFwcElEIHthcHBpZH3igKYiLCAiaW5mbyIpCiAgICAgICAgY2ZnID0gZGljdChnKQogICAgICAgIGNmZ1sidmFsaWRhdGVfb25seSJdID0gVHJ1ZQogICAgICAgIHNlbGYuYnRuX3ZhbGlkYXRlLnNldEVuYWJsZWQoRmFsc2UpCiAgICAgICAgc2VsZi53b3JrZXIgPSBMYXVuY2hXb3JrZXIoY2ZnKQogICAgICAgIHNlbGYud29ya2VyLmxvZ19zaWduYWwuY29ubmVjdChzZWxmLl9vbl93b3JrZXJfbG9nKQogICAgICAgIHNlbGYud29ya2VyLmRvbmVfc2lnbmFsLmNvbm5lY3Qoc2VsZi5fb25fd29ya2VyX2RvbmVfdmFsaWRhdGUpCiAgICAgICAgc2VsZi53b3JrZXIuc3RhcnQoKQogICAgZGVmIF9vbl93b3JrZXJfZG9uZV92YWxpZGF0ZShzZWxmLCBvazogYm9vbCwgbXNnOiBzdHIpOgogICAgICAgIHNlbGYuYnRuX3ZhbGlkYXRlLnNldEVuYWJsZWQoVHJ1ZSkKICAgICAgICBzZWxmLl9vbl93b3JrZXJfZG9uZShvaywgbXNnKQogICAgICAgICMgQXV0by1sYXVuY2ggYWZ0ZXIgc3VjY2Vzc2Z1bCB2YWxpZGF0aW9uCiAgICAgICAgaWYgb2s6CiAgICAgICAgICAgIFF0Q29yZS5RVGltZXIuc2luZ2xlU2hvdCgxMDAwLCBzZWxmLl9sYXVuY2hfc2VsZWN0ZWQpCgogICAgIyA9PT09PSBMYXVuY2ggJiBTaG9ydGN1dCA9PT09PQogICAgZGVmIF9sYXVuY2hfc2VsZWN0ZWQoc2VsZik6CiAgICAgICAgZyA9IHNlbGYuX2N1cnJlbnRfZ2FtZSgpCiAgICAgICAgaWYgbm90IGc6CiAgICAgICAgICAgIHJldHVybgogICAgICAgIHNlbGYuYnRuX2xhdW5jaC5zZXRFbmFibGVkKEZhbHNlKQogICAgICAgIHNlbGYuX2xvZyhmIltpXSBMYXVuY2hpbmcgJ3tnLmdldCgnbmFtZScsJycpfSfigKYiLCAiaW5mbyIpCiAgICAgICAgc2VsZi53b3JrZXIgPSBMYXVuY2hXb3JrZXIoZykKICAgICAgICBzZWxmLndvcmtlci5sb2dfc2lnbmFsLmNvbm5lY3Qoc2VsZi5fb25fd29ya2VyX2xvZykKICAgICAgICBzZWxmLndvcmtlci5kb25lX3NpZ25hbC5jb25uZWN0KHNlbGYuX29uX3dvcmtlcl9kb25lKQogICAgICAgIHNlbGYud29ya2VyLnN0YXJ0KCkKCiAgICBkZWYgX21ha2Vfc2hvcnRjdXRfc2VsZWN0ZWQoc2VsZik6CiAgICAgICAgZyA9IHNlbGYuX2N1cnJlbnRfZ2FtZSgpCiAgICAgICAgaWYgbm90IGc6CiAgICAgICAgICAgIHJldHVybgogICAgICAgIG5hbWUgPSBnLmdldCgibmFtZSIsIlVXUCBHYW1lIikKICAgICAgICB0YXJnZXQgPSB0aGlzX3B5dGhvbl9leGVjdXRhYmxlKCkKICAgICAgICAjIGF2b2lkIGYtc3RyaW5nIGJhY2tzbGFzaCBydWxlOyB1c2UgLmZvcm1hdCgpCiAgICAgICAgYXJncyA9ICcie30iIC0tcnVuICJ7fSInLmZvcm1hdChzdHIoUGF0aChfX2ZpbGVfXykuYWJzb2x1dGUoKSksIG5hbWUucmVwbGFjZSgnIicsICcnKSkKICAgICAgICBkZXNrdG9wID0gUGF0aChvcy5wYXRoLmpvaW4ob3MucGF0aC5leHBhbmR1c2VyKCJ+IiksICJEZXNrdG9wIikpCiAgICAgICAgb3V0ID0gZGVza3RvcCAvIG5hbWUKICAgICAgICBvaywgbXNnID0gbWFrZV93aW5kb3dzX3Nob3J0Y3V0KHRhcmdldCwgYXJncywgb3V0LCBpY29uX3BhdGg9Tm9uZSkKICAgICAgICBpZiBvazoKICAgICAgICAgICAgc2VsZi5fbG9nKGYiW+Kck10gU2hvcnRjdXQgY3JlYXRlZDoge21zZ30iLCAib2siKQogICAgICAgICAgICBzZWxmLl9sb2coIltpXSBZb3UgY2FuIGFkZCB0aGlzIC5sbmsgdG8gU3RlYW0gYXMgYSBOb24tU3RlYW0gZ2FtZSBpZiBkZXNpcmVkLiIsICJpbmZvIikKICAgICAgICBlbHNlOgogICAgICAgICAgICBzZWxmLl9sb2coZiJbeF0gU2hvcnRjdXQgZmFpbGVkOiB7bXNnfSIsICJlcnJvciIpCgogICAgZGVmIF9vbl93b3JrZXJfbG9nKHNlbGYsIGxldmVsOiBzdHIsIG1zZzogc3RyKToKICAgICAgICBzZWxmLl9sb2cobXNnLCBsZXZlbCkKCiAgICBkZWYgX29uX3dvcmtlcl9kb25lKHNlbGYsIG9rOiBib29sLCBtc2c6IHN0cik6CiAgICAgICAgc2VsZi5fbG9nKCgiU3VjY2VzczogIiBpZiBvayBlbHNlICJGYWlsZWQ6ICIpICsgbXNnLCAib2siIGlmIG9rIGVsc2UgImVycm9yIikKICAgICAgICBzZWxmLmJ0bl9sYXVuY2guc2V0RW5hYmxlZChUcnVlKQoKICAgICMgPT09PT0gRGVmYXVsdHMgPT09PT0KICAgIGRlZiBfc2F2ZV9kZWZhdWx0cyhzZWxmKToKICAgICAgICBzZWxmLnNldHRpbmdzWyJkZWZhdWx0X3dhaXQiXSA9IHNlbGYud2FpdF9zcGluX2RlZi52YWx1ZSgpCiAgICAgICAgc2VsZi5zZXR0aW5nc1siZGVmYXVsdF9wcmlvcml0eSJdID0gc2VsZi5wcmlvX2RlZi5jdXJyZW50VGV4dCgpCiAgICAgICAgc2F2ZV9zZXR0aW5ncyhzZWxmLnNldHRpbmdzKQogICAgICAgIHNlbGYuX2xvZygiW+Kck10gRGVmYXVsdHMgc2F2ZWQuIiwgIm9rIikKCiAgICAjID09PT09IExvZ2dpbmcgPT09PT0KICAgIGRlZiBfbG9nKHNlbGYsIG1zZzogc3RyLCBsZXZlbDogc3RyID0gImluZm8iKToKICAgICAgICBwcmVmaXggPSB7ImluZm8iOiJbaV0gIiwgIm9rIjoiW+Kck10gIiwgIndhcm4iOiJbIV0gIiwgImVycm9yIjoiW3hdICJ9LmdldChsZXZlbCwgIiIpCiAgICAgICAgc2VsZi5sb2dfYm94LmFwcGVuZFBsYWluVGV4dChwcmVmaXggKyBtc2cpCgojID09PT09IENMSSBzdXBwb3J0IChmb3Igc2hvcnRjdXQpID09PT09CmRlZiBfcGFyc2VfY2xpX3J1bihhcmd2OiBMaXN0W3N0cl0pIC0+IE9wdGlvbmFsW3N0cl06CiAgICB0cnk6CiAgICAgICAgaWYgIi0tcnVuIiBpbiBhcmd2OgogICAgICAgICAgICBpZHggPSBhcmd2LmluZGV4KCItLXJ1biIpCiAgICAgICAgICAgIHJldHVybiBhcmd2W2lkeCsxXSBpZiBpZHgrMSA8IGxlbihhcmd2KSBlbHNlIE5vbmUKICAgICAgICBmb3IgYSBpbiBhcmd2OgogICAgICAgICAgICBpZiBhLnN0YXJ0c3dpdGgoIi0tcnVuPSIpOgogICAgICAgICAgICAgICAgcmV0dXJuIGEuc3BsaXQoIj0iLDEpWzFdLnN0cmlwKCkuc3RyaXAoJyInKQogICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICBwYXNzCiAgICByZXR1cm4gTm9uZQoKZGVmIG1haW4oKToKICAgIHJ1bl9uYW1lID0gX3BhcnNlX2NsaV9ydW4oc3lzLmFyZ3ZbMTpdKQogICAgYXBwID0gUXRXaWRnZXRzLlFBcHBsaWNhdGlvbihzeXMuYXJndikKICAgIHdpbiA9IE1haW5XaW5kb3coKQogICAgd2luLnNob3coKQogICAgaWYgcnVuX25hbWU6CiAgICAgICAgbmFtZXMgPSBbZy5nZXQoIm5hbWUiLCIiKSBmb3IgZyBpbiB3aW4uZ2FtZXNfZGJbImdhbWVzIl1dCiAgICAgICAgaWYgcnVuX25hbWUgaW4gbmFtZXM6CiAgICAgICAgICAgIHJvdyA9IG5hbWVzLmluZGV4KHJ1bl9uYW1lKQogICAgICAgICAgICB3aW4ubGlzdF93aWRnZXQuc2V0Q3VycmVudFJvdyhyb3cpCiAgICAgICAgICAgIFF0Q29yZS5RVGltZXIuc2luZ2xlU2hvdCgyNTAsIHdpbi5fbGF1bmNoX3NlbGVjdGVkKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHdpbi5fbG9nKGYiW3hdIEdhbWUgJ3tydW5fbmFtZX0nIG5vdCBmb3VuZC4iLCAiZXJyb3IiKQogICAgc3lzLmV4aXQoYXBwLmV4ZWMoKSkKCmRlZiBfc3RlYW1fd2luZG93X3RpdGxlX2hhcyhzdWJzdHI6IHN0cikgLT4gYm9vbDoKICAgIHRyeToKICAgICAgICBpbXBvcnQgcHN1dGlsCiAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgIHJldHVybiBGYWxzZQogICAgc3Vic3RyX2wgPSBzdWJzdHIubG93ZXIoKQogICAgc3RlYW1fcGlkcyA9IHNldCgpCiAgICBmb3IgcHJvYyBpbiBwc3V0aWwucHJvY2Vzc19pdGVyKFsnbmFtZSddKToKICAgICAgICB0cnk6CiAgICAgICAgICAgIG5tID0gKHByb2MuaW5mby5nZXQoJ25hbWUnKSBvciAnJykubG93ZXIoKQogICAgICAgICAgICBpZiBubS5zdGFydHN3aXRoKCdzdGVhbScpOgogICAgICAgICAgICAgICAgc3RlYW1fcGlkcy5hZGQocHJvYy5waWQpCiAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgcGFzcwogICAgaWYgbm90IHN0ZWFtX3BpZHM6CiAgICAgICAgcmV0dXJuIEZhbHNlCiAgICB1c2VyMzIgPSBjdHlwZXMud2luZGxsLnVzZXIzMgogICAgR2V0V2luZG93VGV4dFcgPSB1c2VyMzIuR2V0V2luZG93VGV4dFcKICAgIEdldFdpbmRvd1RleHRMZW5ndGhXID0gdXNlcjMyLkdldFdpbmRvd1RleHRMZW5ndGhXCiAgICBHZXRXaW5kb3dUaHJlYWRQcm9jZXNzSWQgPSB1c2VyMzIuR2V0V2luZG93VGhyZWFkUHJvY2Vzc0lkCiAgICBJc1dpbmRvd1Zpc2libGUgPSB1c2VyMzIuSXNXaW5kb3dWaXNpYmxlCiAgICBFbnVtV2luZG93cyA9IHVzZXIzMi5FbnVtV2luZG93cwogICAgRW51bVdpbmRvd3NQcm9jID0gY3R5cGVzLldJTkZVTkNUWVBFKGN0eXBlcy5jX2Jvb2wsIHdpbnR5cGVzLkhXTkQsIHdpbnR5cGVzLkxQQVJBTSkKICAgIEBFbnVtV2luZG93c1Byb2MKICAgIGRlZiBfZW51bV9wcm9jKGh3bmQsIGxwYXJhbSk6CiAgICAgICAgaWYgbm90IElzV2luZG93VmlzaWJsZShod25kKToKICAgICAgICAgICAgcmV0dXJuIFRydWUKICAgICAgICBwaWQgPSB3aW50eXBlcy5EV09SRCgpCiAgICAgICAgR2V0V2luZG93VGhyZWFkUHJvY2Vzc0lkKGh3bmQsIGN0eXBlcy5ieXJlZihwaWQpKQogICAgICAgIGlmIHBpZC52YWx1ZSBub3QgaW4gc3RlYW1fcGlkczoKICAgICAgICAgICAgcmV0dXJuIFRydWUKICAgICAgICBsZW5ndGggPSBHZXRXaW5kb3dUZXh0TGVuZ3RoVyhod25kKQogICAgICAgIGlmIGxlbmd0aCA9PSAwOgogICAgICAgICAgICByZXR1cm4gVHJ1ZQogICAgICAgIGJ1ZiA9IGN0eXBlcy5jcmVhdGVfdW5pY29kZV9idWZmZXIobGVuZ3RoICsgMSkKICAgICAgICBHZXRXaW5kb3dUZXh0Vyhod25kLCBidWYsIGxlbmd0aCArIDEpCiAgICAgICAgdGl0bGUgPSBidWYudmFsdWUgb3IgIiIKICAgICAgICBpZiBzdWJzdHJfbCBpbiB0aXRsZS5sb3dlcigpOgogICAgICAgICAgICByZXR1cm4gRmFsc2UKICAgICAgICByZXR1cm4gVHJ1ZQogICAgRW51bVdpbmRvd3MoX2VudW1fcHJvYywgMCkKICAgIHJldHVybiBGYWxzZQoKIyA9PT09PSBTdGVhbSBsaWJyYXJ5IGltcG9ydCBoZWxwZXIgPT09PT0KCiMgPT09PT0gSW5zdGFsbGVkIFN0ZWFtIHRpdGxlcyBkZXRlY3RvciA9PT09PQpkZWYgX3BhcnNlX2xpYnJhcnlmb2xkZXJzX3ZkZih2ZGZfcGF0aDogUGF0aCkgLT4gTGlzdFtQYXRoXToKICAgICIiIlZlcnkgbGlnaHQgcGFyc2VyIHRvIGV4dHJhY3QgbGlicmFyeSBmb2xkZXIgcGF0aHMgZnJvbSBsaWJyYXJ5Zm9sZGVycy52ZGYiIiIKICAgIGxpYnMgPSBbXQogICAgdHJ5OgogICAgICAgIHR4dCA9IHZkZl9wYXRoLnJlYWRfdGV4dChlbmNvZGluZz0idXRmLTgiLCBlcnJvcnM9Imlnbm9yZSIpCiAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgIHJldHVybiBsaWJzCiAgICAjIE1hdGNoIGxpbmVzIGxpa2U6ICIxIiAgICAiRDpcXFN0ZWFtTGlicmFyeSIKICAgIGZvciBtIGluIHJlLmZpbmRpdGVyKHInIlxkKyJccyoiKFteIl0rKSInLCB0eHQpOgogICAgICAgIHRyeToKICAgICAgICAgICAgbGliID0gUGF0aChtLmdyb3VwKDEpLnJlcGxhY2UoJ1xcXFwnLCAnXFwnKSkKICAgICAgICAgICAgaWYgbGliLmV4aXN0cygpOgogICAgICAgICAgICAgICAgbGlicy5hcHBlbmQobGliKQogICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgIHBhc3MKICAgICMgQWx3YXlzIGluY2x1ZGUgdGhlIGRlZmF1bHQgU3RlYW0gcm9vdCBsaWJyYXJ5CiAgICByb290ID0gX2dldF9zdGVhbV9yb290KCkKICAgIGlmIHJvb3Q6CiAgICAgICAgbGlicy5hcHBlbmQocm9vdCkKICAgICMgRGUtZHVwCiAgICB1bmlxID0gW10KICAgIHNlZW4gPSBzZXQoKQogICAgZm9yIGxwIGluIGxpYnM6CiAgICAgICAga2V5ID0gc3RyKGxwLnJlc29sdmUoKSkubG93ZXIoKQogICAgICAgIGlmIGtleSBub3QgaW4gc2VlbjoKICAgICAgICAgICAgc2Vlbi5hZGQoa2V5KQogICAgICAgICAgICB1bmlxLmFwcGVuZChscCkKICAgIHJldHVybiB1bmlxCgpkZWYgZ2V0X2luc3RhbGxlZF9zdGVhbV9hcHBpZHMoKSAtPiBzZXQ6CiAgICAiIiJSZXR1cm4gYSBzZXQgb2YgaW5zdGFsbGVkIFN0ZWFtIGFwcGlkcyBieSBzY2FubmluZyBzdGVhbWFwcHMgbWFuaWZlc3RzIGFjcm9zcyBsaWJyYXJpZXMuIiIiCiAgICBhcHBpZHMgPSBzZXQoKQogICAgcm9vdCA9IF9nZXRfc3RlYW1fcm9vdCgpCiAgICBpZiBub3Qgcm9vdDoKICAgICAgICByZXR1cm4gYXBwaWRzCiAgICBzdGVhbWFwcHMgPSByb290IC8gInN0ZWFtYXBwcyIKICAgICMgbGlicmFyeWZvbGRlcnMudmRmIGxpc3RzIGFkZGl0aW9uYWwgbGlicmFyaWVzCiAgICBsaWJzID0gW10KICAgIHRyeToKICAgICAgICBsaWJzID0gX3BhcnNlX2xpYnJhcnlmb2xkZXJzX3ZkZihzdGVhbWFwcHMgLyAibGlicmFyeWZvbGRlcnMudmRmIikKICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgbGlicyA9IFtdCiAgICAjIEFsd2F5cyBpbmNsdWRlIHJvb3Qgc3RlYW1hcHBzCiAgICBpZiByb290IG5vdCBpbiBsaWJzOgogICAgICAgIGxpYnMuYXBwZW5kKHJvb3QpCiAgICAjIFNjYW4gbWFuaWZlc3RzIGluIGVhY2ggbGlicmFyeSdzIHN0ZWFtYXBwcwogICAgZm9yIGxpYl9yb290IGluIGxpYnM6CiAgICAgICAgc2EgPSBsaWJfcm9vdCAvICJzdGVhbWFwcHMiCiAgICAgICAgaWYgbm90IHNhLmV4aXN0cygpOgogICAgICAgICAgICBjb250aW51ZQogICAgICAgIGZvciBtZiBpbiBzYS5nbG9iKCJhcHBtYW5pZmVzdF8qLmFjZiIpOgogICAgICAgICAgICAjIGFwcG1hbmlmZXN0XzEyMzQ1LmFjZgogICAgICAgICAgICBtID0gcmUuc2VhcmNoKHIiYXBwbWFuaWZlc3RfKFxkKylcLmFjZiQiLCBtZi5uYW1lLCByZS5JKQogICAgICAgICAgICBpZiBtOgogICAgICAgICAgICAgICAgYXBwaWRzLmFkZChtLmdyb3VwKDEpKQogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgIyBmYWxsYmFjazogdHJ5IHJlYWRpbmcgZmlsZSBmb3IgImFwcGlkIiAiMTIzNDUiCiAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgdCA9IG1mLnJlYWRfdGV4dChlbmNvZGluZz0idXRmLTgiLCBlcnJvcnM9Imlnbm9yZSIpCiAgICAgICAgICAgICAgICAgICAgbTIgPSByZS5zZWFyY2gociciYXBwaWQiXHMqIihcZCspIicsIHQpCiAgICAgICAgICAgICAgICAgICAgaWYgbTI6CiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGlkcy5hZGQobTIuZ3JvdXAoMSkpCiAgICAgICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICAgICAgICAgIHBhc3MKICAgIHJldHVybiBhcHBpZHMKCmRlZiBpbXBvcnRfb3duZWRfZ2FtZXNfdG9fZGIoZGI6IERpY3Rbc3RyLCBBbnldLCBwYXlsb2FkOiBkaWN0LCBpbnN0YWxsZWRfb25seTogYm9vbCA9IFRydWUpIC0+IFR1cGxlW2ludCwgaW50XToKICAgIHRyeToKICAgICAgICBnYW1lcyA9IHBheWxvYWQuZ2V0KCJyZXNwb25zZSIsIHt9KS5nZXQoImdhbWVzIiwgW10pCiAgICAgICAgaW5zdGFsbGVkID0gZ2V0X2luc3RhbGxlZF9zdGVhbV9hcHBpZHMoKSBpZiBpbnN0YWxsZWRfb25seSBlbHNlIHNldCgpCiAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgIGdhbWVzID0gW10KICAgIGlmIG5vdCBpc2luc3RhbmNlKGdhbWVzLCBsaXN0KToKICAgICAgICByZXR1cm4gKDAsIDApCiAgICBleGlzdGluZyA9IHtzdHIoaXRlbS5nZXQoInN0ZWFtX2FwcGlkIiwiIikpLnN0cmlwKCkgZm9yIGl0ZW0gaW4gZGIuZ2V0KCJnYW1lcyIsIFtdKX0KICAgIGFkZGVkID0gMAogICAgc2tpcHBlZCA9IDAKICAgIGZvciBpdGVtIGluIGdhbWVzOgogICAgICAgIGFwcGlkID0gc3RyKGl0ZW0uZ2V0KCJhcHBpZCIsIiIpKS5zdHJpcCgpCiAgICAgICAgaWYgKG5vdCBhcHBpZC5pc2RpZ2l0KCkpIG9yIChhcHBpZCBpbiBleGlzdGluZykgb3IgKGluc3RhbGxlZF9vbmx5IGFuZCBhcHBpZCBub3QgaW4gaW5zdGFsbGVkKToKICAgICAgICAgICAgc2tpcHBlZCArPSAxOyBjb250aW51ZQogICAgICAgIG5hbWUgPSBpdGVtLmdldCgibmFtZSIpIG9yIGYiQXBwIHthcHBpZH0iCiAgICAgICAgZGIuc2V0ZGVmYXVsdCgiZ2FtZXMiLCBbXSkuYXBwZW5kKHsKICAgICAgICAgICAgIm5hbWUiOiBuYW1lLAogICAgICAgICAgICAic3RlYW1fYXBwaWQiOiBhcHBpZCwKICAgICAgICAgICAgImF1bWlkIjogIiIsCiAgICAgICAgICAgICJhcmdzIjogIiIsCiAgICAgICAgICAgICJleGUiOiAiIiwKICAgICAgICAgICAgInZhbGlkYXRlX3N0ZWFtIjogRmFsc2UsCiAgICAgICAgICAgICJ2YWxpZGF0ZV90aW1lb3V0IjogOTAwLAogICAgICAgICAgICAid2FpdCI6IDQ1LAogICAgICAgICAgICAicHJpb3JpdHkiOiAiSGlnaCIsCiAgICAgICAgICAgICJhZmZpbml0eSI6ICIiCiAgICAgICAgfSkKICAgICAgICBleGlzdGluZy5hZGQoYXBwaWQpCiAgICAgICAgYWRkZWQgKz0gMQogICAgcmV0dXJuIChhZGRlZCwgc2tpcHBlZCkKCmlmIF9fbmFtZV9fID09ICJfX21haW5fXyI6CiAgICBtYWluKCkKCgojIC0tLS0gU3RlYW0gdmFsaWRhdGlvbiB3aW5kb3cvdGl0bGUgaGVscGVycyAtLS0tCmltcG9ydCBjdHlwZXMKZnJvbSBjdHlwZXMgaW1wb3J0IHdpbnR5cGVz").decode("utf-8", errors="ignore")
    _src = _src.replace("if __name__ == '__main__':", "if __name__ == '__main__':\n    pass")
    _src = _src.replace('if __name__ == "__main__":', 'if __name__ == "__main__":\n    pass')
    _register_module("nonuwp.launcher", _src, "nonuwp/launcher.py")
except Exception as _e:
    print("[NONUWP] embed register failed:", _e)
# === END EMBED ===

# PyQt5 -> PyQt6 shim if only PyQt6 is available
try:
    import PyQt6.QtWidgets as _Q6W
    import PyQt6.QtCore as _Q6C
    import PyQt6.QtGui as _Q6G
    _pyqt5 = types.ModuleType("PyQt5")
    _pyqt5.QtWidgets = _Q6W
    _pyqt5.QtCore = _Q6C
    _pyqt5.QtGui = _Q6G
    sys.modules.setdefault("PyQt5", _pyqt5)
    sys.modules.setdefault("PyQt5.QtWidgets", _Q6W)
    sys.modules.setdefault("PyQt5.QtCore", _Q6C)
    sys.modules.setdefault("PyQt5.QtGui", _Q6G)
except Exception:
    pass

# === Registered helper modules ===
_register_module("xbl_auth_device_any", "\nimport argparse, json, sys, time\n\nCANDIDATE_CLIENT_IDS = [\n    \"00000000402B5328\",  # Xbox app (commonly used for MSA device flow)\n    \"000000004C12AE6F\",  # Alternate public Xbox client id\n]\n\ndef run_device_flow(client_id: str, out_path: str) -> bool:\n    try:\n        import msal\n    except ImportError:\n        print(\"This script requires 'msal'. Install with:  py -m pip install msal\", flush=True)\n        return False\n    app = msal.PublicClientApplication(client_id, authority=\"https://login.microsoftonline.com/consumers\")\n    # IMPORTANT: Do NOT include reserved scopes (openid, profile, offline_access)\n    scopes = [\"XboxLive.signin\"]\n    flow = app.initiate_device_flow(scopes=scopes)\n    if \"user_code\" not in flow:\n        return False\n    print(\"\\n=== Microsoft Sign-in ===\")\n    print(\"Go to:\", flow[\"verification_uri\"])\n    print(\"Enter code:\", flow[\"user_code\"])\n    print(\"Then return here; this window will finish automatically.\\n\")\n    result = app.acquire_token_by_device_flow(flow)\n    if \"access_token\" not in result:\n        print(\"Sign-in failed:\", result, file=sys.stderr)\n        return False\n    data = {\n        \"access_token\": result[\"access_token\"],\n        \"refresh_token\": result.get(\"refresh_token\",\"\"),\n        \"expires_at\": int(time.time()) + int(result.get(\"expires_in\", 28800)),\n        \"obtained_at\": int(time.time()),\n        \"token_type\": result.get(\"token_type\",\"Bearer\"),\n        \"scope\": result.get(\"scope\",\"XboxLive.signin\"),\n        \"client_id\": client_id,\n    }\n    with open(out_path, \"w\", encoding=\"utf-8\") as f:\n        json.dump(data, f, indent=2)\n    print(f\"Wrote fresh tokens to: {out_path} (client_id={client_id})\")\n    return True\n\ndef main():\n    ap = argparse.ArgumentParser()\n    ap.add_argument(\"--out\", default=\"tokens.json\", help=\"Where to write tokens.json\")\n    args = ap.parse_args()\n    for cid in CANDIDATE_CLIENT_IDS:\n        ok = run_device_flow(cid, args.out)\n        if ok:\n            return\n        else:\n            print(f\"Client {cid} failed, trying next\u2026\")\n    print(\"All client IDs failed. Ensure you are on a Microsoft Account (MSA) and try again.\", file=sys.stderr)\n    sys.exit(2)\n\nif __name__ == \"__main__\":\n    main()\n", "xbl_auth_device_any.py")
_register_module("xbl.xbl_auth_device_any", "\nimport argparse, json, sys, time\n\nCANDIDATE_CLIENT_IDS = [\n    \"00000000402B5328\",  # Xbox app (commonly used for MSA device flow)\n    \"000000004C12AE6F\",  # Alternate public Xbox client id\n]\n\ndef run_device_flow(client_id: str, out_path: str) -> bool:\n    try:\n        import msal\n    except ImportError:\n        print(\"This script requires 'msal'. Install with:  py -m pip install msal\", flush=True)\n        return False\n    app = msal.PublicClientApplication(client_id, authority=\"https://login.microsoftonline.com/consumers\")\n    # IMPORTANT: Do NOT include reserved scopes (openid, profile, offline_access)\n    scopes = [\"XboxLive.signin\"]\n    flow = app.initiate_device_flow(scopes=scopes)\n    if \"user_code\" not in flow:\n        return False\n    print(\"\\n=== Microsoft Sign-in ===\")\n    print(\"Go to:\", flow[\"verification_uri\"])\n    print(\"Enter code:\", flow[\"user_code\"])\n    print(\"Then return here; this window will finish automatically.\\n\")\n    result = app.acquire_token_by_device_flow(flow)\n    if \"access_token\" not in result:\n        print(\"Sign-in failed:\", result, file=sys.stderr)\n        return False\n    data = {\n        \"access_token\": result[\"access_token\"],\n        \"refresh_token\": result.get(\"refresh_token\",\"\"),\n        \"expires_at\": int(time.time()) + int(result.get(\"expires_in\", 28800)),\n        \"obtained_at\": int(time.time()),\n        \"token_type\": result.get(\"token_type\",\"Bearer\"),\n        \"scope\": result.get(\"scope\",\"XboxLive.signin\"),\n        \"client_id\": client_id,\n    }\n    with open(out_path, \"w\", encoding=\"utf-8\") as f:\n        json.dump(data, f, indent=2)\n    print(f\"Wrote fresh tokens to: {out_path} (client_id={client_id})\")\n    return True\n\ndef main():\n    ap = argparse.ArgumentParser()\n    ap.add_argument(\"--out\", default=\"tokens.json\", help=\"Where to write tokens.json\")\n    args = ap.parse_args()\n    for cid in CANDIDATE_CLIENT_IDS:\n        ok = run_device_flow(cid, args.out)\n        if ok:\n            return\n        else:\n            print(f\"Client {cid} failed, trying next\u2026\")\n    print(\"All client IDs failed. Ensure you are on a Microsoft Account (MSA) and try again.\", file=sys.stderr)\n    sys.exit(2)\n\nif __name__ == \"__main__\":\n    main()\n", "xbl/xbl_auth_device_any.py")
_register_module("xbl_friends_dock_INLINE_v5_REFRESH_UI_v2_PATCHED", "\nfrom __future__ import annotations\n\n\n# === BEGIN XBL INLINE LOADER PATCH (no subprocess, works in one-file EXE) ===\nimport sys, os\nfrom pathlib import Path\nimport importlib.util\n\ndef _exe_dir() -> Path:\n    try:\n        return Path(sys.executable).parent\n    except Exception:\n        return Path.cwd()\n\ndef _ensure_exe_dir_on_syspath():\n    p = str(_exe_dir())\n    if p not in sys.path:\n        sys.path.insert(0, p)\n\ndef _load_helper_module_from_path(helper_path: Path):\n    \"\"\"Load a .py module from disk in-process (even when frozen).\"\"\"\n    try:\n        spec = importlib.util.spec_from_file_location(\"xbl_login_standalone_v3_dyn\", str(helper_path))\n        if not spec or not spec.loader:\n            return None\n        mod = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(mod)\n        return mod\n    except Exception:\n        return None\n\ndef _run_xbl_helper_inline(parent=None) -> bool:\n    \"\"\"\n    Order:\n      1) ENV XBL_HELPER_DIR\n      2) import from xbl package (with exe_dir on sys.path)\n      3) load from file: exe_dir/xbl, _MEIPASS/xbl, cwd/xbl\n    \"\"\"\n    helper_file = \"xbl_login_standalone_v3.py\"\n\n    # 0) ENV override\n    env_dir = os.environ.get(\"XBL_HELPER_DIR\")\n    if env_dir:\n        hp = Path(env_dir) / helper_file\n        if hp.exists():\n            mod = _load_helper_module_from_path(hp)\n            if mod and hasattr(mod, \"main\"):\n                try: mod.main()\n                except SystemExit: pass\n                return True\n\n    # 1) Import as package from sibling xbl/\n    try:\n        _ensure_exe_dir_on_syspath()\n        from xbl import xbl_login_standalone_v3 as _m\n        try: _m.main()\n        except SystemExit: pass\n        return True\n    except Exception:\n        pass\n\n    # 2) Load from common locations\n    candidates = [\n        _exe_dir() / \"xbl\" / helper_file,              # next to EXE\n        Path(getattr(sys, \"_MEIPASS\", _exe_dir())) / \"xbl\" / helper_file if getattr(sys, \"frozen\", False) else None,\n        Path.cwd() / \"xbl\" / helper_file,\n    ]\n    for hp in [c for c in candidates if c]:\n        if hp.exists():\n            mod = _load_helper_module_from_path(hp)\n            if mod and hasattr(mod, \"main\"):\n                try: mod.main()\n                except SystemExit: pass\n                return True\n\n    return False\n\n# Back-compat: if old code calls the legacy helper runner name, route it here\ntry:\n    _run_xbl_login_helper_from_xbl  # type: ignore[name-defined]\nexcept Exception:\n    def _run_xbl_login_helper_from_xbl(parent=None):  # legacy name\n        return _run_xbl_helper_inline(parent)\n# === END XBL INLINE LOADER PATCH ===\n\nimport os, sys, json, time, threading, datetime\nfrom typing import Dict, List, Optional\nfrom pathlib import Path\n\nimport requests\nimport subprocess\nfrom PyQt6 import QtWidgets, QtCore\n\nLOG_FILE = os.environ.get(\"XBL_LOG_FILE\")\n\ndef _log(*a):\n    s = \"[xbl_friends_dock] \" + \" \".join(str(x) for x in a)\n    print(s, flush=True)\n    if LOG_FILE:\n        try:\n            Path(LOG_FILE).parent.mkdir(parents=True, exist_ok=True)\n            with open(LOG_FILE, \"a\", encoding=\"utf-8\") as f:\n                f.write(f\"{datetime.datetime.now().isoformat()} {s}\\n\")\n        except Exception:\n            pass\n\n# ---------- AUTH ----------\nXBL_USER_AUTH = \"https://user.auth.xboxlive.com/user/authenticate\"\nXBL_XSTS_AUTH = \"https://xsts.auth.xboxlive.com/xsts/authorize\"\n\ndef _strip_json_comments(s: str) -> str:\n    out = []; i=0; in_str=False; esc=False\n    while i < len(s):\n        ch = s[i]\n        if in_str:\n            out.append(ch)\n            if esc: esc=False\n            elif ch == '\\\\\\\\': esc=True\n            elif ch == '\"': in_str=False\n            i += 1; continue\n        if ch == '\"': in_str=True; out.append(ch); i += 1; continue\n        if ch == '/' and i+1 < len(s) and s[i+1] in ('/','*'):\n            if s[i+1] == '/':\n                j = s.find('\\\\n', i+2); \n                if j == -1: break\n                i = j + 1; continue\n            else:\n                j = s.find('*/', i+2)\n                if j == -1: break\n                i = j + 2; continue\n        out.append(ch); i += 1\n    return ''.join(out)\n\ndef _find_tokens_path() -> Optional[Path]:\n    env = os.environ.get(\"XBL_TOKENS_PATH\")\n    if env and Path(env).exists(): return Path(env)\n    here = Path(__file__).resolve().parent / \"tokens.json\"\n    if here.exists(): return here\n    cwd = Path(os.getcwd()) / \"tokens.json\"\n    if cwd.exists(): return cwd\n    local = Path(os.environ.get(\"LOCALAPPDATA\", Path.home())) / \"OpenXbox\" / \"xbox\" / \"tokens.json\"\n    if local.exists(): return local\n    return None\n\ndef _post_json(url: str, payload: dict) -> dict:\n    r = requests.post(url, headers={\"Content-Type\":\"application/json\",\"Accept\":\"application/json\",\"Accept-Language\":\"en-US\"}, json=payload, timeout=20)\n    _log(\"POST\", url, \"->\", r.status_code)\n    r.raise_for_status()\n    return r.json()\n\ndef _build_auth_from_tokens(tokens_path: Path) -> Dict[str,str]:\n    raw = tokens_path.read_text(encoding=\"utf-8\", errors=\"ignore\").strip()\n    try:\n        toks = json.loads(raw)\n    except Exception:\n        toks = json.loads(_strip_json_comments(raw))\n    at = toks.get(\"access_token\") or toks.get(\"AccessToken\") or toks.get(\"token\")\n    if not at:\n        raise RuntimeError(\"tokens.json missing access_token\")\n    # user token\n    user_req = {\n        \"RelyingParty\": \"http://auth.xboxlive.com\",\n        \"TokenType\": \"JWT\",\n        \"Properties\": {\n            \"AuthMethod\": \"RPS\",\n            \"SiteName\": \"user.auth.xboxlive.com\",\n            \"RpsTicket\": f\"d={at}\",\n        },\n    }\n    j = _post_json(XBL_USER_AUTH, user_req)\n    user_token = j[\"Token\"]\n    # xsts\n    xsts_req = {\n        \"RelyingParty\": \"http://xboxlive.com\",\n        \"TokenType\": \"JWT\",\n        \"Properties\": {\n            \"UserTokens\": [user_token],\n            \"SandboxId\": \"RETAIL\",\n        },\n    }\n    j2 = _post_json(XBL_XSTS_AUTH, xsts_req)\n    xsts = j2[\"Token\"]\n    uhs = j2[\"DisplayClaims\"][\"xui\"][0][\"uhs\"]\n    return {\n        \"Authorization\": f\"XBL3.0 x={uhs};{xsts}\",\n        \"Accept\": \"application/json\",\n        \"Accept-Language\": \"en-US\",\n    }\n\n# ---------- Service helpers ----------\ndef _request_json(url: str, headers: Dict, versions=(6,5,4,3,2,1), method=\"GET\", json=None, timeout=15):\n    last_exc = None\n    for ver in versions:\n        h = dict(headers); h[\"x-xbl-contract-version\"] = str(ver)\n        try:\n            if method == \"GET\":\n                r = requests.get(url, headers=h, timeout=timeout)\n            else:\n                r = requests.post(url, headers=h, json=json, timeout=timeout)\n            _log(f\"{method} {url} v{ver} ->\", r.status_code)\n            if r.status_code in (400,404):\n                continue\n            if r.status_code == 429:\n                time.sleep(0.5); continue\n            r.raise_for_status()\n            if r.content:\n                try: return r.json()\n                except Exception: return {}\n            return {}\n        except Exception as e:\n            last_exc = e\n    if last_exc: raise last_exc\n    return {}\n\ndef _me_xuid(headers: Dict) -> Optional[str]:\n    try:\n        data = _request_json(\"https://profile.xboxlive.com/users/me/profile/settings?settings=Gamertag\", headers, versions=(3,2,1))\n        pu = (data.get(\"profileUsers\") or [{}])[0]\n        return str(pu.get(\"id\") or \"\")\n    except Exception as e:\n        _log(\"xuid lookup failed:\", repr(e)); return None\n\ndef _fetch_friends(headers: Dict) -> List[Dict]:\n    urls = [\n        \"https://peoplehub.xboxlive.com/users/me/people/social\",\n        \"https://peoplehub.xboxlive.com/users/me/people\",\n        \"https://social.xboxlive.com/users/me/people\",\n    ]\n    me = _me_xuid(headers)\n    if me:\n        urls.insert(0, f\"https://peoplehub.xboxlive.com/users/xuid({me})/people/social\")\n        urls.insert(1, f\"https://peoplehub.xboxlive.com/users/xuid({me})/people/social/summary\")\n\n    for url in urls:\n        try:\n            data = _request_json(url, headers, versions=(6,5,4,3,2,1))\n            arr = data.get(\"people\") or data.get(\"peopleList\") or data.get(\"friends\") or data.get(\"summary\") or []\n            out = []\n            for p in arr or []:\n                x = str(p.get(\"xuid\") or p.get(\"xboxUserId\") or p.get(\"id\") or \"\")\n                g = p.get(\"gamertag\") or p.get(\"modernGamertag\") or p.get(\"preferredName\") or \"\"\n                out.append({\"xuid\": x, \"gamertag\": g})\n            if out:\n                _log(\"friends from\", url, \"->\", len(out))\n                return out\n        except Exception as e:\n            _log(\"friends error for\", url, \":\", repr(e))\n    return []\n\ndef _resolve_gamertags_batch(headers: Dict, xuids: List[str]) -> Dict[str,str]:\n    if not xuids: return {}\n    url = \"https://profile.xboxlive.com/users/batch/profile/settings\"\n    payload = {\"settings\": [\"Gamertag\"], \"userIds\": [f\"xuid({x})\" for x in xuids]}\n    try:\n        data = _request_json(url, headers, versions=(3,2,1), method=\"POST\", json=payload)\n        m = {}\n        for u in data.get(\"profileUsers\", []):\n            uid = str(u.get(\"id\") or \"\")\n            gt = \"\"\n            for s in u.get(\"settings\", []):\n                if s.get(\"id\") == \"Gamertag\":\n                    gt = s.get(\"value\") or \"\"\n            if uid and gt: m[uid] = gt\n        _log(\"resolved gamertags (batch):\", len(m))\n        return m\n    except Exception as e:\n        _log(\"resolve gt batch failed:\", repr(e)); return {}\n\ndef _resolve_gamertags_slow(headers: Dict, xuids: List[str]) -> Dict[str,str]:\n    out = {}\n    for x in xuids:\n        url = f\"https://profile.xboxlive.com/users/xuid({x})/profile/settings?settings=Gamertag\"\n        try:\n            data = _request_json(url, headers, versions=(3,2,1), method=\"GET\")\n            pu = (data.get(\"profileUsers\") or [{}])[0]\n            uid = str(pu.get(\"id\") or \"\")\n            gt = \"\"\n            for s in pu.get(\"settings\", []):\n                if s.get(\"id\") == \"Gamertag\": gt = s.get(\"value\") or \"\"\n            if uid and gt: out[uid] = gt\n        except Exception as e:\n            _log(\"resolve gt slow failed for\", x, \":\", repr(e))\n        time.sleep(0.05)\n    _log(\"resolved gamertags (slow):\", len(out))\n    return out\n\ndef _extract_title_from_presence(data: dict) -> str:\n    for d in data.get(\"devices\", []):\n        for t in d.get(\"titles\", []):\n            name = t.get(\"name\") or t.get(\"titleName\") or \"\"\n            act = t.get(\"activity\") or {}\n            if t.get(\"placement\") == \"Full\" or act.get(\"richPresence\") or act.get(\"broadcastTitle\"):\n                if name: return name\n    return \"\"\n\ndef _presence_batch(headers: Dict, xuids: List[str]) -> Dict[str, Dict]:\n    result = {}\n    try:\n        payload = {\"users\": [f\"xuid({x})\" for x in xuids], \"level\": \"all\"}\n        data = _request_json(\"https://presence.xboxlive.com/users/batch\", headers, versions=(3,2,1), method=\"POST\", json=payload)\n        users = data.get(\"responses\") or data.get(\"users\") or []\n        for u in users:\n            uid = u.get(\"id\") or u.get(\"xuid\") or \"\"\n            if isinstance(uid, str) and uid.startswith(\"xuid(\"): uid = uid[5:-1]\n            state = u.get(\"state\") or u.get(\"presenceState\") or \"\"\n            title = _extract_title_from_presence(u)\n            if uid: result[str(uid)] = {\"state\": state, \"title\": title}\n        if result:\n            _log(\"presence batch OK:\", len(result))\n            return result\n    except Exception as e:\n        _log(\"presence batch failed:\", repr(e))\n    return {}\n\ndef _presence_slow(headers: Dict, xuids: List[str], progress_cb=None) -> Dict[str, Dict]:\n    result = {}\n    for i, x in enumerate(xuids, 1):\n        url = f\"https://userpresence.xboxlive.com/users/xuid({x})?level=all\"\n        try:\n            data = _request_json(url, headers, versions=(3,2,1), method=\"GET\")\n            state = data.get(\"state\") or data.get(\"presenceState\") or \"\"\n            title = _extract_title_from_presence(data)\n            result[str(x)] = {\"state\": state, \"title\": title}\n            if progress_cb and (i % 10 == 0 or i == len(xuids)):\n                progress_cb(i, len(xuids))\n        except Exception as e:\n            _log(\"presence slow failed for\", x, \":\", repr(e))\n        time.sleep(0.045)\n    _log(\"presence slow collected:\", len(result))\n    return result\n\n# ---------- UI (filterable) ----------\n\nclass TransparencyDialog(QtWidgets.QDialog):\n    def __init__(self, dock: QtWidgets.QWidget):\n        super().__init__(dock)\n        self._dock = dock\n        self.setWindowTitle(\"Transparency\")\n        self.setModal(False)\n        self.resize(320, 100)\n\n        v = QtWidgets.QVBoxLayout(self)\n        self.label = QtWidgets.QLabel(self)\n        self.slider = QtWidgets.QSlider(QtCore.Qt.Orientation.Horizontal, self)\n        self.slider.setMinimum(20)   # 20% minimum to avoid disappearing\n        self.slider.setMaximum(100)  # 100% = opaque\n        # initialize from current window opacity\n        current = int(round((dock.windowOpacity() or 1.0) * 100))\n        current = max(self.slider.minimum(), min(self.slider.maximum(), current))\n        self.slider.setValue(current)\n        self._update_label(current)\n\n        self.slider.valueChanged.connect(self._on_change)\n\n        btn_row = QtWidgets.QHBoxLayout()\n        self.btnReset = QtWidgets.QPushButton(\"Reset\")\n        self.btnClose = QtWidgets.QPushButton(\"Close\")\n        btn_row.addStretch(1)\n        btn_row.addWidget(self.btnReset)\n        btn_row.addWidget(self.btnClose)\n\n        v.addWidget(self.label)\n        v.addWidget(self.slider)\n        v.addLayout(btn_row)\n\n        self.btnReset.clicked.connect(self._reset)\n        self.btnClose.clicked.connect(self.close)\n\n    def _update_label(self, val: int):\n        self.label.setText(f\"Opacity: {val}%\")\n\n    def _on_change(self, val: int):\n        try:\n            self._dock.setWindowOpacity(val / 100.0)\n            self._update_label(val)\n            try:\n                self._dock._save_settings(opacity_percent=int(val))\n            except Exception as _e:\n                _log(\"settings write warn:\", repr(_e))\n        except Exception as e:\n            _log(\"opacity change error:\", repr(e))\n\n    def _reset(self):\n        self.slider.setValue(100)\n        try:\n            self._dock._save_settings(opacity_percent=100)\n        except Exception as _e:\n            _log(\"settings write warn:\", repr(_e))\n\nclass FriendsDock(QtWidgets.QDialog):\n\n    # --- Cache helpers (ADD-ONLY) ---\n    # --- Settings helpers (ADD-ONLY) ---\n    def _settings_path(self) -> Path:\n        try:\n            return Path(__file__).resolve().parent / \"friends_settings.json\"\n        except Exception:\n            return Path(\"friends_settings.json\")\n\n    def _load_settings(self) -> dict:\n        try:\n            p = self._settings_path()\n            if not p.exists():\n                return {}\n            raw = p.read_text(encoding=\"utf-8\", errors=\"ignore\")\n            return json.loads(raw) if raw.strip() else {}\n        except Exception as e:\n            _log(\"settings load error:\", repr(e))\n            return {}\n\n    def _save_settings(self, **updates):\n        try:\n            data = self._load_settings()\n            data.update(updates)\n            self._settings_path().write_text(json.dumps(data, ensure_ascii=False, indent=0), encoding=\"utf-8\")\n            _log(\"settings saved:\", updates)\n        except Exception as e:\n            _log(\"settings save error:\", repr(e))\n    # --- end settings helpers ---\n\n    def _cache_path(self) -> Path:\n        try:\n            return Path(__file__).resolve().parent / \"friends_cache.json\"\n        except Exception:\n            return Path(\"friends_cache.json\")\n\n    def _save_cached_rows(self, rows):\n        try:\n            data = [{\"gamertag\": gt, \"status\": st, \"game\": gm} for (gt, st, gm) in (rows or [])]\n            self._cache_path().write_text(json.dumps(data, ensure_ascii=False, indent=0), encoding=\"utf-8\")\n            _log(\"cache saved:\", str(self._cache_path()), len(data), \"rows\")\n        except Exception as e:\n            _log(\"cache save error:\", repr(e))\n\n    def _load_cached_rows(self):\n        try:\n            p = self._cache_path()\n            if not p.exists():\n                return False\n            raw = p.read_text(encoding=\"utf-8\", errors=\"ignore\")\n            arr = json.loads(raw) if raw.strip() else []\n            rows = [(d.get(\"gamertag\",\"\"), d.get(\"status\",\"\"), d.get(\"game\",\"\")) for d in arr]\n            if rows:\n                self.sig_set_rows.emit(rows)\n                self.sig_set_status.emit(f\"Restored {len(rows)} cached friends\")\n                _log(\"cache restored:\", len(rows), \"rows\")\n                return True\n            return False\n        except Exception as e:\n            _log(\"cache load error:\", repr(e))\n            return False\n    # --- end cache helpers ---\n\n    sig_set_status = QtCore.pyqtSignal(str)\n    sig_set_rows = QtCore.pyqtSignal(list)   # list of (gt, status, game)\n    sig_enable_btn = QtCore.pyqtSignal(bool)\n    sig_busy = QtCore.pyqtSignal(bool)\n\n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self.setWindowTitle(\"Xbox Friends\")\n        self.resize(720, 740)\n        # Enable minimize button on title bar\n        try:\n            self.setWindowFlags(self.windowFlags() |\n                                QtCore.Qt.WindowType.WindowMinimizeButtonHint |\n                                QtCore.Qt.WindowType.WindowSystemMenuHint)\n        except Exception as _e:\n            _log(\"minimize flag warn:\", repr(_e))\n        self._full_rows: List[tuple] = []\n\n        v = QtWidgets.QVBoxLayout(self)\n        top = QtWidgets.QHBoxLayout()\n        self.lbl = QtWidgets.QLabel(\"Ready.\")\n        self.view = QtWidgets.QComboBox()\n        self.view.addItems([\"All (Online first)\", \"Online only\"])\n        self.btn = QtWidgets.QPushButton(\"Refresh\")\n        top.addWidget(self.lbl); top.addStretch(1); top.addWidget(QtWidgets.QLabel(\"View:\")); top.addWidget(self.view)\n        # \"Always on top\" toggle (ADD-ONLY)\n        self.chkAlwaysOnTop = QtWidgets.QCheckBox(\"Always on top\")\n        top.addWidget(self.chkAlwaysOnTop)\n        # Busy spinner (indeterminate)  hidden by default\n        self._busy = QtWidgets.QProgressBar(self)\n        self._busy.setRange(0, 0)\n        self._busy.setTextVisible(False)\n        self._busy.setFixedWidth(80)\n        self._busy.hide()\n        top.insertWidget(1, self._busy)\n        # Auto-refresh timer (1 minute; OFF by default)\n        self._autoRefreshTimer = QtCore.QTimer(self)\n        self._autoRefreshTimer.setInterval(60_000)\n        self._autoRefreshTimer.timeout.connect(self.refresh)\n        self.btnAuth = QtWidgets.QPushButton(\"Sign in / Choose tokens.json\")\n        self.btnRefreshTokenOnly = QtWidgets.QPushButton(\"Refresh token only\")\n        top.addWidget(self.btnAuth); top.addWidget(self.btnRefreshTokenOnly); top.addWidget(self.btn)\n\n        # ---- Settings dropdown (cosmetic only) ----\n        # ---- Settings dropdown (cosmetic only) ----\n        self.btnSettings = QtWidgets.QToolButton()\n        self.btnSettings.setText(\"Settings\")\n        self.btnSettings.setPopupMode(QtWidgets.QToolButton.ToolButtonPopupMode.InstantPopup)\n        _menu = QtWidgets.QMenu(self.btnSettings)\n        _a_refresh = _menu.addAction(\"Refresh\"); _a_refresh.triggered.connect(self.refresh)\n        _a_signin  = _menu.addAction(\"Sign in / Choose tokens.json\"); _a_signin.triggered.connect(self._do_auth)\n        _a_rtonly  = _menu.addAction(\"Refresh token only\"); _a_rtonly.triggered.connect(self._refresh_token_only)\n        _a_transp  = _menu.addAction(\"Transparency\"); _a_transp.triggered.connect(self._open_transparency)\n        self._autoAction = _menu.addAction(\"Auto Refresh (1 minute)\")\n        self._autoAction.setCheckable(True)\n        self._autoAction.setChecked(False)\n        self._autoAction.triggered.connect(self._toggle_auto_refresh)\n        self.btnSettings.setMenu(_menu)\n        top.addWidget(self.btnSettings)\n        try:\n            self.btn.hide(); self.btnAuth.hide(); self.btnRefreshTokenOnly.hide()\n        except Exception:\n            pass\n        # ---- end Settings dropdown ----\n\n        # Hide original buttons (objects remain; signals intact)\n        try:\n            self.btn.hide()\n            self.btnAuth.hide()\n            self.btnRefreshTokenOnly.hide()\n        except Exception as _e:\n            _log(\"hide-buttons warning:\", repr(_e))\n        # ---- end Settings dropdown ----\n\n        v.addLayout(top)\n\n        self.table = QtWidgets.QTableWidget(0, 3)\n        self.table.setHorizontalHeaderLabels([\"Gamertag\", \"Status\", \"Game\"])\n        self.table.horizontalHeader().setStretchLastSection(True)\n        self.table.setEditTriggers(QtWidgets.QAbstractItemView.EditTrigger.NoEditTriggers)\n        v.addWidget(self.table, 1)\n\n        self.btn.clicked.connect(self.refresh)\n        self.btnAuth.clicked.connect(self._do_auth)\n        self.btnRefreshTokenOnly.clicked.connect(self._refresh_token_only)\n        self.view.currentIndexChanged.connect(self._reapply_filter)\n        self.view.currentIndexChanged.connect(lambda _i: self._save_settings(view_index=int(_i)))\n        self.chkAlwaysOnTop.toggled.connect(self._apply_always_on_top)\n\n        self.sig_set_status.connect(self._set_status)\n        self.sig_set_rows.connect(self._receive_full_rows)\n        self.sig_enable_btn.connect(self.btn.setEnabled)\n        self.sig_busy.connect(self._busy.setVisible)\n\n        # Load and apply persistent settings (opacity, auto-refresh)\n        try:\n            _s = self._load_settings()\n            # Apply opacity\n            _op = int(_s.get(\"opacity_percent\", 100))\n            _op = max(20, min(100, _op))\n            self.setWindowOpacity(_op / 100.0)\n            # Apply auto-refresh state\n            _auto = bool(_s.get(\"auto_refresh\", False))\n            if hasattr(self, \"_autoAction\"):\n                self._autoAction.setChecked(_auto)\n            if _auto:\n                self._autoRefreshTimer.start()\n            # Apply view filter index\n            try:\n                _vi = int(_s.get(\"view_index\", 0))\n                if 0 <= _vi < self.view.count():\n                    self.view.setCurrentIndex(_vi)\n            except Exception:\n                pass\n            # Apply 'Always on top'\n            _aot = bool(_s.get(\"always_on_top\", False))\n            if hasattr(self, 'chkAlwaysOnTop'):\n                self.chkAlwaysOnTop.setChecked(_aot)\n            self.setWindowFlag(QtCore.Qt.WindowType.WindowStaysOnTopHint, _aot)\n            self.show()\n        except Exception as _e:\n            _log(\"apply settings warn:\", repr(_e))\n\n        # Show cached rows immediately (if available) before first refresh\n        try:\n            _had_cache = self._load_cached_rows()\n        except Exception as _e:\n            _had_cache = False\n            _log(\"warm restore warn:\", repr(_e))\n        if not _had_cache:\n            QtCore.QTimer.singleShot(150, self.refresh)\n\n    def _set_status(self, s: str):\n        self.lbl.setText(s); _log(\"status:\", s)\n\n    def _receive_full_rows(self, rows: List[tuple]):\n        # rows already have \"Online first\" order\n        self._full_rows = rows\n        self._reapply_filter()\n\n    def _reapply_filter(self):\n        rows = self._full_rows\n        if self.view.currentIndex() == 1:  # Online only\n            rows = [r for r in rows if r[1] == \"Online\"]\n        self._apply_rows(rows)\n\n\n    # --- Status LED helpers (ADD-ONLY) ---\n    def _build_led_icon(self, color: QtCore.Qt.GlobalColor) -> QtWidgets.QStyle.StandardPixmap | QtWidgets.QStyle:\n        # Create a small circular pixmap to act as an LED\n        pm = QtGui.QPixmap(14, 14)\n        pm.fill(QtCore.Qt.GlobalColor.transparent)\n        painter = QtGui.QPainter(pm)\n        painter.setRenderHint(QtGui.QPainter.RenderHint.Antialiasing, True)\n        brush = QtGui.QBrush(color)\n        pen = QtGui.QPen(QtCore.Qt.GlobalColor.black)\n        pen.setWidth(1)\n        painter.setPen(pen)\n        painter.setBrush(brush)\n        painter.drawEllipse(1, 1, 12, 12)\n        painter.end()\n        return QtGui.QIcon(pm)\n\n    def _icon_for_state(self, st: str) -> QtGui.QIcon:\n        try:\n            if not hasattr(self, \"_led_green\"):\n                self._led_green = self._build_led_icon(QtCore.Qt.GlobalColor.green)\n                self._led_red   = self._build_led_icon(QtCore.Qt.GlobalColor.red)\n                self._led_blank = self._build_led_icon(QtCore.Qt.GlobalColor.gray)\n        except Exception:\n            pass\n        s = (st or \"\").strip().lower()\n        if s == \"online\":\n            return getattr(self, \"_led_green\", QtWidgets.QApplication.style().standardIcon(QtWidgets.QStyle.StandardPixmap.SP_DialogApplyButton))\n        elif s == \"offline\":\n            return getattr(self, \"_led_red\", QtWidgets.QApplication.style().standardIcon(QtWidgets.QStyle.StandardPixmap.SP_DialogCancelButton))\n        return getattr(self, \"_led_blank\", QtWidgets.QApplication.style().standardIcon(QtWidgets.QStyle.StandardPixmap.SP_MessageBoxInformation))\n    # --- end Status LED helpers ---\n\n    def _apply_rows(self, rows: List[tuple]):\n        self.table.setSortingEnabled(False)\n        self.table.setRowCount(len(rows))\n        for i,(gt,st,gm) in enumerate(rows):\n            # Gamertag text\n            self.table.setItem(i,0, QtWidgets.QTableWidgetItem(gt))\n            # Status LED (icon only)\n            _status_item = QtWidgets.QTableWidgetItem(\"\")\n            try:\n                _status_item.setIcon(self._icon_for_state(st))\n                _status_item.setText(\"\")  # no text, icon only\n                _status_item.setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)\n            except Exception:\n                _status_item.setText(st)\n            self.table.setItem(i,1, _status_item)\n            # Game text\n            self.table.setItem(i,2, QtWidgets.QTableWidgetItem(gm))\n        self.table.setSortingEnabled(True)\n        # Keep consistent order: Online first (already), within that alphabetically\n        self.table.sortItems(1, QtCore.Qt.SortOrder.AscendingOrder)\n\n\n    def _apply_always_on_top(self, checked: bool):\n        try:\n            self.setWindowFlag(QtCore.Qt.WindowType.WindowStaysOnTopHint, bool(checked))\n            self.show()  # re-apply flags\n            try:\n                self._save_settings(always_on_top=bool(checked))\n            except Exception as _e:\n                _log(\"settings write warn:\", repr(_e))\n        except Exception as e:\n            _log(\"always on top apply error:\", repr(e))\n\n    def _open_transparency(self):\n        try:\n            if not hasattr(self, \"_transparencyDlg\") or self._transparencyDlg is None:\n                self._transparencyDlg = TransparencyDialog(self)\n            self._transparencyDlg.show()\n            self._transparencyDlg.raise_()\n            self._transparencyDlg.activateWindow()\n        except Exception as e:\n            QtWidgets.QMessageBox.critical(self, \"Error\", f\"Transparency error: {e}\")\n\n    def _refresh_token_only(self):\n        \"\"\"\n        Run xbl_login_standalone_v3.py to refresh tokens, then prompt where the new token was saved.\n        \"\"\"\n        try:\n            self.sig_enable_btn.emit(False)\n            self.sig_set_status.emit(\"Refreshing token via login helper...\")\n\n            base = Path(__file__).resolve().parent\n            helper = base / \"xbl_login_standalone_v3.py\"\n            if not helper.exists():\n                QtWidgets.QMessageBox.critical(self, \"Missing helper\", \"xbl_login_standalone_v3.py not found next to this script.\")\n                self.sig_enable_btn.emit(True)\n                return\n\n            proc = subprocess.run([sys.executable, str(helper)], cwd=str(base), capture_output=True, text=True)\n            out = (proc.stdout or \"\") + \"\\n\" + (proc.stderr or \"\")\n            if proc.returncode != 0:\n                QtWidgets.QMessageBox.critical(self, \"Refresh failed\", f\"Helper exited with {proc.returncode}.\\n\\nOutput (tail):\\n{out[-2000:]}\")\n                self.sig_enable_btn.emit(True)\n                return\n\n            # Parse output to find the saved tokens file\n            tokens_path = None\n            for line in out.splitlines():\n                s = line.strip()\n                if s.startswith(\"[Info] Tokens file:\"):\n                    tokens_path = s.split(\":\", 1)[1].strip()\n                    break\n            if not tokens_path:\n                # Fallback to typical default\n                tokens_path = str(Path(os.environ.get(\"LOCALAPPDATA\", Path.home())) / \"OpenXbox\" / \"xbox\" / \"tokens.json\")\n\n            # Prompt user where it was saved and offer to use it now\n            msg = QtWidgets.QMessageBox(self)\n            msg.setIcon(QtWidgets.QMessageBox.Icon.Information)\n            msg.setWindowTitle(\"Token refreshed\")\n            msg.setText(f\"New tokens were saved here:\\n{tokens_path}\\n\\nUse this tokens.json now?\")\n            yes_btn = msg.addButton(\"Use now\", QtWidgets.QMessageBox.ButtonRole.AcceptRole)\n            no_btn = msg.addButton(\"Cancel\", QtWidgets.QMessageBox.ButtonRole.RejectRole)\n            msg.exec()\n            if msg.clickedButton() is yes_btn:\n                os.environ[\"XBL_TOKENS_PATH\"] = tokens_path\n                self.sig_set_status.emit(\"Using refreshed tokens. Reloading\")\n                QtCore.QTimer.singleShot(200, self.refresh)\n            else:\n                self.sig_enable_btn.emit(True)\n\n        except Exception as e:\n            QtWidgets.QMessageBox.critical(self, \"Error\", str(e))\n            self.sig_enable_btn.emit(True)\n\n    def _do_auth(self):\n        \"\"\"\n        Opens a small chooser:\n        - Use existing tokens.json (browse & load)\n        - Run device sign-in helper to create a new tokens.json\n        \"\"\"\n        try:\n            default_path = os.environ.get(\"XBL_TOKENS_PATH\") or str((Path.cwd() / \"tokens.json\"))\n            # Simple chooser via QMessageBox-style buttons\n            dlg = QtWidgets.QMessageBox(self)\n            dlg.setIcon(QtWidgets.QMessageBox.Icon.Question)\n            dlg.setWindowTitle(\"Xbox sign-in / tokens.json\")\n            dlg.setText(\"How would you like to provide tokens?\")\n            use_existing = dlg.addButton(\"Use existing tokens.json\", QtWidgets.QMessageBox.ButtonRole.AcceptRole)\n            run_helper  = dlg.addButton(\"Run device sign-in\", QtWidgets.QMessageBox.ButtonRole.ActionRole)\n            cancel_btn  = dlg.addButton(\"Cancel\", QtWidgets.QMessageBox.ButtonRole.RejectRole)\n            # PyQt6: exec()\n            dlg.exec()\n            clicked = dlg.clickedButton()\n            if clicked is cancel_btn:\n                return\n\n            if clicked is use_existing:\n                path, _ = QtWidgets.QFileDialog.getOpenFileName(\n                    self, \"Select tokens.json\", default_path, \"JSON Files (*.json);;All Files (*)\"\n                )\n                if not path:\n                    return\n                # point the app to this file and refresh\n                os.environ[\"XBL_TOKENS_PATH\"] = path\n                self.sig_set_status.emit(\"Using selected tokens.json. Reloading\")\n                QtCore.QTimer.singleShot(200, self.refresh)\n                return\n\n            # Otherwise run helper to produce a new tokens.json\n            save_path, _ = QtWidgets.QFileDialog.getSaveFileName(\n                self, \"Save tokens.json\", default_path, \"JSON Files (*.json);;All Files (*)\"\n            )\n            if not save_path:\n                return\n\n            self.sig_enable_btn.emit(False)\n            self.sig_set_status.emit(\"Starting device sign-in follow the console/device code flow\")\n\n            base = Path(__file__).resolve().parent\n            helper = None\n            for name in [\"xbl_auth_device_any.py\", \"xbl_login_standalone_v3.py\", \"xbl_signin_from_oauth_tokens.py\"]:\n                cand = base / name\n                if cand.exists():\n                    helper = str(cand)\n                    break\n            if helper is None:\n                QtWidgets.QMessageBox.critical(\n                    self, \"Missing helper\",\n                    \"Could not find a sign-in helper (xbl_auth_device_any.py or xbl_login_standalone_v3.py).\"\n                )\n                self.sig_enable_btn.emit(True)\n                return\n\n            import subprocess, sys\n            # Safe subprocess: helper is resolved from trusted package directory and\n            # save_path is a user-chosen file path, not executable input.\n            proc = subprocess.run([sys.executable, helper, \"--out\", save_path], cwd=str(base))  # nosec B603\n            if proc.returncode != 0:\n                QtWidgets.QMessageBox.critical(self, \"Sign-in failed\", f\"Auth helper exited with code {proc.returncode}.\")\n                self.sig_enable_btn.emit(True)\n                return\n\n            os.environ[\"XBL_TOKENS_PATH\"] = save_path\n            self.sig_set_status.emit(\"Token saved. Reloading\")\n            QtCore.QTimer.singleShot(200, self.refresh)\n\n        except Exception as e:\n            QtWidgets.QMessageBox.critical(self, \"Error\", str(e))\n            self.sig_enable_btn.emit(True)\n\n\n    def _toggle_auto_refresh(self):\n        try:\n            if self._autoRefreshTimer.isActive():\n                self._autoRefreshTimer.stop()\n                if hasattr(self, '_autoAction') and self._autoAction:\n                    self._autoAction.setChecked(False)\n                self.sig_set_status.emit(\"Auto Refresh: OFF\")\n                try:\n                    self._save_settings(auto_refresh=False)\n                except Exception as _e:\n                    _log(\"settings write warn:\", repr(_e))\n            else:\n                self._autoRefreshTimer.start()\n                if hasattr(self, '_autoAction') and self._autoAction:\n                    self._autoAction.setChecked(True)\n                self.sig_set_status.emit(\"Auto Refresh: ON (every 1 min)\")\n                try:\n                    self._save_settings(auto_refresh=True)\n                except Exception as _e:\n                    _log(\"settings write warn:\", repr(_e))\n        except Exception as e:\n            QtWidgets.QMessageBox.critical(self, \"Auto Refresh Error\", str(e))\n\n    def refresh(self):\n        self.sig_enable_btn.emit(False); self.sig_set_status.emit(\"\"); self.sig_busy.emit(True); self.sig_set_rows.emit([])\n\n        def _run():\n            try:\n                # ----- auth\n                tpath = _find_tokens_path()\n                if not tpath:\n                    raise RuntimeError(\"tokens.json not found. Set XBL_TOKENS_PATH or place tokens.json next to the script.\")\n                _log(\"Using tokens.json at:\", str(tpath))\n                headers = _build_auth_from_tokens(tpath)\n\n                # ----- friends list\n                friends = _fetch_friends(headers)\n                if not friends:\n                    raise RuntimeError(\"No friends returned (service/permissions).\")\n\n                self.sig_set_status.emit(f\"{len(friends)} friends (resolving names...)\")\n\n                # ----- gamertags\n                missing = [f[\"xuid\"] for f in friends if f.get(\"xuid\") and not f.get(\"gamertag\")]\n                gmap = _resolve_gamertags_batch(headers, missing) if missing else {}\n                if missing and len(gmap) < len(missing):\n                    slow_needed = [x for x in missing if x not in gmap]\n                    if slow_needed:\n                        gmap.update(_resolve_gamertags_slow(headers, slow_needed))\n                for f in friends:\n                    if not f.get(\"gamertag\"):\n                        f[\"gamertag\"] = gmap.get(f.get(\"xuid\",\"\"), f.get(\"xuid\",\"\"))\n\n                self.sig_set_status.emit(f\"{len(friends)} friends (loading presence...)\")\n\n                # ----- presence\n                xuids = [f[\"xuid\"] for f in friends if f.get(\"xuid\")]\n                pres = _presence_batch(headers, xuids) if xuids else {}\n                if xuids and len(pres) < len(xuids):\n                    def _progress(i, n):\n                        self.sig_set_status.emit(f\"{len(friends)} friends (presence {i}/{n})\")\n                    pres.update(_presence_fast(headers, [x for x in xuids if x not in pres], _progress, workers=24))\n\n                rows = []\n                for f in friends:\n                    x = f.get(\"xuid\",\"\"); gt = f.get(\"gamertag\") or x\n                    p = pres.get(x, {})\n                    state = \"Online\" if str(p.get(\"state\",\"\")).lower()==\"online\" else (\"Offline\" if p else \"\")\n                    title = p.get(\"title\",\"\")\n                    rows.append((gt, state, title))\n                rows.sort(key=lambda r: (r[1]!=\"Online\", r[0].lower()))\n\n                self.sig_set_rows.emit(rows)\n                try:\n                    self._save_cached_rows(rows)\n                except Exception as _e:\n                    _log(\"cache post-refresh warn:\", repr(_e))\n                self.sig_set_status.emit(f\"{len(rows)} friends (presence applied)\")\n                self.sig_busy.emit(False)\n                self.sig_enable_btn.emit(True)\n\n            except Exception as e:\n                _log(\"Error:\", repr(e))\n                self.sig_set_status.emit(f\"Error: {e.__class__.__name__}: {e}\")\n                self.sig_busy.emit(False)\n                self.sig_enable_btn.emit(True)\n\n        threading.Thread(target=_run, daemon=True).start()\ndef _presence_fast(headers: Dict, xuids: List[str], progress_cb=None, workers: int = 24) -> Dict[str, Dict]:\n    \"\"\"Concurrent presence fetch using a shared Session. Keeps requests gentle but parallel.\"\"\"\n    import concurrent.futures, time, math\n    result = {}\n    if not xuids:\n        return result\n\n    # Shared session with connection pool\n    sess = requests.Session()\n    try:\n        from requests.adapters import HTTPAdapter\n        from urllib3.util.retry import Retry\n        adapter = HTTPAdapter(pool_connections=workers*2, pool_maxsize=workers*2, max_retries=0)\n        sess.mount(\"https://\", adapter); sess.mount(\"http://\", adapter)\n    except Exception:\n        pass\n\n    base_headers = dict(headers)\n    base_headers[\"x-xbl-contract-version\"] = \"3\"\n    url_tpl = \"https://userpresence.xboxlive.com/users/xuid({})?level=all\"\n\n    # Gentle concurrency: cap workers, backoff on 429, shorter timeout\n    def fetch_one(xuid: str):\n        url = url_tpl.format(xuid)\n        tries = 0\n        delay = 0.3\n        while True:\n            tries += 1\n            try:\n                r = sess.get(url, headers=base_headers, timeout=8)\n                status = r.status_code\n                if status == 429:\n                    # Too many requests; back off a bit and retry\n                    time.sleep(delay)\n                    delay = min(delay * 1.6, 3.0)\n                    if tries < 5:\n                        continue\n                if status in (400, 404):\n                    return xuid, {}\n                r.raise_for_status()\n                j = r.json() if r.content else {}\n                state = j.get(\"state\") or j.get(\"presenceState\") or \"\"\n                title = _extract_title_from_presence(j)\n                return xuid, {\"state\": state, \"title\": title}\n            except Exception:\n                if tries < 3:\n                    time.sleep(delay)\n                    delay = min(delay * 1.6, 3.0)\n                    continue\n                return xuid, {}\n\n    done = 0\n    report_every = max(10, len(xuids)//15)  # ~15 updates max\n    with concurrent.futures.ThreadPoolExecutor(max_workers=max(1, min(workers, 48))) as ex:\n        for xuid, info in ex.map(fetch_one, xuids):\n            done += 1\n            if info:\n                result[str(xuid)] = info\n            if progress_cb and (done % report_every == 0 or done == len(xuids)):\n                progress_cb(done, len(xuids))\n\n    _log(\"presence fast collected:\", len(result))\n    try:\n        sess.close()\n    except Exception:\n        pass\n    return result\n\n\ndef main():\n    _log(\"Starting Xbox Friends Dock (INLINE v5)\")\n    app = QtWidgets.QApplication(sys.argv)\n    w = FriendsDock(); w.show()\n    rc = app.exec()\n    _log(\"App exit code:\", rc); sys.exit(rc)\n\nif __name__ == \"__main__\":\n    main()", "xbl_friends_dock_INLINE_v5_REFRESH_UI_v2_PATCHED.py")

# === BEGIN ADD-ONLY: background worker for non-blocking Steam validation ===
from PyQt6 import QtCore
class _NONUWP_Worker_Validate(QtCore.QThread):
    done = QtCore.pyqtSignal(object, object)  # (result, error)

    def __init__(self, parent, call_noarg, call_with_appid, call_legacy_noarg, call_legacy_with_appid, appid):
        super().__init__(parent)
        self._call_noarg = call_noarg
        self._call_with_appid = call_with_appid
        self._call_legacy_noarg = call_legacy_noarg
        self._call_legacy_with_appid = call_legacy_with_appid
        self._appid = appid

    def run(self):
        try:
            # 1) try auto-detect (no args)
            if self._call_noarg:
                try:
                    res = self._call_noarg()
                    self.done.emit(res, None); return
                except TypeError as te:
                    # only fall through on missing appid / positional complaint
                    if ("appid" not in str(te)) and ("positional" not in str(te)):
                        self.done.emit(None, te); return
                except Exception as e:
                    self.done.emit(None, e); return

            # 2) try with appid (if we have one)
            if self._appid is not None and self._call_with_appid:
                try:
                    res = self._call_with_appid(self._appid)
                    self.done.emit(res, None); return
                except Exception as e:
                    # keep trying legacy
                    pass

            # 3) try legacy name (no args)
            if self._call_legacy_noarg:
                try:
                    res = self._call_legacy_noarg()
                    self.done.emit(res, None); return
                except Exception:
                    pass

            # 4) legacy with appid
            if self._appid is not None and self._call_legacy_with_appid:
                try:
                    res = self._call_legacy_with_appid(self._appid)
                    self.done.emit(res, None); return
                except Exception as e:
                    self.done.emit(None, e); return

            self.done.emit(None, RuntimeError("Validation function not found or failed."))
        except Exception as e:
            self.done.emit(None, e)
# === END ADD-ONLY ===


_register_module("xbl.xbl_friends_dock_INLINE_v5_REFRESH_UI_v2_PATCHED", "\nfrom __future__ import annotations\n\n\n# === BEGIN XBL INLINE LOADER PATCH (no subprocess, works in one-file EXE) ===\nimport sys, os\nfrom pathlib import Path\nimport importlib.util\n\ndef _exe_dir() -> Path:\n    try:\n        return Path(sys.executable).parent\n    except Exception:\n        return Path.cwd()\n\ndef _ensure_exe_dir_on_syspath():\n    p = str(_exe_dir())\n    if p not in sys.path:\n        sys.path.insert(0, p)\n\ndef _load_helper_module_from_path(helper_path: Path):\n    \"\"\"Load a .py module from disk in-process (even when frozen).\"\"\"\n    try:\n        spec = importlib.util.spec_from_file_location(\"xbl_login_standalone_v3_dyn\", str(helper_path))\n        if not spec or not spec.loader:\n            return None\n        mod = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(mod)\n        return mod\n    except Exception:\n        return None\n\ndef _run_xbl_helper_inline(parent=None) -> bool:\n    \"\"\"\n    Order:\n      1) ENV XBL_HELPER_DIR\n      2) import from xbl package (with exe_dir on sys.path)\n      3) load from file: exe_dir/xbl, _MEIPASS/xbl, cwd/xbl\n    \"\"\"\n    helper_file = \"xbl_login_standalone_v3.py\"\n\n    # 0) ENV override\n    env_dir = os.environ.get(\"XBL_HELPER_DIR\")\n    if env_dir:\n        hp = Path(env_dir) / helper_file\n        if hp.exists():\n            mod = _load_helper_module_from_path(hp)\n            if mod and hasattr(mod, \"main\"):\n                try: mod.main()\n                except SystemExit: pass\n                return True\n\n    # 1) Import as package from sibling xbl/\n    try:\n        _ensure_exe_dir_on_syspath()\n        from xbl import xbl_login_standalone_v3 as _m\n        try: _m.main()\n        except SystemExit: pass\n        return True\n    except Exception:\n        pass\n\n    # 2) Load from common locations\n    candidates = [\n        _exe_dir() / \"xbl\" / helper_file,              # next to EXE\n        Path(getattr(sys, \"_MEIPASS\", _exe_dir())) / \"xbl\" / helper_file if getattr(sys, \"frozen\", False) else None,\n        Path.cwd() / \"xbl\" / helper_file,\n    ]\n    for hp in [c for c in candidates if c]:\n        if hp.exists():\n            mod = _load_helper_module_from_path(hp)\n            if mod and hasattr(mod, \"main\"):\n                try: mod.main()\n                except SystemExit: pass\n                return True\n\n    return False\n\n# Back-compat: if old code calls the legacy helper runner name, route it here\ntry:\n    _run_xbl_login_helper_from_xbl  # type: ignore[name-defined]\nexcept Exception:\n    def _run_xbl_login_helper_from_xbl(parent=None):  # legacy name\n        return _run_xbl_helper_inline(parent)\n# === END XBL INLINE LOADER PATCH ===\n\nimport os, sys, json, time, threading, datetime\nfrom typing import Dict, List, Optional\nfrom pathlib import Path\n\nimport requests\nimport subprocess\nfrom PyQt6 import QtWidgets, QtCore\n\nLOG_FILE = os.environ.get(\"XBL_LOG_FILE\")\n\ndef _log(*a):\n    s = \"[xbl_friends_dock] \" + \" \".join(str(x) for x in a)\n    print(s, flush=True)\n    if LOG_FILE:\n        try:\n            Path(LOG_FILE).parent.mkdir(parents=True, exist_ok=True)\n            with open(LOG_FILE, \"a\", encoding=\"utf-8\") as f:\n                f.write(f\"{datetime.datetime.now().isoformat()} {s}\\n\")\n        except Exception:\n            pass\n\n# ---------- AUTH ----------\nXBL_USER_AUTH = \"https://user.auth.xboxlive.com/user/authenticate\"\nXBL_XSTS_AUTH = \"https://xsts.auth.xboxlive.com/xsts/authorize\"\n\ndef _strip_json_comments(s: str) -> str:\n    out = []; i=0; in_str=False; esc=False\n    while i < len(s):\n        ch = s[i]\n        if in_str:\n            out.append(ch)\n            if esc: esc=False\n            elif ch == '\\\\\\\\': esc=True\n            elif ch == '\"': in_str=False\n            i += 1; continue\n        if ch == '\"': in_str=True; out.append(ch); i += 1; continue\n        if ch == '/' and i+1 < len(s) and s[i+1] in ('/','*'):\n            if s[i+1] == '/':\n                j = s.find('\\\\n', i+2); \n                if j == -1: break\n                i = j + 1; continue\n            else:\n                j = s.find('*/', i+2)\n                if j == -1: break\n                i = j + 2; continue\n        out.append(ch); i += 1\n    return ''.join(out)\n\ndef _find_tokens_path() -> Optional[Path]:\n    env = os.environ.get(\"XBL_TOKENS_PATH\")\n    if env and Path(env).exists(): return Path(env)\n    here = Path(__file__).resolve().parent / \"tokens.json\"\n    if here.exists(): return here\n    cwd = Path(os.getcwd()) / \"tokens.json\"\n    if cwd.exists(): return cwd\n    local = Path(os.environ.get(\"LOCALAPPDATA\", Path.home())) / \"OpenXbox\" / \"xbox\" / \"tokens.json\"\n    if local.exists(): return local\n    return None\n\ndef _post_json(url: str, payload: dict) -> dict:\n    r = requests.post(url, headers={\"Content-Type\":\"application/json\",\"Accept\":\"application/json\",\"Accept-Language\":\"en-US\"}, json=payload, timeout=20)\n    _log(\"POST\", url, \"->\", r.status_code)\n    r.raise_for_status()\n    return r.json()\n\ndef _build_auth_from_tokens(tokens_path: Path) -> Dict[str,str]:\n    raw = tokens_path.read_text(encoding=\"utf-8\", errors=\"ignore\").strip()\n    try:\n        toks = json.loads(raw)\n    except Exception:\n        toks = json.loads(_strip_json_comments(raw))\n    at = toks.get(\"access_token\") or toks.get(\"AccessToken\") or toks.get(\"token\")\n    if not at:\n        raise RuntimeError(\"tokens.json missing access_token\")\n    # user token\n    user_req = {\n        \"RelyingParty\": \"http://auth.xboxlive.com\",\n        \"TokenType\": \"JWT\",\n        \"Properties\": {\n            \"AuthMethod\": \"RPS\",\n            \"SiteName\": \"user.auth.xboxlive.com\",\n            \"RpsTicket\": f\"d={at}\",\n        },\n    }\n    j = _post_json(XBL_USER_AUTH, user_req)\n    user_token = j[\"Token\"]\n    # xsts\n    xsts_req = {\n        \"RelyingParty\": \"http://xboxlive.com\",\n        \"TokenType\": \"JWT\",\n        \"Properties\": {\n            \"UserTokens\": [user_token],\n            \"SandboxId\": \"RETAIL\",\n        },\n    }\n    j2 = _post_json(XBL_XSTS_AUTH, xsts_req)\n    xsts = j2[\"Token\"]\n    uhs = j2[\"DisplayClaims\"][\"xui\"][0][\"uhs\"]\n    return {\n        \"Authorization\": f\"XBL3.0 x={uhs};{xsts}\",\n        \"Accept\": \"application/json\",\n        \"Accept-Language\": \"en-US\",\n    }\n\n# ---------- Service helpers ----------\ndef _request_json(url: str, headers: Dict, versions=(6,5,4,3,2,1), method=\"GET\", json=None, timeout=15):\n    last_exc = None\n    for ver in versions:\n        h = dict(headers); h[\"x-xbl-contract-version\"] = str(ver)\n        try:\n            if method == \"GET\":\n                r = requests.get(url, headers=h, timeout=timeout)\n            else:\n                r = requests.post(url, headers=h, json=json, timeout=timeout)\n            _log(f\"{method} {url} v{ver} ->\", r.status_code)\n            if r.status_code in (400,404):\n                continue\n            if r.status_code == 429:\n                time.sleep(0.5); continue\n            r.raise_for_status()\n            if r.content:\n                try: return r.json()\n                except Exception: return {}\n            return {}\n        except Exception as e:\n            last_exc = e\n    if last_exc: raise last_exc\n    return {}\n\ndef _me_xuid(headers: Dict) -> Optional[str]:\n    try:\n        data = _request_json(\"https://profile.xboxlive.com/users/me/profile/settings?settings=Gamertag\", headers, versions=(3,2,1))\n        pu = (data.get(\"profileUsers\") or [{}])[0]\n        return str(pu.get(\"id\") or \"\")\n    except Exception as e:\n        _log(\"xuid lookup failed:\", repr(e)); return None\n\ndef _fetch_friends(headers: Dict) -> List[Dict]:\n    urls = [\n        \"https://peoplehub.xboxlive.com/users/me/people/social\",\n        \"https://peoplehub.xboxlive.com/users/me/people\",\n        \"https://social.xboxlive.com/users/me/people\",\n    ]\n    me = _me_xuid(headers)\n    if me:\n        urls.insert(0, f\"https://peoplehub.xboxlive.com/users/xuid({me})/people/social\")\n        urls.insert(1, f\"https://peoplehub.xboxlive.com/users/xuid({me})/people/social/summary\")\n\n    for url in urls:\n        try:\n            data = _request_json(url, headers, versions=(6,5,4,3,2,1))\n            arr = data.get(\"people\") or data.get(\"peopleList\") or data.get(\"friends\") or data.get(\"summary\") or []\n            out = []\n            for p in arr or []:\n                x = str(p.get(\"xuid\") or p.get(\"xboxUserId\") or p.get(\"id\") or \"\")\n                g = p.get(\"gamertag\") or p.get(\"modernGamertag\") or p.get(\"preferredName\") or \"\"\n                out.append({\"xuid\": x, \"gamertag\": g})\n            if out:\n                _log(\"friends from\", url, \"->\", len(out))\n                return out\n        except Exception as e:\n            _log(\"friends error for\", url, \":\", repr(e))\n    return []\n\ndef _resolve_gamertags_batch(headers: Dict, xuids: List[str]) -> Dict[str,str]:\n    if not xuids: return {}\n    url = \"https://profile.xboxlive.com/users/batch/profile/settings\"\n    payload = {\"settings\": [\"Gamertag\"], \"userIds\": [f\"xuid({x})\" for x in xuids]}\n    try:\n        data = _request_json(url, headers, versions=(3,2,1), method=\"POST\", json=payload)\n        m = {}\n        for u in data.get(\"profileUsers\", []):\n            uid = str(u.get(\"id\") or \"\")\n            gt = \"\"\n            for s in u.get(\"settings\", []):\n                if s.get(\"id\") == \"Gamertag\":\n                    gt = s.get(\"value\") or \"\"\n            if uid and gt: m[uid] = gt\n        _log(\"resolved gamertags (batch):\", len(m))\n        return m\n    except Exception as e:\n        _log(\"resolve gt batch failed:\", repr(e)); return {}\n\ndef _resolve_gamertags_slow(headers: Dict, xuids: List[str]) -> Dict[str,str]:\n    out = {}\n    for x in xuids:\n        url = f\"https://profile.xboxlive.com/users/xuid({x})/profile/settings?settings=Gamertag\"\n        try:\n            data = _request_json(url, headers, versions=(3,2,1), method=\"GET\")\n            pu = (data.get(\"profileUsers\") or [{}])[0]\n            uid = str(pu.get(\"id\") or \"\")\n            gt = \"\"\n            for s in pu.get(\"settings\", []):\n                if s.get(\"id\") == \"Gamertag\": gt = s.get(\"value\") or \"\"\n            if uid and gt: out[uid] = gt\n        except Exception as e:\n            _log(\"resolve gt slow failed for\", x, \":\", repr(e))\n        time.sleep(0.05)\n    _log(\"resolved gamertags (slow):\", len(out))\n    return out\n\ndef _extract_title_from_presence(data: dict) -> str:\n    for d in data.get(\"devices\", []):\n        for t in d.get(\"titles\", []):\n            name = t.get(\"name\") or t.get(\"titleName\") or \"\"\n            act = t.get(\"activity\") or {}\n            if t.get(\"placement\") == \"Full\" or act.get(\"richPresence\") or act.get(\"broadcastTitle\"):\n                if name: return name\n    return \"\"\n\ndef _presence_batch(headers: Dict, xuids: List[str]) -> Dict[str, Dict]:\n    result = {}\n    try:\n        payload = {\"users\": [f\"xuid({x})\" for x in xuids], \"level\": \"all\"}\n        data = _request_json(\"https://presence.xboxlive.com/users/batch\", headers, versions=(3,2,1), method=\"POST\", json=payload)\n        users = data.get(\"responses\") or data.get(\"users\") or []\n        for u in users:\n            uid = u.get(\"id\") or u.get(\"xuid\") or \"\"\n            if isinstance(uid, str) and uid.startswith(\"xuid(\"): uid = uid[5:-1]\n            state = u.get(\"state\") or u.get(\"presenceState\") or \"\"\n            title = _extract_title_from_presence(u)\n            if uid: result[str(uid)] = {\"state\": state, \"title\": title}\n        if result:\n            _log(\"presence batch OK:\", len(result))\n            return result\n    except Exception as e:\n        _log(\"presence batch failed:\", repr(e))\n    return {}\n\ndef _presence_slow(headers: Dict, xuids: List[str], progress_cb=None) -> Dict[str, Dict]:\n    result = {}\n    for i, x in enumerate(xuids, 1):\n        url = f\"https://userpresence.xboxlive.com/users/xuid({x})?level=all\"\n        try:\n            data = _request_json(url, headers, versions=(3,2,1), method=\"GET\")\n            state = data.get(\"state\") or data.get(\"presenceState\") or \"\"\n            title = _extract_title_from_presence(data)\n            result[str(x)] = {\"state\": state, \"title\": title}\n            if progress_cb and (i % 10 == 0 or i == len(xuids)):\n                progress_cb(i, len(xuids))\n        except Exception as e:\n            _log(\"presence slow failed for\", x, \":\", repr(e))\n        time.sleep(0.045)\n    _log(\"presence slow collected:\", len(result))\n    return result\n\n# ---------- UI (filterable) ----------\n\nclass TransparencyDialog(QtWidgets.QDialog):\n    def __init__(self, dock: QtWidgets.QWidget):\n        super().__init__(dock)\n        self._dock = dock\n        self.setWindowTitle(\"Transparency\")\n        self.setModal(False)\n        self.resize(320, 100)\n\n        v = QtWidgets.QVBoxLayout(self)\n        self.label = QtWidgets.QLabel(self)\n        self.slider = QtWidgets.QSlider(QtCore.Qt.Orientation.Horizontal, self)\n        self.slider.setMinimum(20)   # 20% minimum to avoid disappearing\n        self.slider.setMaximum(100)  # 100% = opaque\n        # initialize from current window opacity\n        current = int(round((dock.windowOpacity() or 1.0) * 100))\n        current = max(self.slider.minimum(), min(self.slider.maximum(), current))\n        self.slider.setValue(current)\n        self._update_label(current)\n\n        self.slider.valueChanged.connect(self._on_change)\n\n        btn_row = QtWidgets.QHBoxLayout()\n        self.btnReset = QtWidgets.QPushButton(\"Reset\")\n        self.btnClose = QtWidgets.QPushButton(\"Close\")\n        btn_row.addStretch(1)\n        btn_row.addWidget(self.btnReset)\n        btn_row.addWidget(self.btnClose)\n\n        v.addWidget(self.label)\n        v.addWidget(self.slider)\n        v.addLayout(btn_row)\n\n        self.btnReset.clicked.connect(self._reset)\n        self.btnClose.clicked.connect(self.close)\n\n    def _update_label(self, val: int):\n        self.label.setText(f\"Opacity: {val}%\")\n\n    def _on_change(self, val: int):\n        try:\n            self._dock.setWindowOpacity(val / 100.0)\n            self._update_label(val)\n            try:\n                self._dock._save_settings(opacity_percent=int(val))\n            except Exception as _e:\n                _log(\"settings write warn:\", repr(_e))\n        except Exception as e:\n            _log(\"opacity change error:\", repr(e))\n\n    def _reset(self):\n        self.slider.setValue(100)\n        try:\n            self._dock._save_settings(opacity_percent=100)\n        except Exception as _e:\n            _log(\"settings write warn:\", repr(_e))\n\nclass FriendsDock(QtWidgets.QDialog):\n\n    # --- Cache helpers (ADD-ONLY) ---\n    # --- Settings helpers (ADD-ONLY) ---\n    def _settings_path(self) -> Path:\n        try:\n            return Path(__file__).resolve().parent / \"friends_settings.json\"\n        except Exception:\n            return Path(\"friends_settings.json\")\n\n    def _load_settings(self) -> dict:\n        try:\n            p = self._settings_path()\n            if not p.exists():\n                return {}\n            raw = p.read_text(encoding=\"utf-8\", errors=\"ignore\")\n            return json.loads(raw) if raw.strip() else {}\n        except Exception as e:\n            _log(\"settings load error:\", repr(e))\n            return {}\n\n    def _save_settings(self, **updates):\n        try:\n            data = self._load_settings()\n            data.update(updates)\n            self._settings_path().write_text(json.dumps(data, ensure_ascii=False, indent=0), encoding=\"utf-8\")\n            _log(\"settings saved:\", updates)\n        except Exception as e:\n            _log(\"settings save error:\", repr(e))\n    # --- end settings helpers ---\n\n    def _cache_path(self) -> Path:\n        try:\n            return Path(__file__).resolve().parent / \"friends_cache.json\"\n        except Exception:\n            return Path(\"friends_cache.json\")\n\n    def _save_cached_rows(self, rows):\n        try:\n            data = [{\"gamertag\": gt, \"status\": st, \"game\": gm} for (gt, st, gm) in (rows or [])]\n            self._cache_path().write_text(json.dumps(data, ensure_ascii=False, indent=0), encoding=\"utf-8\")\n            _log(\"cache saved:\", str(self._cache_path()), len(data), \"rows\")\n        except Exception as e:\n            _log(\"cache save error:\", repr(e))\n\n    def _load_cached_rows(self):\n        try:\n            p = self._cache_path()\n            if not p.exists():\n                return False\n            raw = p.read_text(encoding=\"utf-8\", errors=\"ignore\")\n            arr = json.loads(raw) if raw.strip() else []\n            rows = [(d.get(\"gamertag\",\"\"), d.get(\"status\",\"\"), d.get(\"game\",\"\")) for d in arr]\n            if rows:\n                self.sig_set_rows.emit(rows)\n                self.sig_set_status.emit(f\"Restored {len(rows)} cached friends\")\n                _log(\"cache restored:\", len(rows), \"rows\")\n                return True\n            return False\n        except Exception as e:\n            _log(\"cache load error:\", repr(e))\n            return False\n    # --- end cache helpers ---\n\n    sig_set_status = QtCore.pyqtSignal(str)\n    sig_set_rows = QtCore.pyqtSignal(list)   # list of (gt, status, game)\n    sig_enable_btn = QtCore.pyqtSignal(bool)\n    sig_busy = QtCore.pyqtSignal(bool)\n\n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self.setWindowTitle(\"Xbox Friends\")\n        self.resize(720, 740)\n        # Enable minimize button on title bar\n        try:\n            self.setWindowFlags(self.windowFlags() |\n                                QtCore.Qt.WindowType.WindowMinimizeButtonHint |\n                                QtCore.Qt.WindowType.WindowSystemMenuHint)\n        except Exception as _e:\n            _log(\"minimize flag warn:\", repr(_e))\n        self._full_rows: List[tuple] = []\n\n        v = QtWidgets.QVBoxLayout(self)\n        top = QtWidgets.QHBoxLayout()\n        self.lbl = QtWidgets.QLabel(\"Ready.\")\n        self.view = QtWidgets.QComboBox()\n        self.view.addItems([\"All (Online first)\", \"Online only\"])\n        self.btn = QtWidgets.QPushButton(\"Refresh\")\n        top.addWidget(self.lbl); top.addStretch(1); top.addWidget(QtWidgets.QLabel(\"View:\")); top.addWidget(self.view)\n        # \"Always on top\" toggle (ADD-ONLY)\n        self.chkAlwaysOnTop = QtWidgets.QCheckBox(\"Always on top\")\n        top.addWidget(self.chkAlwaysOnTop)\n        # Busy spinner (indeterminate) \u2014 hidden by default\n        self._busy = QtWidgets.QProgressBar(self)\n        self._busy.setRange(0, 0)\n        self._busy.setTextVisible(False)\n        self._busy.setFixedWidth(80)\n        self._busy.hide()\n        top.insertWidget(1, self._busy)\n        # Auto-refresh timer (1 minute; OFF by default)\n        self._autoRefreshTimer = QtCore.QTimer(self)\n        self._autoRefreshTimer.setInterval(60_000)\n        self._autoRefreshTimer.timeout.connect(self.refresh)\n        self.btnAuth = QtWidgets.QPushButton(\"Sign in / Choose tokens.json\")\n        self.btnRefreshTokenOnly = QtWidgets.QPushButton(\"Refresh token only\")\n        top.addWidget(self.btnAuth); top.addWidget(self.btnRefreshTokenOnly); top.addWidget(self.btn)\n\n        # ---- Settings dropdown (cosmetic only) ----\n        # ---- Settings dropdown (cosmetic only) ----\n        self.btnSettings = QtWidgets.QToolButton()\n        self.btnSettings.setText(\"Settings\")\n        self.btnSettings.setPopupMode(QtWidgets.QToolButton.ToolButtonPopupMode.InstantPopup)\n        _menu = QtWidgets.QMenu(self.btnSettings)\n        _a_refresh = _menu.addAction(\"Refresh\"); _a_refresh.triggered.connect(self.refresh)\n        _a_signin  = _menu.addAction(\"Sign in / Choose tokens.json\"); _a_signin.triggered.connect(self._do_auth)\n        _a_rtonly  = _menu.addAction(\"Refresh token only\"); _a_rtonly.triggered.connect(self._refresh_token_only)\n        _a_transp  = _menu.addAction(\"Transparency\u2026\"); _a_transp.triggered.connect(self._open_transparency)\n        self._autoAction = _menu.addAction(\"Auto Refresh (1 minute)\")\n        self._autoAction.setCheckable(True)\n        self._autoAction.setChecked(False)\n        self._autoAction.triggered.connect(self._toggle_auto_refresh)\n        self.btnSettings.setMenu(_menu)\n        top.addWidget(self.btnSettings)\n        try:\n            self.btn.hide(); self.btnAuth.hide(); self.btnRefreshTokenOnly.hide()\n        except Exception:\n            pass\n        # ---- end Settings dropdown ----\n\n        # Hide original buttons (objects remain; signals intact)\n        try:\n            self.btn.hide()\n            self.btnAuth.hide()\n            self.btnRefreshTokenOnly.hide()\n        except Exception as _e:\n            _log(\"hide-buttons warning:\", repr(_e))\n        # ---- end Settings dropdown ----\n\n        v.addLayout(top)\n\n        self.table = QtWidgets.QTableWidget(0, 3)\n        self.table.setHorizontalHeaderLabels([\"Gamertag\", \"Status\", \"Game\"])\n        self.table.horizontalHeader().setStretchLastSection(True)\n        self.table.setEditTriggers(QtWidgets.QAbstractItemView.EditTrigger.NoEditTriggers)\n        v.addWidget(self.table, 1)\n\n        self.btn.clicked.connect(self.refresh)\n        self.btnAuth.clicked.connect(self._do_auth)\n        self.btnRefreshTokenOnly.clicked.connect(self._refresh_token_only)\n        self.view.currentIndexChanged.connect(self._reapply_filter)\n        self.view.currentIndexChanged.connect(lambda _i: self._save_settings(view_index=int(_i)))\n        self.chkAlwaysOnTop.toggled.connect(self._apply_always_on_top)\n\n        self.sig_set_status.connect(self._set_status)\n        self.sig_set_rows.connect(self._receive_full_rows)\n        self.sig_enable_btn.connect(self.btn.setEnabled)\n        self.sig_busy.connect(self._busy.setVisible)\n\n        # Load and apply persistent settings (opacity, auto-refresh)\n        try:\n            _s = self._load_settings()\n            # Apply opacity\n            _op = int(_s.get(\"opacity_percent\", 100))\n            _op = max(20, min(100, _op))\n            self.setWindowOpacity(_op / 100.0)\n            # Apply auto-refresh state\n            _auto = bool(_s.get(\"auto_refresh\", False))\n            if hasattr(self, \"_autoAction\"):\n                self._autoAction.setChecked(_auto)\n            if _auto:\n                self._autoRefreshTimer.start()\n            # Apply view filter index\n            try:\n                _vi = int(_s.get(\"view_index\", 0))\n                if 0 <= _vi < self.view.count():\n                    self.view.setCurrentIndex(_vi)\n            except Exception:\n                pass\n            # Apply 'Always on top'\n            _aot = bool(_s.get(\"always_on_top\", False))\n            if hasattr(self, 'chkAlwaysOnTop'):\n                self.chkAlwaysOnTop.setChecked(_aot)\n            self.setWindowFlag(QtCore.Qt.WindowType.WindowStaysOnTopHint, _aot)\n            self.show()\n        except Exception as _e:\n            _log(\"apply settings warn:\", repr(_e))\n\n        # Show cached rows immediately (if available) before first refresh\n        try:\n            _had_cache = self._load_cached_rows()\n        except Exception as _e:\n            _had_cache = False\n            _log(\"warm restore warn:\", repr(_e))\n        if not _had_cache:\n            QtCore.QTimer.singleShot(150, self.refresh)\n\n    def _set_status(self, s: str):\n        self.lbl.setText(s); _log(\"status:\", s)\n\n    def _receive_full_rows(self, rows: List[tuple]):\n        # rows already have \"Online first\" order\n        self._full_rows = rows\n        self._reapply_filter()\n\n    def _reapply_filter(self):\n        rows = self._full_rows\n        if self.view.currentIndex() == 1:  # Online only\n            rows = [r for r in rows if r[1] == \"Online\"]\n        self._apply_rows(rows)\n\n\n    # --- Status LED helpers (ADD-ONLY) ---\n    def _build_led_icon(self, color: QtCore.Qt.GlobalColor) -> QtWidgets.QStyle.StandardPixmap | QtWidgets.QStyle:\n        # Create a small circular pixmap to act as an LED\n        pm = QtGui.QPixmap(14, 14)\n        pm.fill(QtCore.Qt.GlobalColor.transparent)\n        painter = QtGui.QPainter(pm)\n        painter.setRenderHint(QtGui.QPainter.RenderHint.Antialiasing, True)\n        brush = QtGui.QBrush(color)\n        pen = QtGui.QPen(QtCore.Qt.GlobalColor.black)\n        pen.setWidth(1)\n        painter.setPen(pen)\n        painter.setBrush(brush)\n        painter.drawEllipse(1, 1, 12, 12)\n        painter.end()\n        return QtGui.QIcon(pm)\n\n    def _icon_for_state(self, st: str) -> QtGui.QIcon:\n        try:\n            if not hasattr(self, \"_led_green\"):\n                self._led_green = self._build_led_icon(QtCore.Qt.GlobalColor.green)\n                self._led_red   = self._build_led_icon(QtCore.Qt.GlobalColor.red)\n                self._led_blank = self._build_led_icon(QtCore.Qt.GlobalColor.gray)\n        except Exception:\n            pass\n        s = (st or \"\").strip().lower()\n        if s == \"online\":\n            return getattr(self, \"_led_green\", QtWidgets.QApplication.style().standardIcon(QtWidgets.QStyle.StandardPixmap.SP_DialogApplyButton))\n        elif s == \"offline\":\n            return getattr(self, \"_led_red\", QtWidgets.QApplication.style().standardIcon(QtWidgets.QStyle.StandardPixmap.SP_DialogCancelButton))\n        return getattr(self, \"_led_blank\", QtWidgets.QApplication.style().standardIcon(QtWidgets.QStyle.StandardPixmap.SP_MessageBoxInformation))\n    # --- end Status LED helpers ---\n\n    def _apply_rows(self, rows: List[tuple]):\n        self.table.setSortingEnabled(False)\n        self.table.setRowCount(len(rows))\n        for i,(gt,st,gm) in enumerate(rows):\n            # Gamertag text\n            self.table.setItem(i,0, QtWidgets.QTableWidgetItem(gt))\n            # Status LED (icon only)\n            _status_item = QtWidgets.QTableWidgetItem(\"\")\n            try:\n                _status_item.setIcon(self._icon_for_state(st))\n                _status_item.setText(\"\")  # no text, icon only\n                _status_item.setTextAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)\n            except Exception:\n                _status_item.setText(st)\n            self.table.setItem(i,1, _status_item)\n            # Game text\n            self.table.setItem(i,2, QtWidgets.QTableWidgetItem(gm))\n        self.table.setSortingEnabled(True)\n        # Keep consistent order: Online first (already), within that alphabetically\n        self.table.sortItems(1, QtCore.Qt.SortOrder.AscendingOrder)\n\n\n    def _apply_always_on_top(self, checked: bool):\n        try:\n            self.setWindowFlag(QtCore.Qt.WindowType.WindowStaysOnTopHint, bool(checked))\n            self.show()  # re-apply flags\n            try:\n                self._save_settings(always_on_top=bool(checked))\n            except Exception as _e:\n                _log(\"settings write warn:\", repr(_e))\n        except Exception as e:\n            _log(\"always on top apply error:\", repr(e))\n\n    def _open_transparency(self):\n        try:\n            if not hasattr(self, \"_transparencyDlg\") or self._transparencyDlg is None:\n                self._transparencyDlg = TransparencyDialog(self)\n            self._transparencyDlg.show()\n            self._transparencyDlg.raise_()\n            self._transparencyDlg.activateWindow()\n        except Exception as e:\n            QtWidgets.QMessageBox.critical(self, \"Error\", f\"Transparency error: {e}\")\n\n    def _refresh_token_only(self):\n        \"\"\"\n        Run xbl_login_standalone_v3.py to refresh tokens, then prompt where the new token was saved.\n        \"\"\"\n        try:\n            self.sig_enable_btn.emit(False)\n            self.sig_set_status.emit(\"Refreshing token via login helper...\")\n\n            base = Path(__file__).resolve().parent\n            helper = base / \"xbl_login_standalone_v3.py\"\n            if not helper.exists():\n                QtWidgets.QMessageBox.critical(self, \"Missing helper\", \"xbl_login_standalone_v3.py not found next to this script.\")\n                self.sig_enable_btn.emit(True)\n                return\n\n            proc = subprocess.run([sys.executable, str(helper)], cwd=str(base), capture_output=True, text=True)\n            out = (proc.stdout or \"\") + \"\\n\" + (proc.stderr or \"\")\n            if proc.returncode != 0:\n                QtWidgets.QMessageBox.critical(self, \"Refresh failed\", f\"Helper exited with {proc.returncode}.\\n\\nOutput (tail):\\n{out[-2000:]}\")\n                self.sig_enable_btn.emit(True)\n                return\n\n            # Parse output to find the saved tokens file\n            tokens_path = None\n            for line in out.splitlines():\n                s = line.strip()\n                if s.startswith(\"[Info] Tokens file:\"):\n                    tokens_path = s.split(\":\", 1)[1].strip()\n                    break\n            if not tokens_path:\n                # Fallback to typical default\n                tokens_path = str(Path(os.environ.get(\"LOCALAPPDATA\", Path.home())) / \"OpenXbox\" / \"xbox\" / \"tokens.json\")\n\n            # Prompt user where it was saved and offer to use it now\n            msg = QtWidgets.QMessageBox(self)\n            msg.setIcon(QtWidgets.QMessageBox.Icon.Information)\n            msg.setWindowTitle(\"Token refreshed\")\n            msg.setText(f\"New tokens were saved here:\\n{tokens_path}\\n\\nUse this tokens.json now?\")\n            yes_btn = msg.addButton(\"Use now\", QtWidgets.QMessageBox.ButtonRole.AcceptRole)\n            no_btn = msg.addButton(\"Cancel\", QtWidgets.QMessageBox.ButtonRole.RejectRole)\n            msg.exec()\n            if msg.clickedButton() is yes_btn:\n                os.environ[\"XBL_TOKENS_PATH\"] = tokens_path\n                self.sig_set_status.emit(\"Using refreshed tokens. Reloading\u2026\")\n                QtCore.QTimer.singleShot(200, self.refresh)\n            else:\n                self.sig_enable_btn.emit(True)\n\n        except Exception as e:\n            QtWidgets.QMessageBox.critical(self, \"Error\", str(e))\n            self.sig_enable_btn.emit(True)\n\n    def _do_auth(self):\n        \"\"\"\n        Opens a small chooser:\n        - Use existing tokens.json (browse & load)\n        - Run device sign-in helper to create a new tokens.json\n        \"\"\"\n        try:\n            default_path = os.environ.get(\"XBL_TOKENS_PATH\") or str((Path.cwd() / \"tokens.json\"))\n            # Simple chooser via QMessageBox-style buttons\n            dlg = QtWidgets.QMessageBox(self)\n            dlg.setIcon(QtWidgets.QMessageBox.Icon.Question)\n            dlg.setWindowTitle(\"Xbox sign-in / tokens.json\")\n            dlg.setText(\"How would you like to provide tokens?\")\n            use_existing = dlg.addButton(\"Use existing tokens.json\u2026\", QtWidgets.QMessageBox.ButtonRole.AcceptRole)\n            run_helper  = dlg.addButton(\"Run device sign-in\u2026\", QtWidgets.QMessageBox.ButtonRole.ActionRole)\n            cancel_btn  = dlg.addButton(\"Cancel\", QtWidgets.QMessageBox.ButtonRole.RejectRole)\n            # PyQt6: exec()\n            dlg.exec()\n            clicked = dlg.clickedButton()\n            if clicked is cancel_btn:\n                return\n\n            if clicked is use_existing:\n                path, _ = QtWidgets.QFileDialog.getOpenFileName(\n                    self, \"Select tokens.json\", default_path, \"JSON Files (*.json);;All Files (*)\"\n                )\n                if not path:\n                    return\n                # point the app to this file and refresh\n                os.environ[\"XBL_TOKENS_PATH\"] = path\n                self.sig_set_status.emit(\"Using selected tokens.json. Reloading\u2026\")\n                QtCore.QTimer.singleShot(200, self.refresh)\n                return\n\n            # Otherwise run helper to produce a new tokens.json\n            save_path, _ = QtWidgets.QFileDialog.getSaveFileName(\n                self, \"Save tokens.json\", default_path, \"JSON Files (*.json);;All Files (*)\"\n            )\n            if not save_path:\n                return\n\n            self.sig_enable_btn.emit(False)\n            self.sig_set_status.emit(\"Starting device sign-in\u2026 follow the console/device code flow\")\n\n            base = Path(__file__).resolve().parent\n            helper = None\n            for name in [\"xbl_auth_device_any.py\", \"xbl_login_standalone_v3.py\", \"xbl_signin_from_oauth_tokens.py\"]:\n                cand = base / name\n                if cand.exists():\n                    helper = str(cand)\n                    break\n            if helper is None:\n                QtWidgets.QMessageBox.critical(\n                    self, \"Missing helper\",\n                    \"Could not find a sign-in helper (xbl_auth_device_any.py or xbl_login_standalone_v3.py).\"\n                )\n                self.sig_enable_btn.emit(True)\n                return\n\n            import subprocess, sys\n            proc = subprocess.run([sys.executable, helper, \"--out\", save_path], cwd=str(base))\n            if proc.returncode != 0:\n                QtWidgets.QMessageBox.critical(self, \"Sign-in failed\", f\"Auth helper exited with code {proc.returncode}.\")\n                self.sig_enable_btn.emit(True)\n                return\n\n            os.environ[\"XBL_TOKENS_PATH\"] = save_path\n            self.sig_set_status.emit(\"Token saved. Reloading\u2026\")\n            QtCore.QTimer.singleShot(200, self.refresh)\n\n        except Exception as e:\n            QtWidgets.QMessageBox.critical(self, \"Error\", str(e))\n            self.sig_enable_btn.emit(True)\n\n\n    def _toggle_auto_refresh(self):\n        try:\n            if self._autoRefreshTimer.isActive():\n                self._autoRefreshTimer.stop()\n                if hasattr(self, '_autoAction') and self._autoAction:\n                    self._autoAction.setChecked(False)\n                self.sig_set_status.emit(\"Auto Refresh: OFF\")\n                try:\n                    self._save_settings(auto_refresh=False)\n                except Exception as _e:\n                    _log(\"settings write warn:\", repr(_e))\n            else:\n                self._autoRefreshTimer.start()\n                if hasattr(self, '_autoAction') and self._autoAction:\n                    self._autoAction.setChecked(True)\n                self.sig_set_status.emit(\"Auto Refresh: ON (every 1 min)\")\n                try:\n                    self._save_settings(auto_refresh=True)\n                except Exception as _e:\n                    _log(\"settings write warn:\", repr(_e))\n        except Exception as e:\n            QtWidgets.QMessageBox.critical(self, \"Auto Refresh Error\", str(e))\n\n    def refresh(self):\n        self.sig_enable_btn.emit(False); self.sig_set_status.emit(\"\"); self.sig_busy.emit(True); self.sig_set_rows.emit([])\n\n        def _run():\n            try:\n                # ----- auth\n                tpath = _find_tokens_path()\n                if not tpath:\n                    raise RuntimeError(\"tokens.json not found. Set XBL_TOKENS_PATH or place tokens.json next to the script.\")\n                _log(\"Using tokens.json at:\", str(tpath))\n                headers = _build_auth_from_tokens(tpath)\n\n                # ----- friends list\n                friends = _fetch_friends(headers)\n                if not friends:\n                    raise RuntimeError(\"No friends returned (service/permissions).\")\n\n                self.sig_set_status.emit(f\"{len(friends)} friends (resolving names...)\")\n\n                # ----- gamertags\n                missing = [f[\"xuid\"] for f in friends if f.get(\"xuid\") and not f.get(\"gamertag\")]\n                gmap = _resolve_gamertags_batch(headers, missing) if missing else {}\n                if missing and len(gmap) < len(missing):\n                    slow_needed = [x for x in missing if x not in gmap]\n                    if slow_needed:\n                        gmap.update(_resolve_gamertags_slow(headers, slow_needed))\n                for f in friends:\n                    if not f.get(\"gamertag\"):\n                        f[\"gamertag\"] = gmap.get(f.get(\"xuid\",\"\"), f.get(\"xuid\",\"\"))\n\n                self.sig_set_status.emit(f\"{len(friends)} friends (loading presence...)\")\n\n                # ----- presence\n                xuids = [f[\"xuid\"] for f in friends if f.get(\"xuid\")]\n                pres = _presence_batch(headers, xuids) if xuids else {}\n                if xuids and len(pres) < len(xuids):\n                    def _progress(i, n):\n                        self.sig_set_status.emit(f\"{len(friends)} friends (presence {i}/{n})\")\n                    pres.update(_presence_fast(headers, [x for x in xuids if x not in pres], _progress, workers=24))\n\n                rows = []\n                for f in friends:\n                    x = f.get(\"xuid\",\"\"); gt = f.get(\"gamertag\") or x\n                    p = pres.get(x, {})\n                    state = \"Online\" if str(p.get(\"state\",\"\")).lower()==\"online\" else (\"Offline\" if p else \"\")\n                    title = p.get(\"title\",\"\")\n                    rows.append((gt, state, title))\n                rows.sort(key=lambda r: (r[1]!=\"Online\", r[0].lower()))\n\n                self.sig_set_rows.emit(rows)\n                try:\n                    self._save_cached_rows(rows)\n                except Exception as _e:\n                    _log(\"cache post-refresh warn:\", repr(_e))\n                self.sig_set_status.emit(f\"{len(rows)} friends (presence applied)\")\n                self.sig_busy.emit(False)\n                self.sig_enable_btn.emit(True)\n\n            except Exception as e:\n                _log(\"Error:\", repr(e))\n                self.sig_set_status.emit(f\"Error: {e.__class__.__name__}: {e}\")\n                self.sig_busy.emit(False)\n                self.sig_enable_btn.emit(True)\n\n        threading.Thread(target=_run, daemon=True).start()\ndef _presence_fast(headers: Dict, xuids: List[str], progress_cb=None, workers: int = 24) -> Dict[str, Dict]:\n    \"\"\"Concurrent presence fetch using a shared Session. Keeps requests gentle but parallel.\"\"\"\n    import concurrent.futures, time, math\n    result = {}\n    if not xuids:\n        return result\n\n    # Shared session with connection pool\n    sess = requests.Session()\n    try:\n        from requests.adapters import HTTPAdapter\n        from urllib3.util.retry import Retry\n        adapter = HTTPAdapter(pool_connections=workers*2, pool_maxsize=workers*2, max_retries=0)\n        sess.mount(\"https://\", adapter); sess.mount(\"http://\", adapter)\n    except Exception:\n        pass\n\n    base_headers = dict(headers)\n    base_headers[\"x-xbl-contract-version\"] = \"3\"\n    url_tpl = \"https://userpresence.xboxlive.com/users/xuid({})?level=all\"\n\n    # Gentle concurrency: cap workers, backoff on 429, shorter timeout\n    def fetch_one(xuid: str):\n        url = url_tpl.format(xuid)\n        tries = 0\n        delay = 0.3\n        while True:\n            tries += 1\n            try:\n                r = sess.get(url, headers=base_headers, timeout=8)\n                status = r.status_code\n                if status == 429:\n                    # Too many requests; back off a bit and retry\n                    time.sleep(delay)\n                    delay = min(delay * 1.6, 3.0)\n                    if tries < 5:\n                        continue\n                if status in (400, 404):\n                    return xuid, {}\n                r.raise_for_status()\n                j = r.json() if r.content else {}\n                state = j.get(\"state\") or j.get(\"presenceState\") or \"\"\n                title = _extract_title_from_presence(j)\n                return xuid, {\"state\": state, \"title\": title}\n            except Exception:\n                if tries < 3:\n                    time.sleep(delay)\n                    delay = min(delay * 1.6, 3.0)\n                    continue\n                return xuid, {}\n\n    done = 0\n    report_every = max(10, len(xuids)//15)  # ~15 updates max\n    with concurrent.futures.ThreadPoolExecutor(max_workers=max(1, min(workers, 48))) as ex:\n        for xuid, info in ex.map(fetch_one, xuids):\n            done += 1\n            if info:\n                result[str(xuid)] = info\n            if progress_cb and (done % report_every == 0 or done == len(xuids)):\n                progress_cb(done, len(xuids))\n\n    _log(\"presence fast collected:\", len(result))\n    try:\n        sess.close()\n    except Exception:\n        pass\n    return result\n\n\ndef main():\n    _log(\"Starting Xbox Friends Dock (INLINE v5)\")\n    app = QtWidgets.QApplication(sys.argv)\n    w = FriendsDock(); w.show()\n    rc = app.exec()\n    _log(\"App exit code:\", rc); sys.exit(rc)\n\nif __name__ == \"__main__\":\n    main()", "xbl/xbl_friends_dock_INLINE_v5_REFRESH_UI_v2_PATCHED.py")
_register_module("xbl_login_standalone_v3", "\n# xbl_login_standalone_v3.py \u2014 Sign in to Xbox Live and save tokens\n# Usage: py xbl_login_standalone_v3.py\nimport os, sys, asyncio, urllib.parse as up\n\nfrom pythonxbox.authentication.manager import AuthenticationManager\nfrom pythonxbox.authentication.models import OAuth2TokenResponse\nfrom pythonxbox.common.signed_session import SignedSession\n\nDESKTOP_REDIRECT = \"https://login.live.com/oauth20_desktop.srf\"\n\ndef _tokens_path() -> str:\n    try:\n        from platformdirs import user_data_dir\n        base = user_data_dir(appname=\"xbox\", appauthor=\"OpenXbox\", roaming=False)\n    except Exception:\n        base = os.path.join(os.environ.get(\"LOCALAPPDATA\", os.path.expanduser(\"~\")), \"OpenXbox\", \"xbox\")\n    os.makedirs(base, exist_ok=True)\n    return os.path.join(base, \"tokens.json\")\n\ndef _client_constants():\n    try:\n        from pythonxbox.scripts import CLIENT_ID, CLIENT_SECRET\n        return CLIENT_ID, CLIENT_SECRET\n    except Exception:\n        return \"000000004C12AE6F\", \"\"  # public client ID, no secret\n\nTOKENS_FILE = _tokens_path()\nCLIENT_ID, CLIENT_SECRET = _client_constants()\n\ndef _extract_code(val: str) -> str:\n    s = val.strip()\n    if not s:\n        return \"\"\n    if s.lower().startswith(\"http\"):\n        q = up.urlparse(s).query\n        qs = up.parse_qs(q)\n        return (qs.get(\"code\") or [\"\"])[0]\n    # If they pasted a raw code with extra params like \"&lc=1033\", trim after first '&'\n    if \"&\" in s and not s.lower().startswith(\"microsoft\"):\n        s = s.split(\"&\", 1)[0]\n    return s\n\nasync def amain():\n    async with SignedSession() as session:\n        auth = AuthenticationManager(session, CLIENT_ID, CLIENT_SECRET, DESKTOP_REDIRECT)\n\n        # Try refresh existing tokens\n        try:\n            with open(TOKENS_FILE, \"r\", encoding=\"utf-8\") as f:\n                tokens_json = f.read()\n            auth.oauth = OAuth2TokenResponse.model_validate_json(tokens_json)\n            try:\n                await auth.refresh_tokens()\n                with open(TOKENS_FILE, \"w\", encoding=\"utf-8\") as f:\n                    f.write(auth.oauth.json())\n                print(\"[OK] Already signed in. Tokens refreshed.\")\n                print(f\"[Info] Tokens file: {TOKENS_FILE}\")\n                return\n            except Exception:\n                pass\n        except FileNotFoundError:\n            pass\n\n        # Start auth\n        url = auth.generate_authorization_url()\n        print(\"=== Xbox Sign\u2011In ===\")\n        print(\"1) Open this URL in a browser:\")\n        print(url)\n        print(\"2) Approve sign\u2011in; you will be redirected. If you see a code or a URL with '?code=', copy it.\")\n        val = input(\"3) Paste the code (or full URL) here, then press Enter: \").strip()\n        code = _extract_code(val)\n        if not code:\n            print(\"[CANCELLED] No code detected.\")\n            sys.exit(1)\n\n        try:\n            tokens = await auth.request_oauth_token(code)\n        except Exception as e:\n            print(\"[ERROR] Token exchange failed.\\n\"\n                  \"Tips:\\n\"\n                  \"  \u2022 Paste a **fresh** code (codes are single\u2011use).\\n\"\n                  \"  \u2022 If you pasted a code with '&lc=...', only paste up to the first '&'.\\n\"\n                  \"  \u2022 Or paste the **entire** redirected URL that contains '?code=...'\\n\"\n                  f\"Detail: {e}\", file=sys.stderr)\n            sys.exit(1)\n\n        auth.oauth = tokens\n        with open(TOKENS_FILE, \"w\", encoding=\"utf-8\") as f:\n            f.write(tokens.json())\n        print(\"[OK] Signed in and tokens saved.\")\n        print(f\"[Info] Tokens file: {TOKENS_FILE}\")\n\ndef main():\n    try:\n        asyncio.run(amain())\n    except KeyboardInterrupt:\n        print(\"\\n[Cancelled]\")\n    except Exception as e:\n        print(f\"[ERROR] {e}\", file=sys.stderr)\n        raise\n\nif __name__ == \"__main__\":\n    main()\n", "xbl_login_standalone_v3.py")
_register_module("xbl.xbl_login_standalone_v3", "\n# xbl_login_standalone_v3.py \u2014 Sign in to Xbox Live and save tokens\n# Usage: py xbl_login_standalone_v3.py\nimport os, sys, asyncio, urllib.parse as up\n\nfrom pythonxbox.authentication.manager import AuthenticationManager\nfrom pythonxbox.authentication.models import OAuth2TokenResponse\nfrom pythonxbox.common.signed_session import SignedSession\n\nDESKTOP_REDIRECT = \"https://login.live.com/oauth20_desktop.srf\"\n\ndef _tokens_path() -> str:\n    try:\n        from platformdirs import user_data_dir\n        base = user_data_dir(appname=\"xbox\", appauthor=\"OpenXbox\", roaming=False)\n    except Exception:\n        base = os.path.join(os.environ.get(\"LOCALAPPDATA\", os.path.expanduser(\"~\")), \"OpenXbox\", \"xbox\")\n    os.makedirs(base, exist_ok=True)\n    return os.path.join(base, \"tokens.json\")\n\ndef _client_constants():\n    try:\n        from pythonxbox.scripts import CLIENT_ID, CLIENT_SECRET\n        return CLIENT_ID, CLIENT_SECRET\n    except Exception:\n        return \"000000004C12AE6F\", \"\"  # public client ID, no secret\n\nTOKENS_FILE = _tokens_path()\nCLIENT_ID, CLIENT_SECRET = _client_constants()\n\ndef _extract_code(val: str) -> str:\n    s = val.strip()\n    if not s:\n        return \"\"\n    if s.lower().startswith(\"http\"):\n        q = up.urlparse(s).query\n        qs = up.parse_qs(q)\n        return (qs.get(\"code\") or [\"\"])[0]\n    # If they pasted a raw code with extra params like \"&lc=1033\", trim after first '&'\n    if \"&\" in s and not s.lower().startswith(\"microsoft\"):\n        s = s.split(\"&\", 1)[0]\n    return s\n\nasync def amain():\n    async with SignedSession() as session:\n        auth = AuthenticationManager(session, CLIENT_ID, CLIENT_SECRET, DESKTOP_REDIRECT)\n\n        # Try refresh existing tokens\n        try:\n            with open(TOKENS_FILE, \"r\", encoding=\"utf-8\") as f:\n                tokens_json = f.read()\n            auth.oauth = OAuth2TokenResponse.model_validate_json(tokens_json)\n            try:\n                await auth.refresh_tokens()\n                with open(TOKENS_FILE, \"w\", encoding=\"utf-8\") as f:\n                    f.write(auth.oauth.json())\n                print(\"[OK] Already signed in. Tokens refreshed.\")\n                print(f\"[Info] Tokens file: {TOKENS_FILE}\")\n                return\n            except Exception:\n                pass\n        except FileNotFoundError:\n            pass\n\n        # Start auth\n        url = auth.generate_authorization_url()\n        print(\"=== Xbox Sign\u2011In ===\")\n        print(\"1) Open this URL in a browser:\")\n        print(url)\n        print(\"2) Approve sign\u2011in; you will be redirected. If you see a code or a URL with '?code=', copy it.\")\n        val = input(\"3) Paste the code (or full URL) here, then press Enter: \").strip()\n        code = _extract_code(val)\n        if not code:\n            print(\"[CANCELLED] No code detected.\")\n            sys.exit(1)\n\n        try:\n            tokens = await auth.request_oauth_token(code)\n        except Exception as e:\n            print(\"[ERROR] Token exchange failed.\\n\"\n                  \"Tips:\\n\"\n                  \"  \u2022 Paste a **fresh** code (codes are single\u2011use).\\n\"\n                  \"  \u2022 If you pasted a code with '&lc=...', only paste up to the first '&'.\\n\"\n                  \"  \u2022 Or paste the **entire** redirected URL that contains '?code=...'\\n\"\n                  f\"Detail: {e}\", file=sys.stderr)\n            sys.exit(1)\n\n        auth.oauth = tokens\n        with open(TOKENS_FILE, \"w\", encoding=\"utf-8\") as f:\n            f.write(tokens.json())\n        print(\"[OK] Signed in and tokens saved.\")\n        print(f\"[Info] Tokens file: {TOKENS_FILE}\")\n\ndef main():\n    try:\n        asyncio.run(amain())\n    except KeyboardInterrupt:\n        print(\"\\n[Cancelled]\")\n    except Exception as e:\n        print(f\"[ERROR] {e}\", file=sys.stderr)\n        raise\n\nif __name__ == \"__main__\":\n    main()\n", "xbl/xbl_login_standalone_v3.py")
_register_module("xbl_profile_widget", "\nfrom __future__ import annotations\nimport sys, os, threading, time\nfrom pathlib import Path\nfrom urllib.parse import urlparse, urlunparse, urlencode, parse_qs, quote\nfrom PyQt6 import QtWidgets, QtCore\nfrom PyQt6.QtGui import QPixmap\nimport requests\n\n_HEADERS_INJECTED = None\n\ndef set_global_xbl_headers(h):\n    global _HEADERS_INJECTED\n    _HEADERS_INJECTED = h\n\ndef _possible_token_paths():\n    paths = []\n    env = os.environ.get(\"XBL_TOKENS_PATH\")\n    if env:\n        paths.append(Path(env))\n    paths.append(Path(os.getcwd()) / \"tokens.json\")\n    try:\n        here = Path(__file__).resolve().parent\n        paths.append(here / \"tokens.json\")\n    except Exception:\n        pass\n    local = Path(os.environ.get(\"LOCALAPPDATA\", Path.home())) / \"OpenXbox\" / \"xbox\" / \"tokens.json\"\n    paths.append(local)\n    return paths\n\ndef _read_headers_from_tokens():\n    from xbl_signin_from_oauth_tokens import get_xsts_from_tokens\n    last_err = None\n    for p in _possible_token_paths():\n        try:\n            if p.is_file():\n                print(f\"[xbl_profile_widget] using tokens.json at: {p}\")\n                info = get_xsts_from_tokens(str(p))\n                h = {\"Authorization\": info[\"Authorization\"], \"x-xbl-contract-version\": \"3\", \"Accept\": \"application/json\"}\n                return h\n        except Exception as e:\n            last_err = e\n            print(f\"[xbl_profile_widget] failed tokens at {p}: {e}\")\n    if last_err:\n        raise last_err\n    raise FileNotFoundError(\"tokens.json not found in any known location.\")\n\ndef _get_headers():\n    if _HEADERS_INJECTED:\n        h = dict(_HEADERS_INJECTED)\n        h.setdefault(\"Accept\", \"application/json\")\n        h.setdefault(\"x-xbl-contract-version\", \"3\")\n        return h\n    try:\n        return _read_headers_from_tokens()\n    except Exception as e:\n        print(\"[xbl_profile_widget] header load error:\", e)\n        return None\n\ndef _fetch_profile(headers):\n    url = \"https://profile.xboxlive.com/users/me/profile/settings?settings=Gamertag,GameDisplayPicRaw\"\n    print(\"[xbl_profile_widget] GET profile:\", url)\n    r = requests.get(url, headers=headers, timeout=8)\n    print(\"[xbl_profile_widget] profile status:\", r.status_code)\n    r.raise_for_status()\n    data = r.json()\n    user = (data.get(\"profileUsers\") or [None])[0] or {}\n    settings = {s.get(\"id\"): s.get(\"value\") for s in user.get(\"settings\", [])}\n    return settings.get(\"Gamertag\") or \"(unknown)\", settings.get(\"GameDisplayPicRaw\")\n\ndef _avatar_variants(u: str):\n    variants = []\n    try:\n        parsed = urlparse(u)\n        q = parse_qs(parsed.query)\n        inner = q.get(\"url\", [\"\"])[0]\n        if inner and (\"%2F\" not in inner and \"://\" in inner):\n            inner = quote(inner, safe=\"\")\n        base_q = {\"url\": inner} if inner else {}\n        size_opts = [\n            {\"w\": \"64\", \"h\": \"64\", \"format\": \"png\"},\n            {\"w\": \"128\", \"h\": \"128\", \"format\": \"png\"},\n            {\"w\": \"208\", \"h\": \"208\", \"format\": \"png\"},\n        ]\n        hosts = [\"images-eds-ssl.xboxlive.com\", \"images-eds.xboxlive.com\"]\n        for h in hosts:\n            for so in size_opts:\n                qd = dict(base_q); qd.update(so)\n                new = parsed._replace(scheme=\"https\", netloc=h, query=urlencode(qd, doseq=True), path=\"/image\")\n                variants.append(urlunparse(new))\n        variants.append(u)\n    except Exception:\n        variants.append(u)\n    seen = set(); out = []\n    for v in variants:\n        if v not in seen:\n            out.append(v); seen.add(v)\n    return out\n\ndef _download_avatar(url: str, timeout: int = 8) -> QPixmap | None:\n    ua = {\"User-Agent\": \"Mozilla/5.0\", \"Accept\": \"image/*\"}\n    variants = _avatar_variants(url)\n    last_err = None\n    for i, v in enumerate(variants, 1):\n        try:\n            print(f\"[xbl_profile_widget] avatar try {i}/{len(variants)}:\", v)\n            r = requests.get(v, headers=ua, timeout=8, allow_redirects=True)\n            print(\"[xbl_profile_widget] avatar status:\", r.status_code, \"len:\", len(r.content))\n            r.raise_for_status()\n            if not r.content:\n                raise RuntimeError(\"empty image\")\n            pm = QPixmap()\n            if pm.loadFromData(r.content):\n                return pm\n            last_err = RuntimeError(\"QPixmap load failed\")\n        except Exception as e:\n            last_err = e\n            print(f\"[xbl_profile_widget] avatar error:\", e)\n            time.sleep(0.1 if i < len(variants) else 0)\n    if last_err:\n        print(f\"[xbl_profile_widget] avatar failed: {last_err}\")\n    return None\n\nclass XboxProfileWidget(QtWidgets.QWidget):\n    profileReady = QtCore.pyqtSignal(str)     # gamertag\n    profileError = QtCore.pyqtSignal()\n    avatarReady  = QtCore.pyqtSignal(object)  # QPixmap\n\n    def __init__(self, parent=None):\n        super().__init__(parent)\n        row = QtWidgets.QHBoxLayout(self)\n        row.setContentsMargins(0,0,0,0)\n        self.lbl_avatar = QtWidgets.QLabel()\n        self.lbl_avatar.setFixedSize(48, 48)\n        self.lbl_avatar.setStyleSheet(\"border-radius:10px;background:#222;\")\n        self.lbl_name = QtWidgets.QLabel(\"<i>Not signed in</i>\")\n        self.lbl_name.setMinimumWidth(160)\n        self.btn_refresh = QtWidgets.QPushButton(\"Refresh\")\n        row.addWidget(self.lbl_avatar)\n        row.addSpacing(8)\n        row.addWidget(self.lbl_name)\n        row.addStretch(1)\n        row.addWidget(self.btn_refresh)\n\n        self._refreshing = False\n        self.btn_refresh.clicked.connect(self.refresh)\n\n        # Connect signals to UI slots (runs on main thread)\n        self.profileReady.connect(self._on_profile_ready)\n        self.profileError.connect(self._on_profile_error)\n        self.avatarReady.connect(self._on_avatar_ready)\n\n        QtCore.QTimer.singleShot(0, self.refresh)\n\n    def set_headers(self, headers: dict | None):\n        set_global_xbl_headers(headers)\n\n    @QtCore.pyqtSlot(str)\n    def _on_profile_ready(self, gamertag: str):\n        self.lbl_name.setText(gamertag)\n        self._refreshing = False\n\n    @QtCore.pyqtSlot()\n    def _on_profile_error(self):\n        self.lbl_name.setText(\"Profile error\")\n        self._refreshing = False\n\n    @QtCore.pyqtSlot(object)\n    def _on_avatar_ready(self, pm: QPixmap):\n        scaled = pm.scaled(48, 48, QtCore.Qt.AspectRatioMode.KeepAspectRatioByExpanding, QtCore.Qt.TransformationMode.SmoothTransformation)\n        self.lbl_avatar.setPixmap(scaled)\n\n    def refresh(self):\n        if self._refreshing:\n            return\n        self._refreshing = True\n        self.lbl_name.setText(\"Fetching...\")\n\n        def run_profile():\n            headers = _get_headers()\n            if not headers:\n                self.profileError.emit()\n                return\n            try:\n                gt, pic = _fetch_profile(headers)\n                self.profileReady.emit(gt)  # emit immediately (no timer races)\n                if pic:\n                    def run_avatar():\n                        pm = _download_avatar(pic, timeout=8)\n                        if pm:\n                            self.avatarReady.emit(pm)\n                    threading.Thread(target=run_avatar, daemon=True).start()\n            except Exception as e:\n                print(\"[xbl_profile_widget] profile fetch error:\", e)\n                self.profileError.emit()\n        threading.Thread(target=run_profile, daemon=True).start()\n\nif __name__ == \"__main__\":\n    app = QtWidgets.QApplication(sys.argv)\n    w = QtWidgets.QWidget()\n    w.setWindowTitle(\"Xbox Profile\")\n    lay = QtWidgets.QVBoxLayout(w)\n    lay.setContentsMargins(12,12,12,12)\n    lay.addWidget(XboxProfileWidget())\n    w.resize(320, 80)\n    w.show()\n    sys.exit(app.exec())\n", "xbl_profile_widget.py")
_register_module("xbl.xbl_profile_widget", "\nfrom __future__ import annotations\nimport sys, os, threading, time\nfrom pathlib import Path\nfrom urllib.parse import urlparse, urlunparse, urlencode, parse_qs, quote\nfrom PyQt6 import QtWidgets, QtCore\nfrom PyQt6.QtGui import QPixmap\nimport requests\n\n_HEADERS_INJECTED = None\n\ndef set_global_xbl_headers(h):\n    global _HEADERS_INJECTED\n    _HEADERS_INJECTED = h\n\ndef _possible_token_paths():\n    paths = []\n    env = os.environ.get(\"XBL_TOKENS_PATH\")\n    if env:\n        paths.append(Path(env))\n    paths.append(Path(os.getcwd()) / \"tokens.json\")\n    try:\n        here = Path(__file__).resolve().parent\n        paths.append(here / \"tokens.json\")\n    except Exception:\n        pass\n    local = Path(os.environ.get(\"LOCALAPPDATA\", Path.home())) / \"OpenXbox\" / \"xbox\" / \"tokens.json\"\n    paths.append(local)\n    return paths\n\ndef _read_headers_from_tokens():\n    from xbl_signin_from_oauth_tokens import get_xsts_from_tokens\n    last_err = None\n    for p in _possible_token_paths():\n        try:\n            if p.is_file():\n                print(f\"[xbl_profile_widget] using tokens.json at: {p}\")\n                info = get_xsts_from_tokens(str(p))\n                h = {\"Authorization\": info[\"Authorization\"], \"x-xbl-contract-version\": \"3\", \"Accept\": \"application/json\"}\n                return h\n        except Exception as e:\n            last_err = e\n            print(f\"[xbl_profile_widget] failed tokens at {p}: {e}\")\n    if last_err:\n        raise last_err\n    raise FileNotFoundError(\"tokens.json not found in any known location.\")\n\ndef _get_headers():\n    if _HEADERS_INJECTED:\n        h = dict(_HEADERS_INJECTED)\n        h.setdefault(\"Accept\", \"application/json\")\n        h.setdefault(\"x-xbl-contract-version\", \"3\")\n        return h\n    try:\n        return _read_headers_from_tokens()\n    except Exception as e:\n        print(\"[xbl_profile_widget] header load error:\", e)\n        return None\n\ndef _fetch_profile(headers):\n    url = \"https://profile.xboxlive.com/users/me/profile/settings?settings=Gamertag,GameDisplayPicRaw\"\n    print(\"[xbl_profile_widget] GET profile:\", url)\n    r = requests.get(url, headers=headers, timeout=8)\n    print(\"[xbl_profile_widget] profile status:\", r.status_code)\n    r.raise_for_status()\n    data = r.json()\n    user = (data.get(\"profileUsers\") or [None])[0] or {}\n    settings = {s.get(\"id\"): s.get(\"value\") for s in user.get(\"settings\", [])}\n    return settings.get(\"Gamertag\") or \"(unknown)\", settings.get(\"GameDisplayPicRaw\")\n\ndef _avatar_variants(u: str):\n    variants = []\n    try:\n        parsed = urlparse(u)\n        q = parse_qs(parsed.query)\n        inner = q.get(\"url\", [\"\"])[0]\n        if inner and (\"%2F\" not in inner and \"://\" in inner):\n            inner = quote(inner, safe=\"\")\n        base_q = {\"url\": inner} if inner else {}\n        size_opts = [\n            {\"w\": \"64\", \"h\": \"64\", \"format\": \"png\"},\n            {\"w\": \"128\", \"h\": \"128\", \"format\": \"png\"},\n            {\"w\": \"208\", \"h\": \"208\", \"format\": \"png\"},\n        ]\n        hosts = [\"images-eds-ssl.xboxlive.com\", \"images-eds.xboxlive.com\"]\n        for h in hosts:\n            for so in size_opts:\n                qd = dict(base_q); qd.update(so)\n                new = parsed._replace(scheme=\"https\", netloc=h, query=urlencode(qd, doseq=True), path=\"/image\")\n                variants.append(urlunparse(new))\n        variants.append(u)\n    except Exception:\n        variants.append(u)\n    seen = set(); out = []\n    for v in variants:\n        if v not in seen:\n            out.append(v); seen.add(v)\n    return out\n\ndef _download_avatar(url: str, timeout: int = 8) -> QPixmap | None:\n    ua = {\"User-Agent\": \"Mozilla/5.0\", \"Accept\": \"image/*\"}\n    variants = _avatar_variants(url)\n    last_err = None\n    for i, v in enumerate(variants, 1):\n        try:\n            print(f\"[xbl_profile_widget] avatar try {i}/{len(variants)}:\", v)\n            r = requests.get(v, headers=ua, timeout=8, allow_redirects=True)\n            print(\"[xbl_profile_widget] avatar status:\", r.status_code, \"len:\", len(r.content))\n            r.raise_for_status()\n            if not r.content:\n                raise RuntimeError(\"empty image\")\n            pm = QPixmap()\n            if pm.loadFromData(r.content):\n                return pm\n            last_err = RuntimeError(\"QPixmap load failed\")\n        except Exception as e:\n            last_err = e\n            print(f\"[xbl_profile_widget] avatar error:\", e)\n            time.sleep(0.1 if i < len(variants) else 0)\n    if last_err:\n        print(f\"[xbl_profile_widget] avatar failed: {last_err}\")\n    return None\n\nclass XboxProfileWidget(QtWidgets.QWidget):\n    profileReady = QtCore.pyqtSignal(str)     # gamertag\n    profileError = QtCore.pyqtSignal()\n    avatarReady  = QtCore.pyqtSignal(object)  # QPixmap\n\n    def __init__(self, parent=None):\n        super().__init__(parent)\n        row = QtWidgets.QHBoxLayout(self)\n        row.setContentsMargins(0,0,0,0)\n        self.lbl_avatar = QtWidgets.QLabel()\n        self.lbl_avatar.setFixedSize(48, 48)\n        self.lbl_avatar.setStyleSheet(\"border-radius:10px;background:#222;\")\n        self.lbl_name = QtWidgets.QLabel(\"<i>Not signed in</i>\")\n        self.lbl_name.setMinimumWidth(160)\n        self.btn_refresh = QtWidgets.QPushButton(\"Refresh\")\n        row.addWidget(self.lbl_avatar)\n        row.addSpacing(8)\n        row.addWidget(self.lbl_name)\n        row.addStretch(1)\n        row.addWidget(self.btn_refresh)\n\n        self._refreshing = False\n        self.btn_refresh.clicked.connect(self.refresh)\n\n        # Connect signals to UI slots (runs on main thread)\n        self.profileReady.connect(self._on_profile_ready)\n        self.profileError.connect(self._on_profile_error)\n        self.avatarReady.connect(self._on_avatar_ready)\n\n        QtCore.QTimer.singleShot(0, self.refresh)\n\n    def set_headers(self, headers: dict | None):\n        set_global_xbl_headers(headers)\n\n    @QtCore.pyqtSlot(str)\n    def _on_profile_ready(self, gamertag: str):\n        self.lbl_name.setText(gamertag)\n        self._refreshing = False\n\n    @QtCore.pyqtSlot()\n    def _on_profile_error(self):\n        self.lbl_name.setText(\"Profile error\")\n        self._refreshing = False\n\n    @QtCore.pyqtSlot(object)\n    def _on_avatar_ready(self, pm: QPixmap):\n        scaled = pm.scaled(48, 48, QtCore.Qt.AspectRatioMode.KeepAspectRatioByExpanding, QtCore.Qt.TransformationMode.SmoothTransformation)\n        self.lbl_avatar.setPixmap(scaled)\n\n    def refresh(self):\n        if self._refreshing:\n            return\n        self._refreshing = True\n        self.lbl_name.setText(\"Fetching...\")\n\n        def run_profile():\n            headers = _get_headers()\n            if not headers:\n                self.profileError.emit()\n                return\n            try:\n                gt, pic = _fetch_profile(headers)\n                self.profileReady.emit(gt)  # emit immediately (no timer races)\n                if pic:\n                    def run_avatar():\n                        pm = _download_avatar(pic, timeout=8)\n                        if pm:\n                            self.avatarReady.emit(pm)\n                    threading.Thread(target=run_avatar, daemon=True).start()\n            except Exception as e:\n                print(\"[xbl_profile_widget] profile fetch error:\", e)\n                self.profileError.emit()\n        threading.Thread(target=run_profile, daemon=True).start()\n\nif __name__ == \"__main__\":\n    app = QtWidgets.QApplication(sys.argv)\n    w = QtWidgets.QWidget()\n    w.setWindowTitle(\"Xbox Profile\")\n    lay = QtWidgets.QVBoxLayout(w)\n    lay.setContentsMargins(12,12,12,12)\n    lay.addWidget(XboxProfileWidget())\n    w.resize(320, 80)\n    w.show()\n    sys.exit(app.exec())\n", "xbl/xbl_profile_widget.py")
_register_module("xbl_signin_from_oauth_tokens", "\nimport json, requests, pathlib, os\n\nXBL_USER_AUTH = \"https://user.auth.xboxlive.com/user/authenticate\"\nXBL_XSTS_AUTH = \"https://xsts.auth.xboxlive.com/xsts/authorize\"\n\ndef get_xsts_from_tokens(tokens_path):\n    tokens_path = pathlib.Path(tokens_path)\n    data = json.loads(tokens_path.read_text())\n    access = data[\"access_token\"]\n    # user token\n    payload_user = {\n        \"RelyingParty\": \"http://auth.xboxlive.com\",\n        \"TokenType\": \"JWT\",\n        \"Properties\": {\n            \"AuthMethod\": \"RPS\",\n            \"SiteName\": \"user.auth.xboxlive.com\",\n            \"RpsTicket\": f\"d={access}\"\n        }\n    }\n    r = requests.post(XBL_USER_AUTH, json=payload_user, headers={\"Content-Type\":\"application/json\"})\n    r.raise_for_status()\n    j = r.json()\n    user_token = j[\"Token\"]\n    uhs = j[\"DisplayClaims\"][\"xui\"][0][\"uhs\"]\n\n    # xsts\n    payload_xsts = {\n        \"RelyingParty\": \"http://xboxlive.com\",\n        \"TokenType\": \"JWT\",\n        \"Properties\": {\n            \"UserTokens\": [user_token],\n            \"SandboxId\": \"RETAIL\"\n        }\n    }\n    r2 = requests.post(XBL_XSTS_AUTH, json=payload_xsts, headers={\"Content-Type\":\"application/json\"})\n    r2.raise_for_status()\n    j2 = r2.json()\n    xsts = j2[\"Token\"]\n    uhs2 = j2[\"DisplayClaims\"][\"xui\"][0][\"uhs\"]\n    return {\"Authorization\": f\"XBL3.0 x={uhs2};{xsts}\"}\n", "xbl_signin_from_oauth_tokens.py")
_register_module("xbl.xbl_signin_from_oauth_tokens", "\nimport json, requests, pathlib, os\n\nXBL_USER_AUTH = \"https://user.auth.xboxlive.com/user/authenticate\"\nXBL_XSTS_AUTH = \"https://xsts.auth.xboxlive.com/xsts/authorize\"\n\ndef get_xsts_from_tokens(tokens_path):\n    tokens_path = pathlib.Path(tokens_path)\n    data = json.loads(tokens_path.read_text())\n    access = data[\"access_token\"]\n    # user token\n    payload_user = {\n        \"RelyingParty\": \"http://auth.xboxlive.com\",\n        \"TokenType\": \"JWT\",\n        \"Properties\": {\n            \"AuthMethod\": \"RPS\",\n            \"SiteName\": \"user.auth.xboxlive.com\",\n            \"RpsTicket\": f\"d={access}\"\n        }\n    }\n    r = requests.post(XBL_USER_AUTH, json=payload_user, headers={\"Content-Type\":\"application/json\"})\n    r.raise_for_status()\n    j = r.json()\n    user_token = j[\"Token\"]\n    uhs = j[\"DisplayClaims\"][\"xui\"][0][\"uhs\"]\n\n    # xsts\n    payload_xsts = {\n        \"RelyingParty\": \"http://xboxlive.com\",\n        \"TokenType\": \"JWT\",\n        \"Properties\": {\n            \"UserTokens\": [user_token],\n            \"SandboxId\": \"RETAIL\"\n        }\n    }\n    r2 = requests.post(XBL_XSTS_AUTH, json=payload_xsts, headers={\"Content-Type\":\"application/json\"})\n    r2.raise_for_status()\n    j2 = r2.json()\n    xsts = j2[\"Token\"]\n    uhs2 = j2[\"DisplayClaims\"][\"xui\"][0][\"uhs\"]\n    return {\"Authorization\": f\"XBL3.0 x={uhs2};{xsts}\"}\n", "xbl/xbl_signin_from_oauth_tokens.py")


# === Embedded patches to avoid external helper files ===
try:
    import xbl_friends_dock_INLINE_v5_REFRESH_UI_v2_PATCHED as _fd
    # Resolve FriendsDock class
    FriendsDock = getattr(_fd, "FriendsDock", None)
    if FriendsDock is not None:
        def _embedded_refresh_token_only(self):
            # Mirror UI signals where possible
            try:
                self.sig_enable_btn.emit(False)
            except Exception:
                pass
            try:
                self.sig_set_status.emit("Refreshing token via embedded helper...")
            except Exception:
                pass
            # Prefer standalone login helper (embedded)
            _m = None
            try:
                import xbl_login_standalone_v3 as _m
            except Exception:
                try:
                    import xbl.xbl_login_standalone_v3 as _m
                except Exception:
                    _m = None
            ok = False
            if _m is not None and hasattr(_m, "main"):
                try:
                    _m.main()
                    ok = True
                except SystemExit:
                    ok = True
                except Exception as e:
                    ok = False
            # Notify
            msg = "Xbox token refresh complete." if ok else "Xbox token refresh failed."
            try:
                from PyQt6.QtWidgets import QMessageBox as _QMB6
                _QMB6.information(self, "Xbox token", msg)
            except Exception:
                try:
                    from PyQt5.QtWidgets import QMessageBox as _QMB5
                    _QMB5.information(self, "Xbox token", msg)
                except Exception:
                    print(msg)
            try:
                self.sig_enable_btn.emit(True)
            except Exception:
                pass

        def _embedded_do_auth(self):
            try:
                self.sig_enable_btn.emit(False)
            except Exception:
                pass
            try:
                self.sig_set_status.emit("Starting embedded sign-in...")
            except Exception:
                pass
            # Prefer device-code auth if present; otherwise fall back to login helper
            _m = None
            for name in ("xbl_auth_device_any", "xbl_login_standalone_v3"):
                try:
                    _m = __import__(name)
                    break
                except Exception:
                    try:
                        _m = __import__("xbl." + name, fromlist=["*"])
                        break
                    except Exception:
                        _m = None
            ok = False
            if _m is not None and hasattr(_m, "main"):
                try:
                    _m.main()
                    ok = True
                except SystemExit:
                    ok = True
                except Exception:
                    ok = False
            # Finalize
            try:
                self.sig_enable_btn.emit(True)
            except Exception:
                pass
            if not ok:
                try:
                    from PyQt6.QtWidgets import QMessageBox as _Q
                    _Q.critical(self, "Sign-in failed", "Embedded sign-in helper failed to run.")
                except Exception:
                    try:
                        from PyQt5.QtWidgets import QMessageBox as _Q
                        _Q.critical(self, "Sign-in failed", "Embedded sign-in helper failed to run.")
                    except Exception:
                        print("Embedded sign-in helper failed to run.")

        # Apply monkey patches
        FriendsDock._refresh_token_only = _embedded_refresh_token_only
        FriendsDock._do_auth = _embedded_do_auth
        # Add-only: hook friends presence updates to main window toast
        try:
            _uwpla_orig_init = FriendsDock.__init__
        except Exception:
            _uwpla_orig_init = None
        if _uwpla_orig_init is not None:
            def _uwpla_friends_init(self, *args, **kwargs):
                # Track last known presence to avoid re-toasting
                self._uwpla_last_presence = {}
                self._uwpla_initial_toasts_done = False
                # Call original __init__ first so signals/widgets exist
                _uwpla_orig_init(self, *args, **kwargs)
                try:
                    # Track last seen rows for diffing
                    self._uwpla_prev_rows = []
                except Exception:
                    pass
                try:
                    # Connect once; Qt will ignore duplicate connections safely
                    self.sig_set_rows.connect(self._uwpla_on_set_rows)
                except Exception:
                    pass

            def _uwpla_on_set_rows(self, rows):
                """Internal slot: watch friends rows and emit lightweight toasts on changes."""
                try:
                    new_rows = list(rows) if rows is not None else []
                except Exception:
                    new_rows = []
                try:
                    prev = getattr(self, "_uwpla_prev_rows", [])
                except Exception:
                    prev = []
                try:
                    prev_map = {str(r[0]): (r[1] if len(r) > 1 else "", r[2] if len(r) > 2 else "") for r in prev}
                    new_map = {str(r[0]): (r[1] if len(r) > 1 else "", r[2] if len(r) > 2 else "") for r in new_rows}
                except Exception:
                    # If anything looks weird, just store and bail
                    try:
                        self._uwpla_prev_rows = new_rows
                    except Exception:
                        pass
                    return

                # On very first load, toast all currently online friends once
                if not prev_map:
                    try:
                        parent = self.parent()
                    except Exception:
                        parent = None
                    if parent is not None and hasattr(parent, "_show_toast"):
                        try:
                            for row in new_rows:
                                try:
                                    name = str(row[0])
                                    state = str(row[1] if len(row) > 1 else "")
                                    title = str(row[2] if len(row) > 2 else "")
                                except Exception:
                                    continue
                                s_now = (state or "").lower()
                                if s_now == "online":
                                    try:
                                        if title:
                                            msg = f"{name} is online playing {title}."
                                        else:
                                            msg = f"{name} is online."
                                        parent._show_toast(msg, "info")
                                    except Exception:
                                        pass
                        except Exception:
                            pass
                    try:
                        self._uwpla_prev_rows = new_rows
                    except Exception:
                        pass
                    return

                try:
                    parent = self.parent()
                except Exception:
                    parent = None

                # Walk new rows and compare to previous
                for row in new_rows:
                    try:
                        name = str(row[0])
                        state = str(row[1] if len(row) > 1 else "")
                        title = str(row[2] if len(row) > 2 else "")
                    except Exception:
                        continue

                    old_state, old_title = prev_map.get(name, ("", ""))

                    # Normalize states
                    s_now = (state or "").lower()
                    s_old = (old_state or "").lower()

                    try:
                        # Friend came online
                        if s_now == "online" and s_old != "online":
                            if parent is not None and hasattr(parent, "_show_toast"):
                                try:
                                    if title:
                                        msg = f"{name} just came online playing {title}."
                                    else:
                                        msg = f"{name} just came online."
                                    parent._show_toast(msg, "info")
                                except Exception:
                                    pass

                        # Friend started a new game (title changed while online)
                        if title and title != old_title and s_now == "online":
                            if parent is not None and hasattr(parent, "_show_toast"):
                                try:
                                    parent._show_toast(f"{name} started playing {title}.", "success")
                                except Exception:
                                    pass
                    except Exception:
                        # Never let toast logic break the friends dock
                        continue

                try:
                    self._uwpla_prev_rows = new_rows
                except Exception:
                    pass

            FriendsDock.__init__ = _uwpla_friends_init
            FriendsDock._uwpla_on_set_rows = _uwpla_on_set_rows

except Exception as _e:
    # Non-fatal; app will still run and can fall back to original behavior
    pass
# === End embedded patches ===

# === Begin main app (executed at top-level) ===

# === Add-only: PyQt5->PyQt6 runtime shim & exclude real PyQt5 at build time ===
# Purpose: some helpers still `import PyQt5.*`. We ship only PyQt6 and provide a shim.
try:
    import sys, types
    import PyQt6.QtWidgets as _Q6W
    import PyQt6.QtCore as _Q6C
    import PyQt6.QtGui as _Q6G
    _pyqt5 = types.ModuleType("PyQt5")
    _pyqt5.QtWidgets = _Q6W
    _pyqt5.QtCore = _Q6C
    _pyqt5.QtGui = _Q6G
    # expose into sys.modules so `from PyQt5 import QtWidgets` works
    sys.modules.setdefault("PyQt5", _pyqt5)
    sys.modules.setdefault("PyQt5.QtWidgets", _Q6W)
    sys.modules.setdefault("PyQt5.QtCore", _Q6C)
    sys.modules.setdefault("PyQt5.QtGui", _Q6G)
except Exception:
    pass
# === End shim ===


# === Add-only: XBL compat shims (package path, legacy import alias, token loader) ===

# === Add-only: SSL certs for frozen builds ===
try:
    import certifi, os as _os
    _ca = certifi.where()
    _os.environ.setdefault("SSL_CERT_FILE", _ca)
    _os.environ.setdefault("REQUESTS_CA_BUNDLE", _ca)
except Exception:
    pass
# === End SSL certs ===

import sys, os, json
from pathlib import Path

# === App version & GitHub update config (ADD-ONLY) ===
# Bump APP_VERSION whenever you ship a new build.
APP_VERSION = "3.0.7"

# GitHub repo for UWPLauncher updates.
GITHUB_REPO = "Qvyn/UWPLauncher"
GITHUB_LATEST_URL = f"https://api.github.com/repos/{GITHUB_REPO}/releases/latest"


def _parse_version(v: str):
    """
    Turn '3.0.0' into (3, 0, 0). Non-numeric parts are ignored.
    """
    parts = []
    for piece in str(v).strip().split("."):
        try:
            parts.append(int(piece))
        except ValueError:
            # ignore non-numeric parts like a leading "v"
            continue
    return tuple(parts or [0])


def _version_is_newer(latest: str, current: str) -> bool:
    """
    Returns True if 'latest' > 'current' using simple x.y.z comparison.
    """
    return _parse_version(latest) > _parse_version(current)

def _update_download_dir():
    """Return the folder where update EXEs should be saved.

    For frozen/EXE builds this is the folder containing the current
    executable (next to the .exe), not the temporary _MEIPASS dir.
    For dev/non-frozen runs we fall back to the script directory.
    """
    from pathlib import Path
    # Frozen PyInstaller one-file exe: place download next to the exe
    if getattr(sys, "frozen", False):
        try:
            return Path(sys.executable).parent
        except Exception:
            pass
    # Non-frozen / dev: behave like the script normally would
    try:
        return Path(__file__).parent
    except NameError:
        return Path.cwd()




def _check_for_updates(window):
    """
    Global helper to check GitHub for the latest UWPLauncher release and
    optionally download the newest EXE into the launcher folder.
    """
    from PyQt6 import QtWidgets
    from pathlib import Path as _Path
    import requests, webbrowser, os

    def _toast(msg: str, level: str = "info"):
        try:
            if window is not None and hasattr(window, "_show_toast"):
                window._show_toast(msg, level)
        except Exception:
            pass

    try:
        resp = requests.get(GITHUB_LATEST_URL, timeout=5)
    except Exception as e:
        QtWidgets.QMessageBox.warning(
            window,
            "Update check failed",
            f"Could not contact GitHub:\n{e}"
        )
        _toast("Update check failed (network error).", "error")
        return

    if resp.status_code != 200:
        QtWidgets.QMessageBox.warning(
            window,
            "Update check failed",
            f"GitHub API returned status {resp.status_code}."
        )
        _toast(f"Update check failed (HTTP {resp.status_code}).", "error")
        return

    try:
        data = resp.json()
    except Exception as e:
        QtWidgets.QMessageBox.warning(
            window,
            "Update check failed",
            f"Could not read response:\n{e}"
        )
        _toast("Update check failed (bad response).", "error")
        return

    tag = (data.get("tag_name") or "").lstrip("v").strip()
    latest_ver = tag or ""
    if not latest_ver:
        QtWidgets.QMessageBox.warning(
            window,
            "Update check failed",
            "Could not read latest version info from GitHub."
        )
        return

    if not _version_is_newer(latest_ver, APP_VERSION):
        QtWidgets.QMessageBox.information(
            window,
            "UWPLauncher",
            f"You are already on the latest version ({APP_VERSION})."
        )
        _toast("Youre already on the latest version.", "success")
        return

    assets = data.get("assets") or []
    release_url = data.get("html_url") or ""
    asset_url = ""
    asset_name = ""

    if assets:
        asset = assets[0]
        asset_url = asset.get("browser_download_url") or ""
        asset_name = asset.get("name") or f"UWPLauncher_{latest_ver}.exe"

    if not asset_url:
        # Fallback: no asset found; just open the release page.
        msg = (
            f"A newer version of UWPLauncher is available.\n\n"
            f"Current version: {APP_VERSION}\n"
            f"Latest version:  {latest_ver}\n\n"
            f"No downloadable asset was found automatically.\n"
            f"Open the GitHub release page instead?"
        )
        btn = QtWidgets.QMessageBox.question(
            window,
            "Update available",
            msg,
            QtWidgets.QMessageBox.StandardButton.Yes
            | QtWidgets.QMessageBox.StandardButton.No,
        )
        if btn == QtWidgets.QMessageBox.StandardButton.Yes and release_url:
            try:
                webbrowser.open(release_url)
            except Exception:
                pass
        return

    # Ask the user if they want to download the new EXE now.
    msg = (
        f"A newer version of UWPLauncher is available.\n\n"
        f"Current version: {APP_VERSION}\n"
        f"Latest version:  {latest_ver}\n\n"
        f"Do you want to download the update now?"
    )
    btn = QtWidgets.QMessageBox.question(
        window,
        "Update available",
        msg,
        QtWidgets.QMessageBox.StandardButton.Yes
        | QtWidgets.QMessageBox.StandardButton.No,
    )
    if btn != QtWidgets.QMessageBox.StandardButton.Yes:
        return

    target_dir = _update_download_dir()
    try:
        target_dir.mkdir(parents=True, exist_ok=True)
    except Exception:
        pass

    dest = _Path(target_dir) / asset_name

    # If a file with the same name already exists, confirm overwrite.
    if dest.exists():
        btn = QtWidgets.QMessageBox.question(
            window,
            "Overwrite existing file?",
            f"An update file named '{asset_name}' already exists.\n"
            f"Overwrite it?",
            QtWidgets.QMessageBox.StandardButton.Yes
            | QtWidgets.QMessageBox.StandardButton.No,
        )
        if btn != QtWidgets.QMessageBox.StandardButton.Yes:
            return

    try:
        with requests.get(asset_url, stream=True, timeout=30) as r:
            if r.status_code != 200:
                QtWidgets.QMessageBox.warning(
                    window,
                    "Download failed",
                    f"Download returned status {r.status_code}."
                )
                return
            with open(dest, "wb") as f:
                for chunk in r.iter_content(chunk_size=8192):
                    if not chunk:
                        continue
                    f.write(chunk)
    except Exception as e:
        QtWidgets.QMessageBox.warning(
            window,
            "Download failed",
            f"Could not download update:\n{e}"
        )
        return

    # Offer to open the folder so the user can run the new EXE.
    msg = (
        f"Downloaded the new version to:\n{dest}\n\n"
        f"Close this app and run the new file to finish updating.\n"
        f"Open the folder now?"
    )
    _toast("Update downloaded to the selected folder.", "success")
    btn = QtWidgets.QMessageBox.question(
        window,
        "Update downloaded",
        msg,
        QtWidgets.QMessageBox.StandardButton.Yes
        | QtWidgets.QMessageBox.StandardButton.No,
    )
    if btn == QtWidgets.QMessageBox.StandardButton.Yes:
        try:
            os.startfile(str(target_dir))
        except Exception:
            try:
                webbrowser.open(str(target_dir))
            except Exception:
                pass


def _app_root():
    try:
        if getattr(sys, "frozen", False):
            return Path(getattr(sys, "_MEIPASS", Path(sys.executable).parent))
        return Path(__file__).parent
    except Exception:
        return Path.cwd()

# Make sure `xbl` package is importable
if str(_app_root()) not in sys.path:
    sys.path.insert(0, str(_app_root()))

# Back-compat alias: allow old code `import xbl_signin_from_oauth_tokens`
try:
    import importlib
    _alias = importlib.import_module("xbl.xbl_signin_from_oauth_tokens")
    import types as _types
    if "xbl_signin_from_oauth_tokens" not in sys.modules:
        sys.modules["xbl_signin_from_oauth_tokens"] = _alias
except Exception:
    pass

def _xbl_user_dir():
    base = os.environ.get("LOCALAPPDATA", str(Path.home()))
    p = Path(base) / "OpenXbox" / "xbox"
    p.mkdir(parents=True, exist_ok=True)
    return p

def _xbl_tokens_get():
    candidates = [
        _app_root() / "tokens.json",
        Path.cwd() / "tokens.json",
        _xbl_user_dir() / "tokens.json",
    ]
    for c in candidates:
        try:
            if c.exists():
                return json.loads(c.read_text(encoding="utf-8")), c
        except Exception:
            continue
    return None, candidates[-1]
# === End compat shims ===

# === Add-only: more legacy import aliases for moved helpers ===
try:
    import importlib, sys as _sys
    def _alias_mod(old_name, new_qualname):
        try:
            mod = importlib.import_module(new_qualname)
            if old_name not in _sys.modules:
                _sys.modules[old_name] = mod
        except Exception:
            pass

    # legacy names -> new package paths
    _alias_mod("xbl_profile_widget", "xbl.xbl_profile_widget")
    _alias_mod("xbl_friends_dock_INLINE_v5_REFRESH_UI_v2_PATCHED", "xbl.xbl_friends_dock_INLINE_v5_REFRESH_UI_v2_PATCHED")
    _alias_mod("xbl_auth_device_any", "xbl.xbl_auth_device_any")
except Exception:
    pass
# === End aliases ===



# === Add-only: XBL token refresh that prefers helper inside an "xbl" folder ===
import sys, subprocess, os, json
from pathlib import Path

# === Add-only: helper loader (no subprocess) ===
def _exe_dir():
    import sys
    from pathlib import Path
    try:
        return Path(sys.executable).parent
    except Exception:
        return Path.cwd()

def _ensure_exe_dir_on_syspath():
    import sys
    p = str(_exe_dir())
    if p not in sys.path:
        sys.path.insert(0, p)

def _load_helper_module_from_path(helper_path):
    """Load a .py module from disk in-process (works in frozen EXE)."""
    try:
        import importlib.util, sys
        spec = importlib.util.spec_from_file_location("xbl_login_standalone_v3_dyn", str(helper_path))
        if not spec or not spec.loader:
            return None
        mod = importlib.util.module_from_spec(spec)
        sys.modules[spec.name] = mod
        spec.loader.exec_module(mod)
        return mod
    except Exception:
        return None

def _run_xbl_helper_inline(parent=None):
    """
    Order:
      1) ENV XBL_HELPER_DIR
      2) import from xbl package (with exe_dir on sys.path)
      3) load from file in exe_dir/xbl, _MEIPASS/xbl, cwd/xbl
    """
    import os, sys
    from pathlib import Path

    helper_file = "xbl_login_standalone_v3.py"

    # 0) ENV
    env_dir = os.environ.get("XBL_HELPER_DIR")
    if env_dir:
        hp = Path(env_dir) / helper_file
        if hp.exists():
            mod = _load_helper_module_from_path(hp)
            if mod and hasattr(mod, "main"):
                try:
                    mod.main()
                except SystemExit:
                    pass
                return True

    # 1) import package
    try:
        _ensure_exe_dir_on_syspath()  # allow import from sibling xbl next to EXE
        from xbl import xbl_login_standalone_v3 as _m
        try:
            _m.main()
        except SystemExit:
            pass
        return True
    except Exception:
        pass

    # 2) load from common locations
    candidates = []
    # exe_dir/xbl
    candidates.append(_exe_dir() / "xbl" / helper_file)
    # _MEIPASS/xbl
    try:
        if getattr(sys, "frozen", False) and hasattr(sys, "_MEIPASS"):
            candidates.append(Path(sys._MEIPASS) / "xbl" / helper_file)
    except Exception:
        pass
    # cwd/xbl
    candidates.append(Path.cwd() / "xbl" / helper_file)

    for hp in candidates:
        if hp.exists():
            mod = _load_helper_module_from_path(hp)
            if mod and hasattr(mod, "main"):
                try:
                    mod.main()
                except SystemExit:
                    pass
                return True

    return False
# === End helper loader ===


def _xbl_user_dir():
    base = os.environ.get("LOCALAPPDATA", str(Path.home()))
    p = Path(base) / "OpenXbox" / "xbox"
    p.mkdir(parents=True, exist_ok=True)
    return p

def _is_frozen():
    return getattr(sys, "frozen", False)

def _app_root():
    if _is_frozen():
        return Path(getattr(sys, "_MEIPASS", Path(sys.executable).parent))
    # Use this file's directory as root in dev
    try:
        return Path(__file__).parent
    except NameError:
        return Path.cwd()

def _try_import_run_helper_from_xbl():
    """
    Try importing xbl.xbl_login_standalone_v3 and calling main().
    Works if you package the helper as a module (preferred).
    """
    try:
        import importlib
        mod = importlib.import_module("xbl.xbl_login_standalone_v3")
        if hasattr(mod, "main"):
            try:
                mod.main()
            except SystemExit:
                pass
        return True
    except Exception:
        return False


def _helper_candidates():
    root = _app_root()
    cand = [
        root / "xbl" / "xbl_login_standalone_v3.py",
        Path.cwd() / "xbl" / "xbl_login_standalone_v3.py",
        root / "xbl_login_standalone_v3.py",  # last resort
    ]
    return [p for p in cand if p.exists()]


def _try_spawn_helper_from_xbl_folder():
    """
    Fallback: run a loose helper script placed in an 'xbl' subfolder.
    Works in dev and in PyInstaller if you add-data the folder.
    """
    root = _app_root()
    for hp in _helper_candidates():
        if hp.exists():
            try:
                subprocess.run([sys.executable, str(hp)], cwd=str(hp.parent), timeout=180)
                return True
            except Exception:
                pass
    return False

def refresh_xbl_token(parent=None):
    """
    1) Prefer importing xbl.xbl_login_standalone_v3 and running main()
    2) Else spawn xbl/xbl_login_standalone_v3.py if present
    3) Tokens live in %LOCALAPPDATA%/OpenXbox/xbox/tokens.json
    """
    ok = _try_import_run_helper_from_xbl()
    if not ok:
        ok = _try_spawn_helper_from_xbl_folder()

    tok = _xbl_user_dir() / "tokens.json"
    exists = tok.exists()

    lines = [
        "Token refresh " + ("succeeded." if (ok and exists) else "may have failed."),
        "Tokens path:",
        str(tok),
    ]
    msg = "\n".join(lines)

    # Try Qt info box, else print
    try:
        from PyQt6.QtWidgets import QMessageBox
        QMessageBox.information(parent, "Xbox token", msg)
    except Exception:
        try:
            from PyQt5.QtWidgets import QMessageBox
            QMessageBox.information(parent, "Xbox token", msg)
        except Exception:
            print(msg)

def _auto_refresh_xbl_token_silent():
    """
    Background Xbox token refresh used by the main window timer.

    This reuses the same helper chain as refresh_xbl_token() but never shows
    message boxes, because it can fire on app startup and every few minutes.
    """
    try:
        ok = _try_import_run_helper_from_xbl()
        if not ok:
            ok = _try_spawn_helper_from_xbl_folder()
        tok = _xbl_user_dir() / "tokens.json"
        exists = tok.exists()
        try:
            print(f"[xbl_auto_refresh] helper_ok={ok} tokens_exist={exists} path={tok}")
        except Exception:
            pass
    except Exception as e:
        try:
            print(f"[xbl_auto_refresh] error: {e}")
        except Exception:
            pass

# === End add-only block ===

import sys, os, time, json, ctypes, subprocess, threading
from datetime import datetime
from PyQt6 import QtWidgets, QtCore, QtGui

# === ADD-ONLY: Minimal ThemeManager (Xbox green/black) ===
from PyQt6 import QtWidgets as _QW6
class ThemeManager:
    def __init__(self, app):
        self.app = app
    def apply(self, name: str):
        if name == "xbox_original":
            qss = """
            QWidget { background-color: #0b0f0c; color: #e9f0e8; selection-background-color: #107C10; }
            QMenuBar, QMenu { background-color: #0e140f; color: #e9f0e8; }
            QMenuBar::item:selected, QMenu::item:selected { background-color: #107C10; }
            QPushButton, QToolButton, QComboBox, QLineEdit, QSpinBox, QDoubleSpinBox {
                background-color: #121712; color: #e9f0e8; border: 1px solid #1a8f13; border-radius: 6px; padding: 5px 8px;
            }
            QPushButton:hover, QToolButton:hover, QComboBox:hover, QLineEdit:hover, QSpinBox:hover, QDoubleSpinBox:hover {
                border: 1px solid #2fae27;
            }
            QHeaderView::section { background-color: #101510; color: #cfe5cf; border: 1px solid #1a8f13; padding: 4px; }
            QTableView, QTreeView, QTableWidget, QTreeWidget { gridline-color: #1a8f13; background-color: #0d120d; alternate-background-color: #111711; }
            QScrollBar::handle { background: #107C10; border-radius: 4px; min-height: 20px; min-width: 20px; }
            QProgressBar { background-color: #0e140f; border: 1px solid #1a8f13; border-radius: 6px; text-align: center; color: #e9f0e8; }
            QProgressBar::chunk { background-color: #107C10; margin: 1px; border-radius: 5px; }
            """
        else:
            qss = ""
        try:
            self.app.setStyleSheet(qss)
        except Exception:
            pass
# === END ADD-ONLY ThemeManager ===

import os
from pathlib import Path

# ---- XBL token helpers (shared) ----
def _discover_tokens_path():
    # 1) explicit env
    p = os.environ.get("XBL_TOKENS_PATH")
    if p and Path(p).is_file():
        return p
    # 2) working dir
    p2 = Path(os.getcwd()) / "tokens.json"
    if p2.is_file():
        return str(p2)
    # 3) next to this script
    p3 = Path(__file__).with_name("tokens.json")
    if p3.is_file():
        return str(p3)
    # 4) OpenXbox default
    p4 = Path(os.environ.get("LOCALAPPDATA", os.path.expanduser("~"))) / "OpenXbox" / "xbox" / "tokens.json"
    if p4.is_file():
        return str(p4)
    return None




# Xbox Friends dock (import with fallback launcher)

# === FriendsDock JSON path overrides (write into ./config) ===
try:
    from pathlib import Path as __P
    try:
        __cfg_root = __P(__file__).resolve().parent / "config"
    except Exception:
        __cfg_root = __P.cwd() / "config"
    try:
        __cfg_root.mkdir(parents=True, exist_ok=True)
    except Exception:
        pass

    def __fd_settings_path(self):
        return __cfg_root / "friends_settings.json"

    def __fd_cache_path(self):
        return __cfg_root / "friends_cache.json"

    # Only override if methods exist on the class
    if 'FriendsDock' in globals():
        if hasattr(FriendsDock, '_settings_path'):
            FriendsDock._settings_path = __fd_settings_path
        if hasattr(FriendsDock, '_cache_path'):
            FriendsDock._cache_path = __fd_cache_path
except Exception:
    pass
import subprocess, sys as _sys
from pathlib import Path as _Path
try:
    from xbl_friends_dock import FriendsDock as _FriendsDock
except Exception:
    _FriendsDock = None
def _launch_friends_popup_external():
    # Launch standalone dock as separate process so UI never blocks
    exe = _sys.executable
    here = _Path(__file__).parent
    candidates = [
        here / "xbl_friends_dock_INLINE_v5_REFRESH_UI_v2_PATCHED.py",
        here / "xbl_friends_dock_INLINE_v5_REFRESH_UI_v2.py",
        here / "xbl_friends_dock.py",
    ]
    for popup in candidates:
        if popup.exists():
            try:
                subprocess.Popen([exe, str(popup)], close_fds=True)
                return
            except Exception:
                continue
    # nothing worked
    return

# Optional Xbox Friends dock
try:
    # Try several module names for the friends dock
    FriendsDock = None
    try:
        from xbl_friends_dock import FriendsDock as _FD
        FriendsDock = _FD
    except Exception:
        try:
            from xbl_friends_dock_INLINE_v5_REFRESH_UI_v2_PATCHED import FriendsDock as _FD
            FriendsDock = _FD
        except Exception:
            try:
                from xbl_friends_dock_INLINE_v5_REFRESH_UI_v2 import FriendsDock as _FD
                FriendsDock = _FD
            except Exception:
                FriendsDock = None
except Exception:
    FriendsDock = None

# --- Optional Xbox profile widget ---
try:
    from xbl_profile_widget import XboxProfileWidget
except Exception:
    XboxProfileWidget = None


# ---- Xbox Live helpers (optional) ----
# Prefer existing tokens.json (OpenXbox) if present; fallback to device-code helper.
_XBL_IMPORT_ERR = ""
_XBL_IMPORT_OK = False
_XBL_TOKENS_OK = False
try:
    from xbl_signin_from_oauth_tokens import get_xsts_from_tokens as _xbl_tokens_get
    _XBL_TOKENS_OK = True
except Exception as _e:
    _XBL_IMPORT_ERR = str(_e)

try:
    from xbl_signin_standalone import get_xsts as _xbl_get_xsts
    _XBL_IMPORT_OK = True
except Exception as _e:
    if not _XBL_IMPORT_ERR:
        _XBL_IMPORT_ERR = str(_e)


# ================== Config ==================
UWPHOOK_EXE = ""  # no default path; will be resolved at runtime and saved in settings.json

# ---- UWPHook path resolver (first-run friendly) ----
def _resolve_uwphook_path(parent=None):
    """
    Return a valid path to UWPHook.exe.
    Order:
      1) settings.json  'uwphook_path'
      2) same folder as this script
      3) prompt the user to locate it (then persist to settings.json)
    """
    try:
        settings = load_settings()
    except Exception:
        settings = {}

    # Candidates in priority order
    candidates = []
    p = (settings or {}).get("uwphook_path", "").strip()
    if p:
        candidates.append(p)
    try:
        here = str(Path(__file__).parent / "UWPHook.exe")
        candidates.append(here)
    except Exception:
        pass

    for c in candidates:
        try:
            if c and os.path.isfile(c):
                if (settings or {}).get("uwphook_path") != c:
                    try:
                        s = dict(settings or {})
                        s["uwphook_path"] = c
                        save_settings(s)
                    except Exception:
                        pass
                return c
        except Exception:
            pass

    # Not found  ask user
    try:
        from PyQt6 import QtWidgets
        fname, _ = QtWidgets.QFileDialog.getOpenFileName(
            parent,
            "Locate UWPHook.exe",
            str(Path.home()),
            "UWPHook.exe (UWPHook.exe);;Executables (*.exe);;All Files (*)",
        )
        if fname and os.path.basename(fname).lower() == "uwphook.exe" and os.path.isfile(fname):
            try:
                s = dict(settings or {})
                s["uwphook_path"] = fname
                save_settings(s)
            except Exception:
                pass
            return fname
    except Exception:
        pass
    return ""


# Default flags used when "Use Flags" is checked (per-game flags live in games.json)
DEFAULT_FLAGS    = []



# -------- Discord RPC defaults (public; safe to ship) --------
DISCORD_CLIENT_ID_DEFAULT = "1434331516422455296"   # your Discord Application ID
DISCORD_ENABLED_DEFAULT   = True                    # auto-enable by default
# ============= Paths =============
# Use the EXE directory when frozen, otherwise the script directory.
if getattr(sys, "frozen", False):
    BASE_DIR = os.path.dirname(sys.executable)
else:
    BASE_DIR = os.path.dirname(__file__)

CONFIG_DIR = os.path.join(BASE_DIR, "config")
os.makedirs(CONFIG_DIR, exist_ok=True)
ARTWORK_DIR = os.path.join(CONFIG_DIR, "artwork")
os.makedirs(ARTWORK_DIR, exist_ok=True)
try:
    os.makedirs(CONFIG_DIR, exist_ok=True)
except Exception:
    pass

# JSONs moved into ./config except tokens.json (per user request)
GAMES_DB_PATH = os.path.join(CONFIG_DIR, "games.json")
SETTINGS_PATH = os.path.join(CONFIG_DIR, "settings.json")

# Kernel32 / Affinity / Priority
kernel32 = ctypes.WinDLL('kernel32', use_last_error=True)
OpenProcess = kernel32.OpenProcess
SetPriorityClass = kernel32.SetPriorityClass
SetProcessAffinityMask = kernel32.SetProcessAffinityMask
CloseHandle = kernel32.CloseHandle

PROCESS_QUERY_LIMITED_INFORMATION = 0x1000
PROCESS_SET_INFORMATION           = 0x0200

HIGH_PRIORITY_CLASS  = 0x00000080
NORMAL_PRIORITY_CLASS= 0x00000020

# ============= Games persistence =============
def _seed_defaults():
    # Two seed entries as examples
    return [
        {
            "name": "Gears of War Reloaded",
            "aumid": "Microsoft.Pender_8wekyb3d8bbwe!Launch.GOWDE",
            "exe_name": "Launch_GOWDE.exe",
            "flags": DEFAULT_FLAGS[:],
            "mask_hex": "",                # blank -> auto (all CPUs except CPU0)
            "use_flags": True,
            "high_priority": True,
            "apply_affinity": True,
        },
        {
            "name": "Gears 5",
            "aumid": "Microsoft.HalifaxBaseGame_8wekyb3d8bbwe!GearGameShippingInternal",
            "exe_name": "Gears5_EAC.exe",
            "flags": DEFAULT_FLAGS[:],
            "mask_hex": "",
            "use_flags": True,
            "high_priority": True,
            "apply_affinity": True,
        }
    ]

def load_games():
    try:
        with open(GAMES_DB_PATH, "r", encoding="utf-8") as f:
            data = json.load(f)
            if isinstance(data, list):
                # Normalize flags field into list
                try:
                    for __g in data:
                        __f = __g.get('flags', [])
                        if isinstance(__f, str):
                            __g['flags'] = [x for x in __f.strip().split() if x]
                except Exception:
                    pass
                return data
    except Exception:
        pass
    data = _seed_defaults()
    save_games(data)
    return data

def save_games(data):
    try:
        with open(GAMES_DB_PATH, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2)
    except Exception as e:
        print("Failed saving games.json:", e)

def get_game_by_name(name, games):
    for g in games:
        if g.get("name") == name:
            return g
    return None

# ============= Settings persistence (Discord RPC) =============
def _seed_settings():
    return {
        "discord_enabled": DISCORD_ENABLED_DEFAULT,
        "discord_client_id": DISCORD_CLIENT_ID_DEFAULT,
        "discord_details_tpl": "{name}",
        "discord_state_tpl": "HighPrio={high}  Affinity={aff}  Flags={flags}",
        # New: opt-in artwork-based background
        "use_artwork_theme": False,
        # New: remember game grid cover size
        "cover_size": 220,
        # New: global developer mode switch for exposing advanced options
        "dev_mode": False,
    }

def load_settings():
    try:
        with open(SETTINGS_PATH, "r", encoding="utf-8") as f:
            data = json.load(f)
            if isinstance(data, dict):
                base = _seed_settings()
                base.update(data)
                # Fallback order: env var -> file -> hardcoded default
                cid_env = os.environ.get("DISCORD_CLIENT_ID", "").strip()
                if cid_env:
                    base["discord_client_id"] = cid_env
                if not base.get("discord_client_id"):
                    base["discord_client_id"] = DISCORD_CLIENT_ID_DEFAULT
                # If we have an ID, default to enabled
                if base.get("discord_client_id") and base.get("discord_enabled") is False:
                    base["discord_enabled"] = DISCORD_ENABLED_DEFAULT
                return base
    except Exception:
        pass
    data = _seed_settings()
    save_settings(data)
    return data

def save_settings(data):
    try:
        with open(SETTINGS_PATH, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2)
    except Exception as e:
        print("Failed saving settings.json:", e)

# ============= Process helpers =============
class PROCESSENTRY32(ctypes.Structure):
    _fields_ = [
        ('dwSize', ctypes.c_ulong),
        ('cntUsage', ctypes.c_ulong),
        ('th32ProcessID', ctypes.c_ulong),
        ('th32DefaultHeapID', ctypes.POINTER(ctypes.c_ulong)),
        ('th32ModuleID', ctypes.c_ulong),
        ('cntThreads', ctypes.c_ulong),
        ('th32ParentProcessID', ctypes.c_ulong),
        ('pcPriClassBase', ctypes.c_long),
        ('dwFlags', ctypes.c_ulong),
        ('szExeFile', ctypes.c_char * 260),
    ]

CreateToolhelp32Snapshot = ctypes.windll.kernel32.CreateToolhelp32Snapshot
Process32First           = ctypes.windll.kernel32.Process32First
Process32Next            = ctypes.windll.kernel32.Process32Next
_CloseHandle             = ctypes.windll.kernel32.CloseHandle
TH32CS_SNAPPROCESS       = 0x00000002

def iter_pids_by_name(exe_name: str):
    exe_name_low = exe_name.lower()
    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)
    if hSnapshot == ctypes.c_void_p(-1).value:
        return
    entry = PROCESSENTRY32()
    entry.dwSize = ctypes.sizeof(PROCESSENTRY32)
    if not Process32First(hSnapshot, ctypes.byref(entry)):
        _CloseHandle(hSnapshot); return
    while True:
        name = entry.szExeFile.decode(errors='ignore').lower()
        if name == exe_name_low:
            yield entry.th32ProcessID
        if not Process32Next(hSnapshot, ctypes.byref(entry)):
            break
    _CloseHandle(hSnapshot)

def compute_mask(mask_hex: str | None) -> int:
    if mask_hex:
        try:
            return int(mask_hex, 16)
        except Exception:
            pass
    # auto: use all CPUs except CPU0
    try:
        import multiprocessing
        n = multiprocessing.cpu_count()
    except Exception:
        n = 8
    if n <= 1:
        return 1
    return (1 << n) - 2  # drop CPU0

def apply_affinity_priority(exe_name: str, mask_hex: str, do_aff: bool, do_high: bool) -> tuple[int,int]:
    mask = compute_mask(mask_hex)
    changed = 0
    for pid in iter_pids_by_name(exe_name):
        access = PROCESS_QUERY_LIMITED_INFORMATION | PROCESS_SET_INFORMATION
        h = OpenProcess(access, False, pid)
        if h:
            try:
                if do_aff:
                    SetProcessAffinityMask(h, ctypes.c_size_t(mask))
                if do_high:
                    SetPriorityClass(h, HIGH_PRIORITY_CLASS)
                changed += 1
            finally:
                CloseHandle(h)
    return changed, mask

# ============= Discord RPC =============
class DiscordManager:
    def __init__(self):
        self.enabled = False
        self.client_id = ""
        self.rpc = None
        self.connected = False
        self.start_time = None

        # Keyboard shortcut: Ctrl+F opens Friends pop-out
        try:
            sc = QtGui.QShortcut(QtGui.QKeySequence('Ctrl+F'), self)
            sc.activated.connect(_friends_click)
            self._friends_shortcut = sc
        except Exception:
            pass

    def configure(self, enabled: bool, client_id: str):
        self.enabled = bool(enabled)
        self.client_id = (client_id or "").strip()

    def connect(self, log_cb=lambda s: None):
        if not self.enabled or not self.client_id:
            return False
        try:
            from pypresence import Presence  # requires pypresence installed
        except Exception as e:
            log_cb(f"Discord RPC unavailable (pypresence not installed): {e}")
            return False
        try:
            self.rpc = Presence(self.client_id)
            self.rpc.connect()
            self.connected = True
            self.start_time = int(time.time())
            log_cb("Discord RPC connected.")
            return True
        except Exception as e:
            log_cb(f"Discord RPC failed to connect: {e}")
            self.connected = False
            return False

    def set_presence(self, details: str, state: str, log_cb=lambda s: None):
        if not self.connected or not self.rpc:
            return
        try:
            self.rpc.update(details=details[:127], state=state[:127], start=self.start_time)
        except Exception as e:
            log_cb(f"Discord RPC update failed: {e}")

    def clear(self, log_cb=lambda s: None):
        if not self.connected or not self.rpc:
            return
        try:
            self.rpc.clear()
            log_cb("Discord RPC cleared.")
        except Exception as e:
            log_cb(f"Discord RPC clear failed: {e}")

    def close(self, log_cb=lambda s: None):
        if not self.connected or not self.rpc:
            return
        try:
            self.rpc.close()
            self.connected = False
            log_cb("Discord RPC closed.")
        except Exception as e:
            log_cb(f"Discord RPC close failed: {e}")

# ============= UWP Sync (Get-StartApps) =============
def get_start_apps_via_powershell():
    """
    Returns list of dicts: [{Name, AppID}, ...] gathered by Get-StartApps.
    Requires PowerShell (Windows 10/11). If not available, returns [].
    """
    try:
        # Ensure powershell is available
        ps = os.environ.get("SystemRoot", r"C:\Windows")
        ps_exe = os.path.join(ps, "System32", "WindowsPowerShell", "v1.0", "powershell.exe")
        if not os.path.isfile(ps_exe):
            ps_exe = "powershell"
        cmd = [ps_exe, "-NoProfile", "-ExecutionPolicy", "Bypass", "-Command",
               "Get-StartApps | Select-Object Name,AppID | ConvertTo-Json -Depth 3"]
        out = subprocess.check_output(cmd, stderr=subprocess.STDOUT, text=True, encoding="utf-8", creationflags=0x08000000 if os.name == "nt" else 0)
        data = json.loads(out)
        if isinstance(data, dict):
            data = [data]
        results = []
        for item in (data or []):
            name = item.get("Name", "")
            appid = item.get("AppID", "")
            if name and appid:
                results.append({"Name": name, "AppID": appid})
        return results
    except Exception:
        return []

class UWPSyncDialog(QtWidgets.QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Sync UWP Apps")
        self.resize(700, 500)
        v = QtWidgets.QVBoxLayout(self)

        self.info = QtWidgets.QLabel("Detected Start Apps (use search to filter). Select one to add as a game profile.")
        v.addWidget(self.info)

        search_row = QtWidgets.QHBoxLayout()
        self.search = QtWidgets.QLineEdit()
        self.search.setPlaceholderText("Search apps...")
        search_row.addWidget(self.search)

        # Refresh "button" as a custom widget so it matches the rest of the UI.
        # This is a small clickable frame with an icon + label, instead of a
        # plain QPushButton.
        self.btn_refresh = QtWidgets.QFrame()
        self.btn_refresh.setObjectName("RefreshWidget")
        btn_layout = QtWidgets.QHBoxLayout(self.btn_refresh)
        btn_layout.setContentsMargins(8, 4, 8, 4)
        btn_layout.setSpacing(6)

        lbl_icon = QtWidgets.QLabel("")
        lbl_icon.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        btn_layout.addWidget(lbl_icon)

        lbl_text = QtWidgets.QLabel("Refresh")
        btn_layout.addWidget(lbl_text)
        btn_layout.addStretch(1)

        # Give it a clickable cursor and a subtle border so it feels like a widget.
        try:
            self.btn_refresh.setCursor(QtGui.QCursor(QtCore.Qt.CursorShape.PointingHandCursor))
            self.btn_refresh.setStyleSheet(
                "#RefreshWidget {"
                "  border: 1px solid #3c3c3c;"
                "  border-radius: 6px;"
                "  background-color: #202020;"
                "}"
                "#RefreshWidget:hover {"
                "  border-color: #4caf50;"
                "  background-color: #262626;"
                "}"
            )
        except Exception:
            pass

        search_row.addWidget(self.btn_refresh)
        v.addLayout(search_row)

        self.list = QtWidgets.QListWidget()
        v.addWidget(self.list, 1)

        btn_row = QtWidgets.QHBoxLayout()
        self.btn_add = QtWidgets.QPushButton("Add Selected")
        self.btn_close = QtWidgets.QPushButton("Close")
        btn_row.addStretch(1)
        btn_row.addWidget(self.btn_add)
        btn_row.addWidget(self.btn_close)
        v.addLayout(btn_row)

        self.btn_close.clicked.connect(self.close)

        # Make the refresh widget clickable.
        def _refresh_click(ev):
            try:
                self.populate()
            except Exception:
                pass
        self.btn_refresh.mousePressEvent = _refresh_click
        self.search.textChanged.connect(self._apply_filter)
        self.populate()

    def populate(self):
        self.all_items = get_start_apps_via_powershell()
        self._refresh("")

    def _apply_filter(self, text):
        self._refresh(text or "")

    def _refresh(self, query: str):
        q = (query or "").lower()
        self.list.clear()
        for app in (self.all_items or []):
            line = f"{app['Name']}    {app['AppID']}"
            if not q or q in line.lower():
                it = QtWidgets.QListWidgetItem(line)
                it.setData(QtCore.Qt.ItemDataRole.UserRole, app)
                self.list.addItem(it)

    def selected_app(self):
        it = self.list.currentItem()
        if not it: return None
        return it.data(QtCore.Qt.ItemDataRole.UserRole)

# ============= UI Editors =============
class GameEditor(QtWidgets.QDialog):
    def __init__(self, parent=None, data=None):
        super().__init__(parent)
        self.setWindowTitle("Game Settings")
        self.setModal(True)
        self.data = data or {}
        form = QtWidgets.QFormLayout(self)

        self.name = QtWidgets.QLineEdit(self.data.get("name",""))
        self.aumid = QtWidgets.QLineEdit(self.data.get("aumid",""))
        self.exe = QtWidgets.QLineEdit(self.data.get("exe_name",""))
        self.exe_path = QtWidgets.QLineEdit(self.data.get("exe",""))
        self.flags = QtWidgets.QLineEdit(" ".join(self.data.get("flags", [])))
        self.mask = QtWidgets.QLineEdit(self.data.get("mask_hex",""))

        self.chk_use_flags = QtWidgets.QCheckBox()
        self.chk_use_flags.setChecked(bool(self.data.get("use_flags", True)))
        self.chk_high = QtWidgets.QCheckBox()
        self.chk_high.setChecked(bool(self.data.get("high_priority", True)))
        self.chk_aff = QtWidgets.QCheckBox()
        self.chk_aff.setChecked(bool(self.data.get("apply_affinity", True)))

        form.addRow("Name", self.name)
        form.addRow("AUMID / UWP ID", self.aumid)
        form.addRow("Game EXE (process)", self.exe)
        form.addRow("EXE Path (optional)", self.exe_path)
        form.addRow("Flags (space-separated)", self.flags)
        form.addRow("Affinity Mask (HEX)", self.mask)
        form.addRow("Use Flags", self.chk_use_flags)
        form.addRow("High Priority", self.chk_high)
        form.addRow("Apply Affinity", self.chk_aff)

        # Custom artwork (optional, saved with other artwork)
        self.custom_art_path = self.data.get("custom_art_path", "")
        art_row = QtWidgets.QHBoxLayout()
        self.btn_artwork = QtWidgets.QPushButton("Choose artwork image...")
        self.lbl_artwork_status = QtWidgets.QLabel(self._artwork_status_text())
        self.lbl_artwork_status.setStyleSheet("color: gray;")
        art_row.addWidget(self.btn_artwork)
        art_row.addWidget(self.lbl_artwork_status, 1)

        # Let the user pick a custom artwork image and copy it into the
        # launcher artwork folder. This wires the button to the existing
        # _on_choose_artwork helper below.
        try:
            self.btn_artwork.clicked.connect(self._on_choose_artwork)
        except Exception:
            pass
        art_widget = QtWidgets.QWidget()
        art_widget.setLayout(art_row)
        form.addRow("Custom artwork", art_widget)

        btns = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.StandardButton.Ok | QtWidgets.QDialogButtonBox.StandardButton.Cancel)
        # (no artwork button in SettingsEditor; handler not needed here)
        btns.accepted.connect(self.accept)
        btns.rejected.connect(self.reject)
        form.addRow(btns)


    def _artwork_status_text(self):
        p = (self.custom_art_path or "").strip()
        if p:
            try:
                import os as _os
                base = _os.path.basename(p)
            except Exception:
                base = p
            return f"Selected: {base}"
        return "No custom artwork set"

    def _on_choose_artwork(self):
        # Let the user pick an image file and copy it into the launcher artwork folder.
        from PyQt6 import QtWidgets as _QtWidgets
        try:
            fname, _ = _QtWidgets.QFileDialog.getOpenFileName(
                self,
                "Select artwork image",
                "",
                "Images (*.png *.jpg *.jpeg *.bmp *.webp);;All Files (*)",
            )
        except Exception:
            fname = ""
        if not fname:
            return
        try:
            from pathlib import Path as _Path
            import shutil

            src = _Path(fname)
            if not src.is_file():
                return

            # Target name based on Steam appid if present, else game name
            base_name = None
            try:
                appid = str(self.data.get("appid", "")).strip()
                if appid:
                    base_name = f"{appid}{src.suffix.lower() or '.jpg'}"
            except Exception:
                base_name = None
            if not base_name:
                nm = self.name.text().strip() or "game"
                safe = "".join(c if c.isalnum() else "_" for c in nm)
                base_name = f"{safe}{src.suffix.lower() or '.jpg'}"

            # Ensure artwork folder exists and copy there
            target_dir = ARTWORK_DIR if isinstance(ARTWORK_DIR, str) else str(ARTWORK_DIR)
            target_dir_path = _Path(target_dir)
            try:
                target_dir_path.mkdir(parents=True, exist_ok=True)
            except Exception:
                pass

            dst = target_dir_path / base_name
            shutil.copyfile(src, dst)
            self.custom_art_path = str(dst)
            self.lbl_artwork_status.setText(self._artwork_status_text())
        except Exception as e:
            try:
                _QtWidgets.QMessageBox.warning(self, "Artwork", f"Failed to copy artwork:\n{e}")
            except Exception:
                print(f"[ART] Failed to copy artwork: {e}")

    def get_data(self):
        return {
            "name": self.name.text().strip(),
            "aumid": self.aumid.text().strip(),
            "exe_name": self.exe.text().strip(),
            "exe": self.exe_path.text().strip(),
            "flags": [f for f in self.flags.text().strip().split() if f],
            "mask_hex": self.mask.text().strip(),
            "use_flags": self.chk_use_flags.isChecked(),
            "high_priority": self.chk_high.isChecked(),
            "apply_affinity": self.chk_aff.isChecked(),
            "custom_art_path": (self.custom_art_path or "").strip(),
        }


class SettingsEditor(QtWidgets.QDialog):
    def __init__(self, parent=None, settings=None):
        super().__init__(parent)
        self.setWindowTitle("Settings (Discord RPC)")
        self.setModal(True)
        self.settings = dict(settings or {})
        form = QtWidgets.QFormLayout(self)

        # Global toggle
        self.chk_discord = QtWidgets.QCheckBox()
        self.chk_discord.setChecked(bool(self.settings.get("discord_enabled", False)))

        # Advanced fields (client id + templates)  visibility controlled by dev_mode
        self.client_id = QtWidgets.QLineEdit(self.settings.get("discord_client_id", ""))
        self.details_tpl = QtWidgets.QLineEdit(self.settings.get("discord_details_tpl", "{name}"))
        self.state_tpl = QtWidgets.QLineEdit(self.settings.get(
            "discord_state_tpl",
            "HighPrio={high}  Affinity={aff}  Flags={flags}",
        ))

        dev_mode = bool(self.settings.get("dev_mode", False))

        # Only show advanced controls when dev_mode is enabled
        form.addRow("Enable Discord RPC", self.chk_discord)
        if dev_mode:
            form.addRow("Discord Client ID", self.client_id)
            form.addRow("Details Template", self.details_tpl)
            form.addRow("State Template", self.state_tpl)

            hint = QtWidgets.QLabel("Template vars: {name}, {high}, {aff}, {flags}")
            hint.setStyleSheet("color: gray;")
            form.addRow(hint)
        else:
            # Hide widgets from layout when not in dev mode, but keep values alive
            self.client_id.setVisible(False)
            self.details_tpl.setVisible(False)
            self.state_tpl.setVisible(False)

        # Use selected game artwork as full-window background
        self.chk_artwork_theme = QtWidgets.QCheckBox()
        self.chk_artwork_theme.setChecked(bool(self.settings.get("use_artwork_theme", False)))
        form.addRow("Use game artwork for theme", self.chk_artwork_theme)

        btns = QtWidgets.QDialogButtonBox(
            QtWidgets.QDialogButtonBox.StandardButton.Ok
            | QtWidgets.QDialogButtonBox.StandardButton.Cancel
        )
        btns.accepted.connect(self.accept)
        btns.rejected.connect(self.reject)
        form.addRow(btns)

    def get_settings(self):
        # Preserve dev_mode flag as-is; it is controlled from the main settings gear menu
        dev_mode = bool(self.settings.get("dev_mode", False))
        return {
            "discord_enabled": self.chk_discord.isChecked(),
            "discord_client_id": self.client_id.text().strip(),
            "discord_details_tpl": self.details_tpl.text().strip() or "{name}",
            "discord_state_tpl": self.state_tpl.text().strip() or "HighPrio={high}  Affinity={aff}  Flags={flags}",
            # Persist artwork-driven theme toggle
            "use_artwork_theme": self.chk_artwork_theme.isChecked(),
            "dev_mode": dev_mode,
        }

# ============= Worker =============

class Worker(QtCore.QObject):
    progress = QtCore.pyqtSignal(str)
    done = QtCore.pyqtSignal(bool, str)
    presence = QtCore.pyqtSignal(dict)  # {details,str; state,str}

    def __init__(self, game, use_flags: bool, mask_hex: str, do_aff: bool, do_high: bool, extra_flags: list[str], discord_cfg: dict):
        super().__init__()
        self.game = game
        self.use_flags = use_flags
        self.mask_hex = mask_hex
        self.do_aff = do_aff
        self.do_high = do_high
        self.extra_flags = extra_flags or []
        self.discord_cfg = discord_cfg or {}

    def run(self):
        try:
            # Normalize core fields
            aumid = (self.game.get("aumid", "") or "").strip()
            exe_name = (self.game.get("exe_name", "") or "").strip()
            exe_path = (self.game.get("exe", "") or "").strip()

            base_flags = self.game.get("flags", [])
            if isinstance(base_flags, str):
                base_flags = [x for x in base_flags.strip().split() if x]
            flags = (base_flags if self.use_flags else []) + self.extra_flags

            # --- Steam library games: launch via Steam, never UWPHook (ADD-ONLY) ---
            source = (self.game.get("source", "") or "").lower()
            appid = (self.game.get("appid", "") or "").strip()
            if source == "steam" and appid:
                uri = f"steam://rungameid/{appid}"
                self.progress.emit(f"Launching via Steam: {uri}")
                try:
                    if os.name == "nt":
                        os.startfile(uri)  # type: ignore[attr-defined]
                    else:
                        subprocess.Popen(["xdg-open", uri], close_fds=True)
                except Exception as e:
                    self.done.emit(False, f"Failed to launch via Steam: {e}")
                    return
                # We don't try to force affinity/priority for Steam-launched games here,
                # because we don't know the exact EXE name yet.
                try:
                    details_tpl = self.discord_cfg.get("discord_details_tpl", "{name}")
                    state_tpl = self.discord_cfg.get(
                        "discord_state_tpl",
                        "HighPrio={high}  Affinity={aff}  Flags={flags}",
                    )
                    show_flags = " ".join(flags) if flags else "(none)"
                    payload = {
                        "details": details_tpl.format(name=self.game.get("name", "")),
                        "state": state_tpl.format(
                            name=self.game.get("name", ""),
                            high=self.do_high,
                            aff=self.do_aff,
                            flags=show_flags,
                        ),
                    }
                    self.presence.emit(payload)
                except Exception as e:
                    self.progress.emit(f"Discord presence formatting failed: {e}")
                self.done.emit(True, "Launched Steam game via Steam.")
                return

            # ---------- NON-UWP / REGULAR GAME PATH ----------
            # If there's no AUMID but we *do* have an EXE path, launch directly.
            if not aumid and exe_path:
                argv = [exe_path] + flags
                self.progress.emit("Launching (native): " + " ".join(argv))
                try:
                    subprocess.Popen(argv, close_fds=True)
                except Exception as e:
                    self.done.emit(False, f"Failed to launch game: {e}")
                    return

                # Determine which process name to watch
                target_exe = exe_name or os.path.basename(exe_path)

                # Wait for the actual game process
                t0 = time.time()
                found_once = False
                while time.time() - t0 < 45:
                    pids = list(iter_pids_by_name(target_exe))
                    if pids:
                        found_once = True
                        break
                    time.sleep(0.5)

                if not found_once:
                    self.done.emit(False, f"Could not find process: {target_exe}")
                    return

                changed, mask = apply_affinity_priority(target_exe, self.mask_hex, self.do_aff, self.do_high)

            # ---------- ORIGINAL UWP / UWPHook PATH ----------
            else:
                uwp_path = _resolve_uwphook_path(None)
                if not uwp_path:
                    self.done.emit(False, "UWPHook.exe not found. Please locate it.")
                    return

                argv = [uwp_path, aumid, exe_name] + flags
                self.progress.emit("Launching: " + " ".join(argv))
                subprocess.Popen(argv, close_fds=True)

                # Wait for the actual game exe (by exe_name)
                t0 = time.time()
                found_once = False
                while time.time() - t0 < 45:
                    pids = list(iter_pids_by_name(exe_name))
                    if pids:
                        found_once = True
                        break
                    time.sleep(0.5)

                if not found_once:
                    self.done.emit(False, f"Could not find process: {exe_name}")
                    return

                changed, mask = apply_affinity_priority(exe_name, self.mask_hex, self.do_aff, self.do_high)

            # Log affinity/priority result
            self.progress.emit(
                f"Applied settings to {changed} process(es). "
                f"Mask=0x{mask:X} High={self.do_high} Affinity={self.do_aff}"
            )

            # Discord presence payload (unchanged behavior)
            try:
                details_tpl = self.discord_cfg.get("discord_details_tpl", "{name}")
                state_tpl = self.discord_cfg.get(
                    "discord_state_tpl",
                    "HighPrio={high}  Affinity={aff}  Flags={flags}",
                )
                show_flags = " ".join(flags) if flags else "(none)"
                payload = {
                    "details": details_tpl.format(name=self.game.get("name", "")),
                    "state": state_tpl.format(
                        name=self.game.get("name", ""),
                        high=self.do_high,
                        aff=self.do_aff,
                        flags=show_flags,
                    ),
                }
                self.presence.emit(payload)
            except Exception as e:
                self.progress.emit(f"Discord presence formatting failed: {e}")

            self.done.emit(True, "Done.")
        except Exception as e:
            self.done.emit(False, f"Error: {e}")
# ============= Main UI =============

# --- Xbox / Game Bar notification mirroring (winsdk) ---
try:
    from PyQt6 import QtCore as _QtCore
    _HAVE_QT = True
except Exception:
    _HAVE_QT = False

try:
    # Python Windows SDK projection
    from winsdk.windows.ui.notifications.management import UserNotificationListener, UserNotificationListenerAccessStatus
    from winsdk.windows.ui.notifications import NotificationKinds
    _HAVE_WINSDK = True
except Exception:
    _HAVE_WINSDK = False

# App IDs and keywords we treat as Xbox-related
_XBOX_TARGET_APP_IDS = {
    "Microsoft.XboxApp",
    "Microsoft.XboxGamingOverlay",
    "Microsoft.Xbox.TCUI",
}
_XBOX_KEYWORDS = ("message", "invite", "party", "game invite", "chat", "invited you", "party invite", "join")

def _xbox_summarize_notification(n):
    app_id = "<unknown>"
    text = "<no-text>"
    try:
        app_info = n.app_info
        app_id = getattr(app_info, "app_user_model_id", None) or getattr(app_info, "id", None) or "<unknown>"
    except Exception:
        pass
    try:
        visual = n.notification.visual
        binding = None
        try:
            binding = visual.get_binding("ToastGeneric")
        except Exception:
            binding = None
        if not binding:
            try:
                for b in visual.get_bindings():
                    binding = b
                    break
            except Exception:
                binding = None
        parts = []
        if binding:
            for child in binding.get_text_elements():
                t = child.text
                if t:
                    parts.append(t)
        if parts:
            text = " | ".join(parts)
    except Exception:
        pass
    return app_id, (text or '').strip()

if _HAVE_QT:
    class _XboxNotifWorker(_QtCore.QThread):
        toast = _QtCore.pyqtSignal(str)
        toast_detail = _QtCore.pyqtSignal(str, str)  # app_id, text

        def __init__(self, parent=None):
            super().__init__(parent)
            self._running = True

        def stop(self):
            self._running = False

        def run(self):
            if not _HAVE_WINSDK:
                return
            import asyncio
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)

            async def _watch():
                try:
                    listener = UserNotificationListener.current
                    status = await listener.request_access_async()
                    if status != UserNotificationListenerAccessStatus.ALLOWED:
                        return
                    seen = set()
                    while self._running:
                        try:
                            arr = await listener.get_notifications_async(NotificationKinds.TOAST)
                            for n in arr:
                                if n.id in seen:
                                    continue
                                app_id, text = _xbox_summarize_notification(n)
                                app_lower = (app_id or '').lower()
                                txt_lower = (text or '').lower()
                                is_xbox_source = ('xbox' in app_lower) or any(tid.lower() in app_lower for tid in _XBOX_TARGET_APP_IDS)
                                is_keyword = any(kw in txt_lower for kw in [kw.lower() for kw in _XBOX_KEYWORDS])
                                if is_xbox_source or is_keyword:
                                    msg = text.strip() if text and text.strip() else f"Xbox notification from {app_id}"
                                    self.toast.emit(msg)
                                    self.toast_detail.emit(app_id or '', text or '')
                                seen.add(n.id)
                        except Exception:
                            # don't spam logs from the worker thread
                            pass
                        await asyncio.sleep(1.0)
                except Exception:
                    pass

            try:
                loop.run_until_complete(_watch())
            finally:
                try:
                    loop.stop()
                    loop.close()
                except Exception:
                    pass


# --- XBL token auto-refresh helpers (robust, skew-tolerant) ---
def _xbl_tokens_path():
    """Return the expected OpenXbox tokens.json path (LocalAppData/OpenXbox/xbox/tokens.json)."""
    import os
    try:
        root = os.getenv("LOCALAPPDATA") or os.getenv("APPDATA") or ""
        if root:
            p = os.path.join(root, "OpenXbox", "xbox", "tokens.json")
            return p
    except Exception:
        pass
    # Fallback next to app as last resort
    try:
        from pathlib import Path as _Path
        return str((_Path.cwd() / "tokens.json").resolve())
    except Exception:
        return "tokens.json"


def _xbl_load_tokens():
    import json, time, os
    path = _xbl_tokens_path()
    try:
        with open(path, "r", encoding="utf-8") as f:
            data = json.load(f)
        # Normalize fields
        now = int(time.time())
        # Try several field names commonly used
        exp = data.get("expires_at") or data.get("expires") or data.get("expiry") or 0
        if isinstance(exp, str):
            try:
                exp = int(float(exp))
            except Exception:
                exp = 0
        return data, int(exp or 0), path
    except Exception:
        return None, 0, path


def _xbl_save_tokens_atomic(obj):
    import json, os, tempfile, shutil
    path = _xbl_tokens_path()
    try:
        os.makedirs(os.path.dirname(path), exist_ok=True)
    except Exception:
        pass
    try:
        d = json.dumps(obj, indent=2)
        fd, tmpp = tempfile.mkstemp(prefix="tokens_", suffix=".json", dir=os.path.dirname(path) or None)
        with os.fdopen(fd, "w", encoding="utf-8") as f:
            f.write(d)
        shutil.move(tmpp, path)
        return True
    except Exception:
        try:
            with open(path, "w", encoding="utf-8") as f:
                json.dump(obj, f, indent=2)
            return True
        except Exception:
            return False
class Main(QtWidgets.QWidget):
    def on_xbox_sign_in(self):
        try:
            self._append("Xbox Live: checking tokens.json...")
            tokens_path = _discover_tokens_path()
            if not tokens_path:
                # No tokens.json yet: actively run the Xbox helper so the user can sign in.
                self._append("Xbox Live: tokens.json missing, running Xbox helper for sign-in...")
                try:
                    refresh_xbl_token(parent=self)
                except Exception as e:
                    self._append(f"Xbox helper failed: {e}")
                tokens_path = _discover_tokens_path()
                if not tokens_path:
                    self._append("Xbox sign-in failed: tokens.json not found even after helper.")
                    QtWidgets.QMessageBox.warning(
                        self,
                        "Xbox Sign-In",
                        "Could not find or create tokens.json.\n"
                        "Make sure the Xbox helper scripts are present."
                    )
                    return
            info = _xbl_tokens_get(tokens_path)
            auth = info.get("Authorization")
            if not auth:
                raise RuntimeError("helper returned no Authorization")
            self._xbl_headers = {
                "Authorization": auth,
                "Accept": "application/json",
                "x-xbl-contract-version": "3",
            }
            os.environ["XBL_TOKENS_PATH"] = tokens_path
            self._append("Xbox Live: signed in. (source: " + tokens_path + ")")
            try:
                if getattr(self, "xbox_profile", None):
                    self.xbox_profile.set_headers(self._xbl_headers)
                    self.xbox_profile.refresh()
            except Exception as e:
                self._append(f"[xbl_profile_widget] refresh failed: {e}")
            QtWidgets.QMessageBox.information(self, "Xbox Sign-In", "Signed in using:\n" + tokens_path)
        except Exception as e:
            self._append(f"Xbox sign-in failed: {e}")
            QtWidgets.QMessageBox.critical(self, "Xbox Sign-In", f"Failed: {e}")

    def on_xbox_sign_out(self):
        """
        Sign out of Xbox Live for this launcher instance.
        This clears in-memory headers and removes any tokens.json we can find,
        so future Xbox calls behave as signed-out until the user signs in again.
        """
        try:
            self._append("Xbox Live: signing out...")
            # Clear in-memory headers and global injection
            try:
                self._xbl_headers = None
            except Exception:
                pass
            try:
                set_global_xbl_headers(None)
            except Exception:
                pass

            # Try to locate and remove tokens.json from common locations
            removed_paths = []
            try:
                tokens_path = _discover_tokens_path()
            except Exception:
                tokens_path = None

            candidates = []
            if tokens_path:
                candidates.append(Path(tokens_path))
            try:
                candidates.append(_xbl_user_dir() / "tokens.json")
            except Exception:
                pass

            # De-duplicate and remove any existing token files
            seen = set()
            for p in candidates:
                try:
                    p = Path(p)
                    key = str(p.resolve())
                except Exception:
                    continue
                if key in seen:
                    continue
                seen.add(key)
                if p.is_file():
                    try:
                        p.unlink()
                        removed_paths.append(str(p))
                    except Exception as e:
                        self._append(f"Xbox Live: failed to remove {p}: {e}")

            # Reset environment override
            try:
                if "XBL_TOKENS_PATH" in os.environ:
                    del os.environ["XBL_TOKENS_PATH"]
            except Exception:
                pass

            # Reset profile widget UI if present
            try:
                if getattr(self, "xbox_profile", None):
                    self.xbox_profile.set_headers(None)
                    try:
                        self.xbox_profile.lbl_name.setText("<i>Not signed in</i>")
                    except Exception:
                        pass
            except Exception:
                pass

            if removed_paths:
                msg = "Signed out of Xbox Live.\nRemoved tokens:\n" + "\n".join(removed_paths)
            else:
                msg = "Signed out of Xbox Live.\nNo tokens.json file was found to remove."
            self._append(msg.replace("\n", " "))
            QtWidgets.QMessageBox.information(self, "Xbox Sign-Out", msg)
        except Exception as e:
            self._append(f"Xbox sign-out failed: {e}")
            QtWidgets.QMessageBox.critical(self, "Xbox Sign-Out", f"Failed: {e}")

    
    
    
    
            def _run():
                try:
                    # Prefer tokens.json path if available
                    if _XBL_TOKENS_OK:
                        self._append("Xbox Live: checking tokens.json...")
                        info = _xbl_tokens_get(tokens_path)
                    elif _XBL_IMPORT_OK:
                        self._append("Xbox Live: starting device-code sign-in...")
                        info = _xbl_get_xsts()
                    else:
                        self._append(f"Xbox Live helpers unavailable: {_XBL_IMPORT_ERR or 'no helper installed'}")
                        return
    
                    gt = info.get("gamertag") or "(unknown)"
                    xuid = info.get("xuid") or "(unknown)"
                    self._append(f"Signed in to Xbox Live as {gt}  (XUID: {xuid})")
                    # Save headers for later Xbox API calls
                    self._xbl_headers = {
                        "Authorization": info["Authorization"],
                        "x-xbl-contract-version": "3",
                    }
                    try:
                        if hasattr(self, '_friendsDock') and self._friendsDock:
                            self._friendsDock.set_headers(self._xbl_headers)
                    except Exception:
                        pass
                except Exception as e:
                    self._append(f"Xbox sign-in failed: {e}")
                finally:
                    try:
                        self.btn_xsignin.setDisabled(False)
                    except Exception:
                        pass
    
            import threading
            t = threading.Thread(target=_run, daemon=True)
            t.start()
    
    
        def closeEvent(self, e):
            try:
                self.discord.clear(self._append)
                self.discord.close(self._append)
            except Exception:
                pass
            super().closeEvent(e)
    
        

    def _open_friends(self):
        try:
            if 'FriendsDock' in globals() and FriendsDock:
                try:
                    dlg = FriendsDock(self)
                    dlg.setWindowModality(QtCore.Qt.WindowModality.NonModal)
                    dlg.show()
                    dlg.raise_()
                    dlg.activateWindow()
                    return
                except Exception as e:
                    self._append(f"[friends] inline launch failed: {e}")
            _launch_friends_popup_external()
        except Exception as e:
            self._append(f"[friends] failed to launch popup: {e}")
    def __init__(self):
        super().__init__()

        # --- XBL token auto-refresh ---
        try:
            from PyQt6 import QtCore as _QtCore
            self._xbl_refreshing = False
            self._xbl_refresh_backoff = 0  # seconds
            self._xbl_refresh_timer = _QtCore.QTimer(self)
            self._xbl_refresh_timer.setSingleShot(False)
            self._xbl_refresh_timer.setInterval(60 * 1000)  # check every 60s
            self._xbl_refresh_timer.timeout.connect(self._xbl_check_refresh_needed)
            self._xbl_refresh_timer.start()
        except Exception:
            self._xbl_refresh_timer = None
            self._xbl_refreshing = False
            self._xbl_refresh_backoff = 0

        # Start Xbox/Game Bar notification mirroring if winsdk is present
        try:
            if _HAVE_QT and _HAVE_WINSDK:
                self._xbox_worker = _XboxNotifWorker(self)
                # Use the existing one-at-a-time toast system
                self._xbox_worker.toast.connect(lambda t: self._show_toast(t, "info"))
                self._xbox_worker.toast_detail.connect(self._on_xbox_toast_detail)
                self._xbox_worker.start()
                self._xbox_debug = bool(self.settings.get('xbox_notifications_debug', False))
            else:
                self._xbox_worker = None
        except Exception:
            self._xbox_worker = None
        # --- Toast queue state (serializes notifications) ---
        try:
            from PyQt6 import QtCore as _QtCore
            self._toast_queue = []          # list[tuple(text, level, timeout_ms)]
            self._toast_active = False      # whether a toast is currently animating/visible
            self._toast_timer = _QtCore.QTimer(self)
            self._toast_timer.setSingleShot(True)
            self._toast_timer.timeout.connect(self._drain_toast_queue)
        except Exception:
            self._toast_queue = []
            self._toast_active = False
            self._toast_timer = None

        # --- Toast queue state (serializes notifications) ---
        try:
            from PyQt6 import QtCore as _QtCore
            self._toast_queue = []          # list[tuple(text, level, timeout_ms)]
            self._toast_active = False      # whether a toast is currently animating/visible
            self._toast_timer = _QtCore.QTimer(self)
            self._toast_timer.setSingleShot(True)
            self._toast_timer.timeout.connect(self._drain_toast_queue)
        except Exception:
            self._toast_queue = []
            self._toast_active = False
            self._toast_timer = None

        self.setWindowTitle(f"UWPLauncher v{APP_VERSION}")
        self.resize(920, 640)

        # Artwork-driven background support
        self._artwork_bg_path = None
        self._artwork_bg = None

        self.discord = DiscordManager()
        self.settings = load_settings()
        self.discord.configure(self.settings.get("discord_enabled", False), self.settings.get("discord_client_id",""))


        # Xbox headers will be populated after successful sign-in
        self._xbl_headers = None

        # --- Root layout: sidebar + main content ---
        root_layout = QtWidgets.QHBoxLayout(self)
        root_layout.setContentsMargins(0, 0, 0, 0)
        root_layout.setSpacing(0)

        # Left sidebar (navigation)
        sidebar = QtWidgets.QVBoxLayout()
        sidebar.setContentsMargins(4, 4, 4, 4)
        sidebar.setSpacing(8)

        # Library / games view
        self.btn_nav_library = QtWidgets.QToolButton()
        self.btn_nav_library.setText("")
        self.btn_nav_library.setToolTip("Library")
        self.btn_nav_library.setCheckable(True)
        self.btn_nav_library.setChecked(True)
        self.btn_nav_library.setAutoRaise(True)
        sidebar.addWidget(self.btn_nav_library)

        # Friends dock
        self.btn_nav_friends = QtWidgets.QToolButton()
        self.btn_nav_friends.setText("")
        self.btn_nav_friends.setToolTip("Friends")
        self.btn_nav_friends.setAutoRaise(True)
        sidebar.addWidget(self.btn_nav_friends)

        # Discord presence
        self.btn_nav_discord = QtWidgets.QToolButton()
        self.btn_nav_discord.setText("")
        self.btn_nav_discord.setToolTip("Discord RPC Settings")
        self.btn_nav_discord.setAutoRaise(True)
        sidebar.addWidget(self.btn_nav_discord)

        # Xbox sign-in
        self.btn_nav_xbox = QtWidgets.QToolButton()
        self.btn_nav_xbox.setText("")
        self.btn_nav_xbox.setToolTip("Xbox Sign-In")
        self.btn_nav_xbox.setAutoRaise(True)
        sidebar.addWidget(self.btn_nav_xbox)

        # Xbox sign-out
        self.btn_nav_xbox_signout = QtWidgets.QToolButton()
        self.btn_nav_xbox_signout.setText("")
        self.btn_nav_xbox_signout.setToolTip("Xbox Sign-Out")
        self.btn_nav_xbox_signout.setAutoRaise(True)
        sidebar.addWidget(self.btn_nav_xbox_signout)

        # Xbox profile refresh (gamertag + avatar)
        self.btn_nav_xbox_profile = QtWidgets.QToolButton()
        self.btn_nav_xbox_profile.setText("")
        self.btn_nav_xbox_profile.setToolTip("Refresh Xbox profile")
        self.btn_nav_xbox_profile.setAutoRaise(True)
        sidebar.addWidget(self.btn_nav_xbox_profile)

        # Library refresh
        self.btn_nav_refresh = QtWidgets.QToolButton()
        self.btn_nav_refresh.setText("")
        self.btn_nav_refresh.setToolTip("Refresh library")
        self.btn_nav_refresh.setAutoRaise(True)
        sidebar.addWidget(self.btn_nav_refresh)

        # Check for updates
        self.btn_nav_update = QtWidgets.QToolButton()
        self.btn_nav_update.setText("")
        self.btn_nav_update.setToolTip(f"Check for updates (current: {APP_VERSION})")
        self.btn_nav_update.setAutoRaise(True)
        self.btn_nav_update.clicked.connect(lambda: _check_for_updates(self))
        sidebar.addWidget(self.btn_nav_update)

        # Log viewer
        self.btn_nav_log = QtWidgets.QToolButton()
        self.btn_nav_log.setText("")
        self.btn_nav_log.setToolTip("Log")
        self.btn_nav_log.setAutoRaise(True)
        sidebar.addWidget(self.btn_nav_log)

        sidebar.addStretch(1)

        # Settings / skins / add-edit-delete-sync menu
        self.btn_nav_settings = QtWidgets.QToolButton()
        self.btn_nav_settings.setText("")
        self.btn_nav_settings.setToolTip("Settings")
        self.btn_nav_settings.setAutoRaise(True)
        sidebar.addWidget(self.btn_nav_settings)

        root_layout.addLayout(sidebar)

        # Main column (search + grid + details)
        layout = QtWidgets.QVBoxLayout()
        layout.setContentsMargins(8, 8, 8, 8)
        layout.setSpacing(8)
        root_layout.addLayout(layout, 1)
        # Add Xbox profile header (gamertag + avatar)
        if 'XboxProfileWidget' in globals() and XboxProfileWidget:
            try:
                self.xbox_profile = XboxProfileWidget(self)
                layout.addWidget(self.xbox_profile)
                # Hide the builtin refresh button on the profile widget; we
                # expose this as a sidebar action instead so all refresh /
                # actions live in one place.
                try:
                    if hasattr(self.xbox_profile, "btn_refresh"):
                        self.xbox_profile.btn_refresh.setVisible(False)
                except Exception:
                    pass
                try:
                    if getattr(self, '_xbl_headers', None):
                        self.xbox_profile.set_headers(self._xbl_headers)
                except Exception:
                    pass
                try:
                    self.xbox_profile.refresh()
                except Exception:
                    pass
            except Exception as _e:
                pass


        # Toggles
        toggles = QtWidgets.QHBoxLayout()
        self.chk_priority = QtWidgets.QCheckBox("High priority")
        self.chk_affinity = QtWidgets.QCheckBox("Set CPU affinity")
        self.chk_flags = QtWidgets.QCheckBox("Use game flags")
        self.chk_priority.setChecked(True)
        self.chk_affinity.setChecked(True)
        self.chk_flags.setChecked(True)
        self.le_mask = QtWidgets.QLineEdit("")
        self.le_mask.setPlaceholderText("HEX mask (blank = auto, all CPUs except CPU0)")
        self.le_mask.setMaximumWidth(260)
        toggles.addWidget(self.chk_priority)
        toggles.addWidget(self.chk_affinity)
        toggles.addWidget(self.chk_flags)
        toggles.addWidget(QtWidgets.QLabel("Mask:"))
        toggles.addWidget(self.le_mask)
        toggles.addStretch(1)
        toggles.addWidget(QtWidgets.QLabel("Game:"))
        self.selector = QtWidgets.QComboBox()
        toggles.addWidget(self.selector, 1)
        layout.addLayout(toggles)

        # Extra flags perlaunch
        self.extra_flags = QtWidgets.QLineEdit("")
        self.extra_flags.setPlaceholderText("Extra flags (space-separated, appended at launch)")
        layout.addWidget(self.extra_flags)

        # Discord RPC row (settings only; status label is at bottom)
        disc_row = QtWidgets.QHBoxLayout()
        self.btn_settings = QtWidgets.QPushButton("Settings (Discord RPC)")
        self.btn_settings.setVisible(False)
        disc_row.addWidget(self.btn_settings)
        disc_row.addStretch(1)
        layout.addLayout(disc_row)

        # Cover size slider (controls card size in the grid)
        self.cover_size_slider = QtWidgets.QSlider(QtCore.Qt.Orientation.Horizontal)
        self.cover_size_slider.setRange(160, 320)

        # Load last-used value from settings (clamped to slider range)
        try:
            saved_size = int(self.settings.get("cover_size", 220))
        except Exception:
            saved_size = 220
        saved_size = max(160, min(saved_size, 320))
        self.cover_size_slider.setValue(saved_size)

        layout.addWidget(self.cover_size_slider)

        # Scrollable grid of game artwork
        self.games_scroll = QtWidgets.QScrollArea()
        self.games_scroll.setWidgetResizable(True)
        self.games_container = QtWidgets.QWidget()
        self.games_layout = QtWidgets.QGridLayout(self.games_container)
        self.games_layout.setContentsMargins(12, 12, 12, 12)
        self.games_layout.setHorizontalSpacing(24)
        self.games_layout.setVerticalSpacing(24)
        self.games_scroll.setWidget(self.games_container)
        layout.addWidget(self.games_scroll, 2)

        # Game selector + CRUD (buttons kept but hidden; settings menu handles them)
        row = QtWidgets.QHBoxLayout()
        self.btn_add = QtWidgets.QPushButton("Add")
        self.btn_edit = QtWidgets.QPushButton("Edit")
        self.btn_del = QtWidgets.QPushButton("Delete")
        self.btn_sync = QtWidgets.QPushButton("Sync UWP")
        self.btn_add.setVisible(False)
        self.btn_edit.setVisible(False)
        self.btn_del.setVisible(False)
        self.btn_sync.setVisible(False)
        self.btn_add = QtWidgets.QPushButton("Add")
        self.btn_edit = QtWidgets.QPushButton("Edit")
        self.btn_del = QtWidgets.QPushButton("Delete")
        self.btn_sync = QtWidgets.QPushButton("Sync UWP")
        row.addWidget(self.btn_add)
        row.addWidget(self.btn_edit)
        row.addWidget(self.btn_del)
        row.addWidget(self.btn_sync)

        # --- Settings menu to host Add/Edit/Delete/Sync ---
        self.btn_actions_settings = QtWidgets.QToolButton()
        QtCore.QTimer.singleShot(0, lambda: _NONUWP_augment_settings(self))
        self.btn_actions_settings.setText('Settings')
        self.btn_actions_settings.setToolTip('Add / Edit / Delete / Sync')
        self.btn_actions_settings.setPopupMode(QtWidgets.QToolButton.ToolButtonPopupMode.InstantPopup)
        self.menu_actions = QtWidgets.QMenu(self)
        self.btn_actions_settings.setMenu(self.menu_actions)
        self.btn_actions_settings.setVisible(False)
        row.addWidget(self.btn_actions_settings)
        # Populate menu
        act_add = self.menu_actions.addAction('Add')
        act_edit = self.menu_actions.addAction('Edit')
        act_delete = self.menu_actions.addAction('Delete')
        self.menu_actions.addSeparator()
        act_sync = self.menu_actions.addAction('Sync UWP')
        # ---- Skins submenu (add-only) ----
        skins = self.menu_actions.addMenu('Skins')
        act_skin_default = skins.addAction('Default')
        act_skin_xbox = skins.addAction('Xbox Original (green/black)')
        def _apply_skin(name):
            try:
                tm = ThemeManager(QtWidgets.QApplication.instance())
                tm.apply(name)
            except Exception:
                pass
        act_skin_default.triggered.connect(lambda: _apply_skin('default'))
        act_skin_xbox.triggered.connect(lambda: _apply_skin('xbox_original'))

        # Developer mode toggle (global)  appears under the gear icon
        self.menu_actions.addSeparator()
        act_dev_mode = self.menu_actions.addAction('Developer mode')
        act_dev_mode.setCheckable(True)
        try:
            act_dev_mode.setChecked(bool(self.settings.get('dev_mode', False)))
        except Exception:
            # If settings aren't available yet, fall back to unchecked
            act_dev_mode.setChecked(False)
        def _toggle_dev_mode(checked):
            try:
                # Ensure we have a settings dict
                if not hasattr(self, 'settings') or not isinstance(self.settings, dict):
                    self.settings = {}
                self.settings['dev_mode'] = bool(checked)
                save_settings(self.settings)
                # Update any debug/status UI that should only be visible in dev mode
                try:
                    if hasattr(self, 'lbl_discord'):
                        self.lbl_discord.setVisible(bool(self.settings.get('dev_mode', False)))
                except Exception:
                    pass
            except Exception:
                pass
        act_dev_mode.toggled.connect(_toggle_dev_mode)

        # Wire actions to existing slots
        act_add.triggered.connect(self._on_add)
        act_edit.triggered.connect(self._on_edit)
        act_delete.triggered.connect(self._on_del)
        act_sync.triggered.connect(self._on_sync)
        # Hide the original row buttons so only the Settings menu shows
        self.btn_add.setVisible(False)
        self.btn_edit.setVisible(False)
        self.btn_del.setVisible(False)
        self.btn_sync.setVisible(False)

        self.btn_friends = QtWidgets.QPushButton('Friends')
        self.btn_friends.setVisible(False)
        row.addWidget(self.btn_friends)
        self.btn_xsignin = QtWidgets.QPushButton("Xbox Sign-In")
        self.btn_xsignin.setVisible(False)
        row.addWidget(self.btn_xsignin)
        layout.addLayout(row)

        # Log (primary viewer is now opened from the sidebar)
        self.log = QtWidgets.QTextEdit()
        self.log.setReadOnly(True)
        # Keep a reasonable size but hide it from the main layout
        self.log.setMinimumHeight(140)
        self.log.setVisible(False)
        layout.addWidget(self.log, 1)

        
        # Artwork preview for Steam games (optional, kept off-screen; background uses artwork directly)
        self.lbl_artwork = QtWidgets.QLabel()
        self.lbl_artwork.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.lbl_artwork.setMinimumHeight(1)
        self.lbl_artwork.setVisible(False)

        # Launch button (bottom of the main UI)
        self.btn = QtWidgets.QPushButton("LAUNCH")
        self.btn.setMinimumHeight(72)
        layout.addWidget(self.btn)

# Steam status (LED + label) + Discord RPC status (same bottom row)
        status_row = QtWidgets.QHBoxLayout()
        self.lbl_steam_led = QtWidgets.QLabel()
        self.lbl_steam_led.setFixedSize(14, 14)
        # default color; will be updated by _update_steam_led()
        self.lbl_steam_led.setStyleSheet("border-radius: 7px; background-color: #c62828;")
        status_row.addWidget(self.lbl_steam_led)
        status_row.addWidget(QtWidgets.QLabel("Steam"))
        status_row.addStretch(1)
        self.lbl_discord = QtWidgets.QLabel(self._discord_status_text())
        self.lbl_discord.setStyleSheet("color: gray;")
        # Only show this debug-style status line when developer mode is enabled
        try:
            self.lbl_discord.setVisible(bool(self.settings.get("dev_mode", False)))
        except Exception:
            # If settings are not yet available for some reason, default to hidden
            try:
                self.lbl_discord.setVisible(False)
            except Exception:
                pass
        try:
            self.lbl_discord.setAlignment(QtCore.Qt.AlignmentFlag.AlignRight)
        except Exception:
            pass
        status_row.addWidget(self.lbl_discord)
        layout.addLayout(status_row)

        # Data
        self.games = load_games()
        self._refresh_selector()

        # Sidebar refresh: reload games + selector + grid when the user clicks
        # the refresh tool button.
        try:
            self.btn_nav_refresh.clicked.connect(self._on_nav_refresh)
        except Exception:
            pass

        # Hook up grid controls (cover size slider)
        try:
            # Smooth resize: resize existing cards on the fly instead of
            # rebuilding the whole grid on every tick.
            self.cover_size_slider.setTracking(True)
            self.cover_size_slider.valueChanged.connect(self._on_cover_size_changed)
        except Exception:
            pass

        # Rebuild grid once after loading
        try:
            self._rebuild_game_grid()
        except Exception:
            pass

        # Initialize Steam LED based on current config/steam.json (if any)
        try:
            self._update_steam_led()
        except Exception:
            pass

        # Wire
        self.selector.currentIndexChanged.connect(self._on_sel_change)
        self.btn_add.clicked.connect(self._on_add)
        self.btn_edit.clicked.connect(self._on_edit)
        self.btn_del.clicked.connect(self._on_del)
        self.btn_sync.clicked.connect(self._on_sync)
        self.btn.clicked.connect(self._on_launch)
        self.btn_settings.clicked.connect(self._on_settings)
        self.btn_friends.clicked.connect(self._open_friends)
        try:
            self.btn_xsignin.clicked.connect(self.on_xbox_sign_in)
        except Exception:
            pass

        # Wire sidebar nav buttons to existing actions
        try:
            self.btn_nav_friends.clicked.connect(self._open_friends)
        except Exception:
            pass
        try:
            # Tapping the sidebar settings button opens the same menu as the old Settings toolbutton.
            self.btn_nav_settings.clicked.connect(lambda: self.btn_actions_settings.showMenu())
        except Exception:
            pass
        try:
            # Discord RPC settings from sidebar
            self.btn_nav_discord.clicked.connect(self._on_settings)
        except Exception:
            pass
        try:
            # Xbox sign-in from sidebar
            self.btn_nav_xbox.clicked.connect(self.on_xbox_sign_in)
        except Exception:
            pass
        try:
            # Xbox sign-out from sidebar
            self.btn_nav_xbox_signout.clicked.connect(self.on_xbox_sign_out)
        except Exception:
            pass

        try:
            # Xbox profile refresh (avatar / gamertag) from sidebar
            self.btn_nav_xbox_profile.clicked.connect(self._on_nav_xbox_profile_refresh)
        except Exception:
            pass
        try:
            # Log viewer from sidebar
            self.btn_nav_log.clicked.connect(self._show_log_viewer)
        except Exception:
            pass

        # Show defaults of first game
        self._on_sel_change(self.selector.currentIndex())

        # Try to connect Discord if enabled
        self._connect_discord_if_needed()
        # Xbox tokens: auto-refresh at startup + every 5 minutes (silent)
        try:
            import threading as _threading
            try:
                t = _threading.Thread(target=_auto_refresh_xbl_token_silent, daemon=True)
                t.start()
            except Exception:
                _auto_refresh_xbl_token_silent()
            self._xbl_auto_timer = QtCore.QTimer(self)
            self._xbl_auto_timer.setInterval(5 * 60 * 1000)
            self._xbl_auto_timer.timeout.connect(_auto_refresh_xbl_token_silent)
            self._xbl_auto_timer.start()
        except Exception as e:
            try:
                print('[xbl_auto_refresh] timer setup failed:', e)
            except Exception:
                pass
            try:
                print("[xbl_auto_refresh] timer setup failed:", e)
            except Exception:
                pass


                    # ---------- helpers ----------
    def _append(self, s:str):
        # Main log sink
        try:
            self.log.append(s)
        except Exception:
            pass
        # Mirror into log viewer if it exists
        try:
            if hasattr(self, "log_view") and self.log_view is not None:
                self.log_view.append(s)
        except Exception:
            pass

    
    
    def _show_toast(self, text: str, level: str = "info", timeout_ms: int = 3500):
        """Queue a toast; display serially to avoid overlap."""
        if not text:
            return
        try:
            self._toast_queue.append((text, level, timeout_ms))
            self._drain_toast_queue()
        except Exception:
            pass

    def _render_toast_now(self, text: str, level: str = "info", timeout_ms: int = 3500):
        """
        Lightweight in-app toast notification in the bottom-right corner.
        level: "info" | "success" | "error"
        """
        if not text:
            return

        try:
            from PyQt6 import QtWidgets as _QtWidgets, QtGui as _QtGui, QtCore as _QtCore
        except Exception:
            return

        # Pick background color based on level
        if level == "success":
            bg = "#2e7d32"   # green-ish
        elif level == "error":
            bg = "#c62828"   # red-ish
        else:
            bg = "#37474f"   # neutral dark

        toast = _QtWidgets.QFrame(self)
        toast.setObjectName("toast")
        toast.setAttribute(_QtCore.Qt.WidgetAttribute.WA_StyledBackground, True)
        toast.setStyleSheet(
            f"""
            QFrame#toast {{
                background-color: {bg};
                color: #ffffff;
                border-radius: 8px;
                padding: 8px 12px;
            }}
            """
        )

        layout = _QtWidgets.QHBoxLayout(toast)
        layout.setContentsMargins(10, 6, 10, 6)
        layout.setSpacing(8)

        label = _QtWidgets.QLabel(text)
        label.setWordWrap(True)
        layout.addWidget(label)

        toast.adjustSize()

        # Position toast in bottom-right of the main window
        margin = 16
        size = toast.sizeHint()
        w, h = size.width(), size.height()
        x = max(0, self.width() - w - margin)
        y = max(0, self.height() - h - margin)
        toast.setGeometry(x, y, w, h)

        # Fade-in / fade-out animations
        effect = _QtWidgets.QGraphicsOpacityEffect(toast)
        toast.setGraphicsEffect(effect)

        anim_in = _QtCore.QPropertyAnimation(effect, b"opacity", toast)
        anim_in.setDuration(200)
        anim_in.setStartValue(0.0)
        anim_in.setEndValue(1.0)

        def start_fade_out():
            anim_out = _QtCore.QPropertyAnimation(effect, b"opacity", toast)
            anim_out.setDuration(250)
            anim_out.setStartValue(1.0)
            anim_out.setEndValue(0.0)

            def cleanup():
                try:
                    self._toast_active = False
                    if self._toast_timer:
                        self._toast_timer.start(150)
                    self._drain_toast_queue()
                    self._drain_toast_queue()  # proceed immediately to next
                except Exception:
                    self._toast_active = False

                toast.hide()
                toast.deleteLater()

            anim_out.finished.connect(cleanup)
            toast._anim_out = anim_out
            anim_out.start()

        # Keep animations alive on the object so they dont get GCd
        toast._anim_in = anim_in

        toast.show()
        
        anim_in.start()
        _QtCore.QTimer.singleShot(timeout_ms, start_fade_out)



    def _show_log_viewer(self):
        """Open a modeless window showing the log contents."""
        from PyQt6 import QtWidgets as _QtWidgets
        try:
            dlg = getattr(self, "_log_dialog", None)
            if dlg is None:
                dlg = _QtWidgets.QDialog(self)
                dlg.setWindowTitle("Log")
                dlg.resize(900, 400)
                layout = _QtWidgets.QVBoxLayout(dlg)
                self.log_view = _QtWidgets.QTextEdit()
                self.log_view.setReadOnly(True)
                # Seed with current log text
                try:
                    self.log_view.setPlainText(self.log.toPlainText())
                except Exception:
                    pass
                layout.addWidget(self.log_view)
                self._log_dialog = dlg
            dlg.show()
            dlg.raise_()
            dlg.activateWindow()
        except Exception as e:
            try:
                print(f"[log] failed to show log viewer: {e}")
            except Exception:
                pass

    def _update_steam_led(self):
        """Update the Steam LED indicator based on config/steam.json.
        Green = we have a steamid + encrypted API key.
        Red   = missing or invalid credentials.
        """
        try:
            from pathlib import Path as _Path
            import json as _json

            ok = False
            cfg = _Path("config") / "steam.json"
            if cfg.is_file():
                try:
                    data = _json.loads(cfg.read_text(encoding="utf-8"))
                    steamid = str(data.get("steamid", "")).strip()
                    enc = str(data.get("api_key_enc", "")).strip()
                    ok = bool(steamid and enc)
                except Exception:
                    ok = False

            if hasattr(self, "lbl_steam_led"):
                color = "#00c853" if ok else "#c62828"
                self.lbl_steam_led.setStyleSheet(
                    f"border-radius: 7px; background-color: {color};"
                )
        except Exception:
            try:
                if hasattr(self, "lbl_steam_led"):
                    self.lbl_steam_led.setStyleSheet(
                        "border-radius: 7px; background-color: #c62828;"
                    )
            except Exception:
                pass


    def _update_artwork_for_current_game(self):
        """Update the artwork QLabel based on the currently selected game.
        - Only shows art for Steam games with a cached image.
        - If no artwork is available, the label is left blank.
        Also makes sure artwork is cached on demand for the current Steam appid.
        """
        try:
            from PyQt6 import QtGui, QtCore as _QtCore
        except Exception:
            return
        try:
            g = self._current_game()
        except Exception:
            g = None
        art_path = None
        try:
            if g:
                # Prefer per-game custom artwork if present
                try:
                    custom = str(g.get("custom_art_path", "")).strip()
                except Exception:
                    custom = ""
                if custom:
                    try:
                        import os as _os
                        if _os.path.isfile(custom):
                            art_path = custom
                    except Exception:
                        art_path = None
                # If no custom artwork, fall back to Steam artwork by appid
                if not art_path:
                    appid = str(g.get("appid", "")).strip()
                    if appid:
                        # Ensure artwork is cached for this appid (also creates config/artwork).
                        try:
                            _steam_artwork_ensure_cached(appid)
                        except Exception as e:
                            print(f"[ART] on-select cache failed for appid {appid}: {e}")
                        p = _steam_artwork_path(appid)
                        # Support both Path and plain string
                        if hasattr(p, "is_file"):
                            if p.is_file():
                                art_path = str(p)
                        else:
                            import os as _os
                            if _os.path.isfile(p):
                                art_path = str(p)
        except Exception:
            art_path = None

        if art_path and hasattr(self, "lbl_artwork"):
            try:
                pix = QtGui.QPixmap(art_path)
                if not pix.isNull():
                    # Scale to fit label while keeping aspect ratio
                    w = max(1, self.lbl_artwork.width() or 320)
                    h = max(1, self.lbl_artwork.height() or 240)
                    scaled = pix.scaled(
                        w,
                        h,
                        _QtCore.Qt.AspectRatioMode.KeepAspectRatio,
                        _QtCore.Qt.TransformationMode.SmoothTransformation,
                    )
                    self.lbl_artwork.setPixmap(scaled)
                    # Optional: apply artwork as background if enabled
                    try:
                        settings_obj = getattr(self, "settings", None)
                        if isinstance(settings_obj, dict) and settings_obj.get("use_artwork_theme"):
                            self._set_artwork_background(art_path)
                    except Exception:
                        pass
                    return
            except Exception:
                pass
        # No artwork found or failed to load  clear the label and background
        try:
            if hasattr(self, "lbl_artwork"):
                self.lbl_artwork.clear()
            try:
                self._set_artwork_background(None)
            except Exception:
                pass
        except Exception:
            pass


    def _set_artwork_background(self, art_path: str):
        """
        Store the selected artwork path and trigger a repaint so the entire
        window background is covered by that image.
        """
        try:
            from PyQt6 import QtGui
        except Exception:
            return
        try:
            if not art_path:
                self._artwork_bg_path = None
                self._artwork_bg = None
                self.update()
                return
            pix = QtGui.QPixmap(art_path)
            if pix.isNull():
                return
            self._artwork_bg_path = art_path
            self._artwork_bg = pix
            self.update()
        except Exception:
            pass

    def paintEvent(self, event):
        """Custom paint to draw the artwork across the whole window background."""
        try:
            from PyQt6 import QtGui, QtCore
            pix = getattr(self, "_artwork_bg", None)
            if pix is not None and not pix.isNull():
                painter = QtGui.QPainter(self)
                try:
                    target_size = self.size()
                    tw, th = target_size.width(), target_size.height()
                    if tw > 0 and th > 0:
                        img_size = pix.size()
                        iw, ih = img_size.width(), img_size.height()
                        if iw > 0 and ih > 0:
                            # Scale so the image *covers* the entire UI, keeping aspect ratio,
                            # and then crop the overflow (like a wallpaper cover mode).
                            scale = max(tw / iw, th / ih)
                            new_w = int(iw * scale)
                            new_h = int(ih * scale)
                            scaled = pix.scaled(
                                new_w,
                                new_h,
                                QtCore.Qt.AspectRatioMode.KeepAspectRatio,
                                QtCore.Qt.TransformationMode.SmoothTransformation,
                            )
                            # Center the cropped image within the window
                            x = (tw - new_w) // 2
                            y = (th - new_h) // 2
                            # Make the background slightly transparent so UI elements stay readable
                            painter.setOpacity(0.35)
                            painter.drawPixmap(x, y, scaled)
                finally:
                    painter.end()
        except Exception:
            # Fail silently if there is any issue with painting; do not crash the UI
            pass
        # Let the normal Qt / stylesheet painting run for all child widgets
        super().paintEvent(event)




    def _on_nav_xbox_profile_refresh(self):
        """Refresh the Xbox profile widget (gamertag + avatar) using the
        latest Xbox Live headers if available."""
        try:
            xp = getattr(self, "xbox_profile", None)
            if xp is None:
                return
            # Re-apply headers if we have them
            try:
                if getattr(self, "_xbl_headers", None) and hasattr(xp, "set_headers"):
                    xp.set_headers(self._xbl_headers)
            except Exception:
                pass
            try:
                xp.refresh()
            except Exception:
                pass
        except Exception:
            pass

    def _on_nav_refresh(self):
        """Refresh library via Steam sync and then refresh selector + grid.

        This uses the existing NONUWP Steam sync helper so new games / changes
        are pulled in, instead of only re-reading games.json.
        """
        try:
            _NONUWP_act_sync(self)
        except Exception:
            # Fallback: at least reload games.json and refresh selector/grid.
            try:
                self.games = load_games()
            except Exception:
                return
            try:
                self._refresh_selector()
            except Exception:
                pass

    def _refresh_selector(self):
        self.selector.blockSignals(True)
        self.selector.clear()
        self.selector.addItems([g.get("name","") for g in self.games])
        self.selector.blockSignals(False)
        if self.selector.count() > 0:
            self.selector.setCurrentIndex(0)
        try:
            self._update_artwork_for_current_game()
        except Exception:
            pass
        # Rebuild the game artwork grid when the library changes
        try:
            self._rebuild_game_grid()
        except Exception:
            pass

    def _on_sel_change(self, idx:int):
        g = self._current_game()
        if not g: return
        self.chk_priority.setChecked(bool(g.get("high_priority", True)))
        self.chk_affinity.setChecked(bool(g.get("apply_affinity", True)))
        self.chk_flags.setChecked(bool(g.get("use_flags", True)))
        self.le_mask.setText(g.get("mask_hex",""))
        try:
            self._update_artwork_for_current_game()
        except Exception:
            pass

        # Discord Rich Presence: reflect current selection while browsing
        try:
            if self.settings.get("discord_enabled") and getattr(self, "discord", None) and self.discord.connected:
                details_tpl = self.settings.get("discord_details_tpl", "{name}")
                state_tpl = self.settings.get("discord_state_tpl", "HighPrio={high}  Affinity={aff}  Flags={flags}")
                base_flags = g.get("flags", [])
                if isinstance(base_flags, str):
                    base_flags = [x for x in base_flags.strip().split() if x]
                show_flags = " ".join(base_flags) if base_flags else "(none)"
                high = bool(self.chk_priority.isChecked())
                aff = bool(self.chk_affinity.isChecked())
                details = details_tpl.format(name=g.get("name", ""))
                state = state_tpl.format(
                    name=g.get("name", ""),
                    high=high,
                    aff=aff,
                    flags=show_flags,
                )
                self.discord.set_presence(details, state, self._append)
        except Exception:
            # Never let Discord issues break selection changes
            pass


    def _art_path_for_game(self, g):
        """Return best artwork path for a given game dict, honoring custom_art_path first."""
        if not g:
            return None
        art_path = None
        try:
            # Prefer per-game custom artwork if present
            try:
                custom = str(g.get("custom_art_path", "")).strip()
            except Exception:
                custom = ""
            if custom:
                try:
                    import os as _os
                    if _os.path.isfile(custom):
                        art_path = custom
                except Exception:
                    art_path = None
            # If no custom artwork, fall back to Steam artwork by appid
            if not art_path:
                appid = str(g.get("appid", "")).strip()
                if appid:
                    try:
                        _steam_artwork_ensure_cached(appid)
                    except Exception as e:
                        print(f"[ART] grid cache failed for appid {appid}: {e}")
                    try:
                        p = _steam_artwork_path(appid)
                    except Exception:
                        p = None
                    if p is not None:
                        if hasattr(p, "is_file"):
                            if p.is_file():
                                art_path = str(p)
                        else:
                            import os as _os
                            if _os.path.isfile(p):
                                art_path = str(p)
        except Exception:
            art_path = None
        return art_path

    def _rebuild_game_grid(self):
        """Rebuild the cover grid to look like the Xenia-style layout."""
        try:
            from PyQt6 import QtGui, QtCore, QtWidgets as _QtWidgets
        except Exception:
            return
        layout = getattr(self, "games_layout", None)
        container = getattr(self, "games_container", None)
        if layout is None or container is None:
            return

        # Clear existing items
        try:
            while layout.count():
                item = layout.takeAt(0)
                w = item.widget()
                if w is not None:
                    w.setParent(None)
        except Exception:
            pass

        self._card_widgets = []

        games = getattr(self, "games", []) or []
        if not games:
            return

        query = ""
        try:
            if hasattr(self, "search_edit") and self.search_edit is not None:
                query = self.search_edit.text().strip().lower()
        except Exception:
            query = ""

        try:
            size = int(self.cover_size_slider.value()) if hasattr(self, "cover_size_slider") else 160
        except Exception:
            size = 160
        size = max(96, min(size, 320))

        # Grid layout: cap to 4 columns max per row.
        # We fill columns left-to-right, then move to the next row so there
        # are at most 4 game cards in each row. Extra games are accessible via
        # vertical scrolling.
        max_cols = 4
        row = 0
        col = 0

        for idx, g in enumerate(games):
            name = str(g.get("name", "") or "").strip()
            if query and query not in name.lower():
                continue

            card = _QtWidgets.QFrame()
            card.setFrameShape(_QtWidgets.QFrame.Shape.StyledPanel)
            card.setObjectName("gameCard")

            v = _QtWidgets.QVBoxLayout(card)
            v.setContentsMargins(4, 4, 4, 4)
            v.setSpacing(4)

            cover = _QtWidgets.QLabel()
            cover.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
            cover_w = size
            cover_h = int(size * 1.4)
            cover.setFixedSize(cover_w, cover_h)

            # Lock card width to the cover width so cards
            # don't stretch wider than their artwork when the
            # main window is resized.
            card_w = cover_w + 8  # 4px margins on each side
            card.setFixedWidth(card_w)

            art_path = self._art_path_for_game(g)
            pix = None
            if art_path:
                try:
                    pix = QtGui.QPixmap(art_path)
                except Exception:
                    pix = None
            if pix is not None and (not pix.isNull()):
                # Keep the original pixmap on the card so we can rescale it
                # smoothly as the user moves the slider, without hitting disk
                # or network again.
                card._cover_pixmap = pix
                cover._base_pixmap = pix
                scaled = pix.scaled(
                    cover_w,
                    cover_h,
                    QtCore.Qt.AspectRatioMode.KeepAspectRatioByExpanding,
                    QtCore.Qt.TransformationMode.SmoothTransformation,
                )
                cover.setPixmap(scaled)
            else:
                card._cover_pixmap = None
                cover._base_pixmap = None
                cover.setStyleSheet("background-color: #202020; border-radius: 4px;")
                cover.setText("No Art")
                cover.setWordWrap(True)

            title = _QtWidgets.QLabel(name or "(unnamed)")
            title.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
            title.setWordWrap(True)

            v.addWidget(cover)
            v.addWidget(title)

            # Remember the cover widget so we can resize it later when the
            # slider moves, without rebuilding the whole grid.
            try:
                card._cover_label = cover
            except Exception:
                pass

            def _clicked(ev, index=idx):
                self._on_game_card_clicked(index)
            card.mousePressEvent = _clicked

            layout.addWidget(card, row, col)
            self._card_widgets.append(card)

            # Fill columns first (up to max_cols), then move to the next row.
            col += 1
            if col >= max_cols:
                col = 0
                row += 1

        # Force relayout
        try:
            container.updateGeometry()
            container.adjustSize()
        except Exception:
            pass


    def _on_cover_size_changed(self, value:int):
        """Smoothly resize existing game cards when the slider moves.
        This only rescales the in-memory pixmaps and adjusts widget sizes,
        avoiding a full grid rebuild for each tick so the UI stays responsive.
        """
        try:
            from PyQt6 import QtCore as _QtCore
        except Exception:
            return
        try:
            size = int(value)
        except Exception:
            size = 160
        size = max(96, min(size, 320))

        cards = getattr(self, "_card_widgets", []) or []
        for card in cards:
            try:
                cover = getattr(card, "_cover_label", None)
                if cover is None:
                    continue
                base_pix = getattr(card, "_cover_pixmap", None)
                cover_w = size
                cover_h = int(size * 1.4)
                cover.setFixedSize(cover_w, cover_h)

                # Keep the card width in sync with the current cover size
                try:
                    card_w = cover_w + 8  # 4px margins on each side
                    card.setFixedWidth(card_w)
                except Exception:
                    pass

                if base_pix is not None and (not base_pix.isNull()):
                    scaled = base_pix.scaled(
                        cover_w,
                        cover_h,
                        _QtCore.Qt.AspectRatioMode.KeepAspectRatioByExpanding,
                        _QtCore.Qt.TransformationMode.SmoothTransformation,
                    )
                    cover.setPixmap(scaled)
            except Exception:
                continue

        try:
            container = getattr(self, "games_container", None)
            if container is not None:
                container.updateGeometry()
                container.adjustSize()
        except Exception:
            pass

        # Persist slider value in settings so the grid size is remembered
        try:
            if isinstance(getattr(self, "settings", None), dict):
                self.settings["cover_size"] = size
                save_settings(self.settings)
        except Exception:
            pass

    def _on_game_card_clicked(self, index:int):
        """When user clicks a card, select that game in the underlying combo and update details."""
        try:
            if 0 <= index < self.selector.count():
                self.selector.setCurrentIndex(index)
        except Exception:
            pass

    def _current_game(self):
        name = self.selector.currentText().strip()
        return get_game_by_name(name, self.games)

    # ---------- CRUD ----------
    def _on_add(self):
        dlg = GameEditor(self)
        if dlg.exec() == QtWidgets.QDialog.DialogCode.Accepted:
            g = dlg.get_data()
            if g.get("name"):
                self.games.append(g)
                save_games(self.games)
                self._refresh_selector()
                self.selector.setCurrentIndex(self.selector.count()-1)

    def _on_edit(self):
        g = self._current_game()
        if not g: return
        dlg = GameEditor(self, g)
        if dlg.exec() == QtWidgets.QDialog.DialogCode.Accepted:
            newg = dlg.get_data()
            # replace the entry
            idx = 0
            for i, e in enumerate(self.games):
                if e.get("name") == g.get("name"):
                    self.games[i] = newg
                    idx = i
                    break
            save_games(self.games)
            self._refresh_selector()
            self.selector.setCurrentIndex(max(0, idx))

    def _on_del(self):
        idx = self.selector.currentIndex()
        if idx < 0: return
        name = self.selector.currentText()
        if QtWidgets.QMessageBox.question(self, "Delete", f"Remove '{name}' from launcher?") == QtWidgets.QMessageBox.StandardButton.Yes:
            self.games.pop(idx)
            save_games(self.games)
            self._refresh_selector()

    # ---------- UWP Sync ----------
    def _on_sync(self):
        dlg = UWPSyncDialog(self)
        if dlg.exec() == QtWidgets.QDialog.DialogCode.Accepted:
            pass  # not used; we add via Add Selected button
        # Handle Add Selected here so main list updates immediately
        app = dlg.selected_app()
        if not app:
            return
        prefill = {
            "name": app.get("Name",""),
            "aumid": app.get("AppID",""),
            "exe_name": "",  # user must enter the running process name
            "flags": [],
            "mask_hex":"",
            "use_flags": True,
            "high_priority": True,
            "apply_affinity": True,
        }
        ge = GameEditor(self, prefill)
        if ge.exec() == QtWidgets.QDialog.DialogCode.Accepted:
            g = ge.get_data()
            if g.get("name"):
                self.games.append(g)
                save_games(self.games)
                self._refresh_selector()
                self.selector.setCurrentIndex(self.selector.count()-1)

    # ---------- Settings / Discord ----------
    def _discord_status_text(self):
        if not self.settings.get("discord_enabled"):
            return "Discord RPC: disabled"
        cid = self.settings.get("discord_client_id","")
        return f"Discord RPC: enabled (Client ID: {cid or 'not set'})"

    def _on_settings(self):
        dlg = SettingsEditor(self, self.settings)
        if dlg.exec() == QtWidgets.QDialog.DialogCode.Accepted:
            self.settings = dlg.get_settings()
            save_settings(self.settings)
            self.lbl_discord.setText(self._discord_status_text())
            self.discord.configure(self.settings.get("discord_enabled", False), self.settings.get("discord_client_id",""))
            self._connect_discord_if_needed()

    def _connect_discord_if_needed(self):
        if self.settings.get("discord_enabled") and self.settings.get("discord_client_id",""):
            ok = self.discord.connect(self._append)
            if ok:
                # Set an initial idle presence so Discord shows the app immediately
                try:
                    self.discord.set_presence("UWPLauncher", "Browsing library", self._append)
                except Exception:
                    pass
            else:
                self._append("Discord not connected; continue without RPC.")
        else:
            self._append("Discord RPC disabled.")


    # ---------- Launch ----------
    def _on_launch(self):
        g = self._current_game()
        if not g:
            self._append("No game selected.")
            return

        # Apply current UI toggles to run (non-destructive to JSON unless you Edit/Save)
        use_flags = self.chk_flags.isChecked()
        mask_hex = self.le_mask.text().strip() or g.get("mask_hex","")
        do_aff = self.chk_affinity.isChecked()
        do_high = self.chk_priority.isChecked()
        extra = [x for x in self.extra_flags.text().strip().split() if x]

        # Log config (avoid touching UWPHook for non-UWP titles)
        aumid = (g.get("aumid","") or "").strip()
        exe_name = (g.get("exe_name","") or "").strip()
        exe_path = (g.get("exe","") or "").strip()

        if aumid:
            uwp_info = _resolve_uwphook_path(None) or "(not set)"
        else:
            uwp_info = "(not used for this title)"

        self._append(f"UWPHook: {uwp_info}")
        self._append(f"AUMID:   {aumid}")
        log_exe = exe_name or (os.path.basename(exe_path) if exe_path else "")
        self._append(f"EXE:     {log_exe}")
        base_flags = g.get('flags', [])
        if isinstance(base_flags, str):
            base_flags = [x for x in base_flags.strip().split() if x]
        show_flags = (base_flags if use_flags else []) + extra
        self._append(f"Flags:   {' '.join(show_flags) if show_flags else '(none)'}")
        self._append(f"Mask:    {mask_hex or '(auto: all CPUs except CPU0)'}")
        self._append(f"HighPrio:{do_high}  Affinity:{do_aff}")

        # Launch in thread
        self.btn.setDisabled(True)
        self.thread = QtCore.QThread(self)
        discord_cfg = {
            "discord_details_tpl": self.settings.get("discord_details_tpl","{name}"),
            "discord_state_tpl": self.settings.get("discord_state_tpl","HighPrio={high}  Affinity={aff}  Flags={flags}"),
        }
        self.worker = Worker(g, use_flags, mask_hex, do_aff, do_high, extra, discord_cfg)
        self.worker.moveToThread(self.thread)
        self.thread.started.connect(self.worker.run)
        self.worker.progress.connect(self._append)
        self.worker.done.connect(self._on_done)
        self.worker.presence.connect(self._on_presence)
        self.thread.start()

    def _on_presence(self, payload: dict):
        if not payload: return
        if self.settings.get("discord_enabled") and self.discord.connected:
            self.discord.set_presence(payload.get("details",""), payload.get("state",""), self._append)

    def _on_done(self, ok: bool, msg: str):
        self._append(msg)
        self.btn.setDisabled(False)
        if hasattr(self, "thread") and self.thread:
            self.thread.quit()
            self.thread.wait(2000)

        # Toast summary of the launch result
        try:
            if ok:
                self._show_toast("Game launched successfully.", "success")
            else:
                # msg already has full details in the log
                self._show_toast("Launch failed  see log for details.", "error")
        except Exception:
            pass

    # ---------- close ----------

    # ---------- Xbox Live Sign-In ----------
    


# (moved into Main)

    def _drain_toast_queue(self):
        """Show next toast if none active."""
        try:
            if self._toast_active or not getattr(self, "_toast_queue", None):
                return
            item = self._toast_queue.pop(0)
            self._toast_active = True
            text, level, timeout_ms = item
            self._render_toast_now(text, level, timeout_ms)
        except Exception:
            # If something goes wrong, clear state to avoid deadlock
            self._toast_active = False

    def closeEvent(self, event):
        try:
            w = getattr(self, '_xbox_worker', None)
            if w is not None:
                w.stop()
                w.wait(1000)
        except Exception:
            pass
        try:
            super().closeEvent(event)
        except Exception:
            pass

    def _on_xbox_toast_detail(self, app_id: str, text: str):
        try:
            if getattr(self, "_xbox_debug", False):
                self._append(f"[xbox-notif] {app_id}: {text}")
        except Exception:
            pass

    def _xbl_check_refresh_needed(self):
        """Check tokens.json expiry; refresh a few minutes early with jitter; handles backoff."""
        try:
            import time, random
            data, exp, _ = _xbl_load_tokens()
            if not data or not exp:
                return
            now = int(time.time())
            # Refresh 5 minutes before expiry (skew 120s) with small jitter
            refresh_at = int(exp) - 300
            if now >= refresh_at - 120:
                if not self._xbl_refreshing:
                    # simple backoff if recent failures
                    if self._xbl_refresh_backoff > 0:
                        if now < self._xbl_refresh_backoff:
                            return
                    self._xbl_try_refresh(reason="timer")
        except Exception:
            pass

    def _xbl_try_refresh(self, reason="manual"):
        """Invoke embedded refresh flow safely; set flags and toast on success/failure."""
        if getattr(self, "_xbl_refreshing", False):
            return
        self._xbl_refreshing = True
        ok = False
        msg = None
        try:
            # Use embedded helper if present
            if hasattr(self, "_embedded_refresh_token_only"):
                self._embedded_refresh_token_only()
                # Validate new expiry
                import time
                _, exp, _ = _xbl_load_tokens()
                if exp and exp > int(time.time()) + 900:  # got at least 15 more minutes
                    ok = True
                else:
                    msg = "Xbox token refresh did not extend expiry."
            else:
                msg = "No embedded refresh helper available."
        except Exception as e:
            msg = f"Xbox token refresh error: {e}"
        finally:
            try:
                self._xbl_refreshing = False
            except Exception:
                pass

        # Notify + backoff
        try:
            if ok:
                try:
                    self._xbl_refresh_backoff = 0
                except Exception:
                    pass
                self._show_toast("Xbox token refreshed.", "success")
            else:
                import time
                self._xbl_refresh_backoff = int(time.time()) + 300  # 5 min
                if msg:
                    self._show_toast(msg, "error")
        except Exception:
            pass

def _open_friends(self):
    try:
        if 'FriendsDock' in globals() and FriendsDock:
            try:
                dlg = FriendsDock(self)
                dlg.setWindowModality(QtCore.Qt.WindowModality.NonModal)
                dlg.show()
                dlg.raise_()
                dlg.activateWindow()
                return
            except Exception as e:
                self._append(f"[friends] inline launch failed: {e}")
        # Fallback: launch external helper script
        _launch_friends_popup_external()
    except Exception as e:
        self._append(f"[friends] failed to launch popup: {e}")

def main():
    app = QtWidgets.QApplication(sys.argv)
    w = Main()
    w.show()
    sys.exit(app.exec())

# === BEGIN NONUWP HANDLERS + AUGMENT (add-only) ===
def _NONUWP_module():
    import importlib, sys, types, base64 as _b64
    if "nonuwp" not in sys.modules:
        pkg = types.ModuleType("nonuwp"); pkg.__path__ = []; sys.modules["nonuwp"] = pkg
    if "nonuwp.launcher" not in sys.modules:
        # assume embed already ran; if not, nothing to do here
        pass
    return importlib.import_module("nonuwp.launcher")

def _NONUWP_call_by_sig(func, *args, **kwargs):
    import inspect
    try:
        sig = inspect.signature(func)
        allowed = {k:v for k,v in kwargs.items() if k in sig.parameters}
        try:
            ba = sig.bind_partial(*args, **allowed)
        except TypeError:
            ba = sig.bind_partial(**allowed)
        return func(*ba.args, **ba.kwargs)
    except Exception:
        try: return func()
        except Exception:
            try: return func(*args)
            except Exception:
                return func

def NONUWP_sync_steam_library_dialog(self):
    from PyQt6 import QtWidgets
    import json, os
    mod = _NONUWP_module()
    f = getattr(mod, "sync_steam_library", None)
    if not callable(f):
        QtWidgets.QMessageBox.warning(self, "Sync Steam Library", "Function not found in launcher.py"); return
    try:
        return f()
    except TypeError as te:
        need_prompt = ("steamid" in str(te)) or ("api_key" in str(te))
    except Exception:
        need_prompt = False
    steamid = ""; api_key = ""
    if need_prompt:
        from pathlib import Path as _Path
        cfg = _Path("config"); cfg.mkdir(parents=True, exist_ok=True)
        fcfg = cfg / "steam.json"
        try:
            cached = json.loads(fcfg.read_text(encoding="utf-8"))
            steamid = str(cached.get("steamid",""))
            enc = str(cached.get("api_key_enc",""))
            if enc:
                api_key = _steam_decrypt(enc)
        except Exception:
            pass
        dlg = QtWidgets.QDialog(self); dlg.setWindowTitle("Steam credentials")
        form = QtWidgets.QFormLayout(dlg)
        e_id = QtWidgets.QLineEdit(steamid); e_key = QtWidgets.QLineEdit(api_key); e_key.setEchoMode(QtWidgets.QLineEdit.EchoMode.Password)
        form.addRow("SteamID64:", e_id); form.addRow("API Key:", e_key)
        btns = QtWidgets.QDialogButtonBox(QtWidgets.QDialogButtonBox.StandardButton.Ok|QtWidgets.QDialogButtonBox.StandardButton.Cancel)
        form.addRow(btns)
        btns.accepted.connect(dlg.accept); btns.rejected.connect(dlg.reject)
        if dlg.exec() != QtWidgets.QDialog.DialogCode.Accepted: return
        steamid = e_id.text().strip(); api_key = e_key.text().strip()
        obj = {"steamid": steamid}
        try:
            enc = _steam_encrypt(api_key)
            if enc:
                obj["api_key_enc"] = enc
        except Exception:
            pass
        try:
            fcfg.write_text(json.dumps(obj, indent=2), encoding="utf-8")
        except Exception:
            pass
    try:
        if steamid and api_key:
            return f(steamid=steamid, api_key=api_key)
        return _NONUWP_call_by_sig(f, steamid, api_key, steamid64=steamid, key=api_key)
    except Exception as e:
        QtWidgets.QMessageBox.warning(self, "Sync Steam Library", str(e))

def NONUWP_validate_dialog(self):
    from PyQt6 import QtWidgets
    mod = _NONUWP_module()
    f = getattr(mod, "steam_validate_and_wait", None)
    if callable(f):
        try: return f()
        except TypeError:
            try: return f(None)
            except Exception: pass
    f2 = getattr(mod, "steam_validate", None)
    if callable(f2):
        try: return f2()
        except Exception as e: QtWidgets.QMessageBox.warning(self, "Validate through Steam", str(e))

def NONUWP_load_games_generic():
    mod = _NONUWP_module()
    lg = getattr(mod, "load_games", None)
    if not callable(lg): return {}
    import inspect
    try:
        sig = inspect.signature(lg)
        if len(sig.parameters) == 0: return lg()
        if len(sig.parameters) == 1: return lg("games.json")
    except Exception: pass
    try: return lg()
    except Exception: return {}

def NONUWP_save_games_generic(data):
    mod = _NONUWP_module()
    sg = getattr(mod, "save_games", None)
    if not callable(sg): return False
    import inspect
    try:
        sig = inspect.signature(sg)
        if len(sig.parameters) == 1: return sg(data)
        if len(sig.parameters) >= 2: return sg("games.json", data)
    except Exception: pass
    try: return sg(data)
    except Exception: return False

def _NONUWP_act_sign_in(self):
    from PyQt6 import QtWidgets
    try:
        f = getattr(_NONUWP_module(), "steam_openid_login", None)
        if callable(f):
            f()

        # After attempting sign-in, refresh the Steam LED indicator if available
        try:
            if hasattr(self, "_update_steam_led"):
                self._update_steam_led()
        except Exception:
            pass

        QtWidgets.QMessageBox.information(
            self,
            "Steam Sign-In",
            "Steam sign-in has been started in your browser."
        )
    except Exception as e:
        QtWidgets.QMessageBox.warning(self, "Steam Sign-In", str(e))


def _NONUWP_act_sync(self):
    from PyQt6 import QtWidgets
    try:
        # Run Steam sync via launcher helper - this returns a tuple like:
        # (True, "Fetched N games.", { "response": { "games": [...] } })
        res = NONUWP_sync_steam_library_dialog(self)

        # Merge games from the returned payload directly into self.games
        merged = False
        games_src = []

        # Extract payload from res without assuming exact shape
        if isinstance(res, dict):
            games_src = (res.get("response") or res).get("games") or []
        elif isinstance(res, (list, tuple)):
            # Look for dict with "response" key inside the tuple/list
            payload = None
            for part in res:
                if isinstance(part, dict):
                    if "response" in part:
                        payload = part
                        break
                    payload = part
            if payload is not None:
                resp = payload.get("response") or payload
                games_src = resp.get("games") or []

        # Merge into in-memory list without deleting existing entries
        if isinstance(games_src, list):
            for g in games_src:
                if not isinstance(g, dict):
                    continue
                name = (g.get("name") or "").strip()
                appid = str(g.get("appid", "")).strip()
                exe = ""  # Steam API does not give the EXE path; user fills this later.
                if not name and not appid:
                    continue

                # Avoid duplicates by (appid, name) combo
                is_dup = False
                try:
                    for existing in self.games:
                        if not isinstance(existing, dict):
                            continue
                        if appid and str(existing.get("appid","")).strip() == appid:
                            is_dup = True
                            break
                        if name and existing.get("name","").strip() == name:
                            is_dup = True
                            break
                except Exception:
                    pass
                if is_dup:
                    continue


                if appid:
                    try:
                        _steam_artwork_ensure_cached(appid)
                    except Exception:
                        pass

                entry = {
                    "name": name or f"App {appid}",
                    "exe_name": "",
                    "exe": exe,
                    "aumid": "",
                    "appid": appid,
                    "flags": [],
                    "mask_hex": "",
                    "use_flags": True,
                    "high_priority": True,
                    "apply_affinity": True,
                    "source": "steam",
                }
                try:
                    self.games.append(entry)
                    merged = True
                except Exception:
                    pass

        # ADD-ONLY: ensure Steam artwork is cached for all Steam games after sync
        # Shows a small progress dialog so the UI doesn't feel frozen while images download.
        try:
            try:
                from PyQt6 import QtWidgets, QtCore
            except Exception:
                QtWidgets = None
                QtCore = None

            steam_games = []
            steam_games = []
            for gg in self.games:
                if not isinstance(gg, dict):
                    continue
                if gg.get("platform") != "steam":
                    continue
                appid = gg.get("appid")
                if not appid:
                    continue
                steam_games.append(appid)

            dlg = None
            total = len(steam_games)
            if steam_games and QtWidgets is not None and QtCore is not None:
                try:
                    dlg = QtWidgets.QProgressDialog("Fetching Steam artwork...", "Cancel", 0, total, self)
                    dlg.setWindowTitle("Artwork")
                    dlg.setWindowModality(QtCore.Qt.WindowModality.WindowModal)
                    dlg.setAutoClose(True)
                    dlg.setAutoReset(True)
                except Exception:
                    dlg = None
                # Set wait cursor while we work
                try:
                    self.setCursor(QtCore.Qt.CursorShape.WaitCursor)
                except Exception:
                    pass

            # Console progress bar (single line) so the user sees progress without spam
            try:
                _steam_art_console_start(total)
            except Exception:
                pass

            # Multi-threaded artwork caching: small thread pool so HTTP fetches happen in parallel.
            try:
                import concurrent.futures as _cf
                done = 0

                def _worker(appid):
                    try:
                        _steam_artwork_ensure_cached(appid)
                    except Exception as e:
                        try:
                            print(f"[ART] sync cache failed for appid {appid}: {e}")
                        except Exception:
                            pass

                max_workers = min(8, total) if total > 0 else 0
                if max_workers > 0:
                    with _cf.ThreadPoolExecutor(max_workers=max_workers) as _exec:
                        futures = [_exec.submit(_worker, appid) for appid in steam_games]
                        for _f in _cf.as_completed(futures):
                            done += 1
                            # update GUI progress
                            if dlg is not None and QtWidgets is not None:
                                try:
                                    dlg.setValue(done)
                                    QtWidgets.QApplication.processEvents()
                                    if dlg.wasCanceled():
                                        break
                                except Exception:
                                    pass
                            # update console progress
                            try:
                                _steam_art_console_update(done)
                            except Exception:
                                pass
            except Exception as _e:
                try:
                    print(f"[ART] threaded artwork sync failed, falling back to sequential: {_e}")
                except Exception:
                    pass
                for i, appid in enumerate(steam_games, start=1):
                    if dlg is not None and QtWidgets is not None:
                        try:
                            dlg.setValue(i)
                            QtWidgets.QApplication.processEvents()
                            if dlg.wasCanceled():
                                break
                        except Exception:
                            pass
                    try:
                        _steam_artwork_ensure_cached(appid)
                    except Exception as e:
                        print(f"[ART] sync cache failed for appid {appid}: {e}")
                    # console progress in fallback
                    try:
                        _steam_art_console_update(i)
                    except Exception:
                        pass

            if dlg is not None:
                try:
                    dlg.setValue(total)
                    dlg.close()
                except Exception:
                    pass
            # Restore cursor
            if QtWidgets is not None and QtCore is not None:
                try:
                    self.unsetCursor()
                except Exception:
                    pass
        except Exception as e:
            print(f"[ART] bulk cache failure: {e}")

        if merged:
            try:
                save_games(self.games)
            except Exception:
                pass
            try:
                self._refresh_selector()
            except Exception:
                pass

        if res is not None:
            QtWidgets.QMessageBox.information(self, "Sync Steam Library", str(res))
            try:
                self._show_toast("Steam library synced.", "success")
            except Exception:
                pass
    except Exception as e:
        QtWidgets.QMessageBox.warning(self, "Sync Steam Library", str(e))
        try:
            self._show_toast("Steam library sync failed.", "error")
        except Exception:
            pass
def _NONUWP_act_validate(self):
    from PyQt6 import QtWidgets
    try:
        mod = _NONUWP_module()
        f = getattr(mod, "steam_validate_and_wait", None)
        f2 = getattr(mod, "steam_validate", None)

        # build callables with consistent signatures
        def _call_noarg():
            return f() if callable(f) else (_raise(RuntimeError("noarg not available")))
        def _call_with_appid(appid):
            return f(appid=appid) if callable(f) else (_raise(RuntimeError("with_appid not available")))
        def _legacy_noarg():
            return f2() if callable(f2) else (_raise(RuntimeError("legacy noarg not available")))
        def _legacy_with_appid(appid):
            return f2(appid=appid) if callable(f2) else (_raise(RuntimeError("legacy with_appid not available")))

        # helper since lambdas above need a raising function
        def _raise(e): raise e

        # try to get selected game's appid if present (do NOT prompt here; only fallback later in worker result)
        appid = None
        try:
            g = self._current_game()
            appid = g.get("appid") if isinstance(g, dict) else None
        except Exception:
            appid = None

        # Progress dialog (non-modal, keep UI responsive)
        prog = QtWidgets.QProgressDialog("Validating via Steam... This can take ~60s.", "Hide", 0, 0, self)
        prog.setWindowTitle("Validate through Steam")
        prog.setMinimumDuration(0)
        prog.setCancelButton(None)
        prog.setAutoClose(False)
        prog.show()
        # Fast mode: auto-hide after ~4s so the app doesn't feel stuck
        try:
            if getattr(self, "_fast_validate", True):
                QtCore.QTimer.singleShot(4000, prog.close)
        except Exception:
            pass

        worker = _NONUWP_Worker_Validate(
            self,
            call_noarg = _call_noarg if callable(f) else None,
            call_with_appid = (lambda a: _call_with_appid(a)) if callable(f) else None,
            call_legacy_noarg = _legacy_noarg if callable(f2) else None,
            call_legacy_with_appid = (lambda a: _legacy_with_appid(a)) if callable(f2) else None,
            appid = appid
        )
        def _done(res, err):
            try:
                prog.close()
            except Exception:
                pass
            if err is None and res is not None:
                QtWidgets.QMessageBox.information(self, "Validate through Steam", str(res))
                return
            # If we failed because of missing AppID, prompt now
            # (We can't perfectly detect it here, so just allow user to enter one.)
            appid_text, ok = QtWidgets.QInputDialog.getText(self, "Validate through Steam", "Steam AppID (leave blank to cancel):")
            if not ok or not appid_text.strip():
                QtWidgets.QMessageBox.information(self, "Validate through Steam", "Cancelled.")
                return
            try:
                _appid = int(appid_text.strip())
            except Exception:
                QtWidgets.QMessageBox.warning(self, "Validate through Steam", "AppID must be a number.")
                return
            # persist back
            try:
                gg = self._current_game()
                if isinstance(gg, dict): gg["appid"] = _appid
                NONUWP_save_games_generic({"games": self.games})
            except Exception:
                pass
            # try again quickly on UI thread (short blocking call is okay; if it waits long, it will still block)
            try:
                if callable(f):
                    r = f(appid=_appid); QtWidgets.QMessageBox.information(self, "Validate through Steam", str(r)); return
                if callable(f2):
                    r = f2(appid=_appid); QtWidgets.QMessageBox.information(self, "Validate through Steam", str(r)); return
                QtWidgets.QMessageBox.warning(self, "Validate through Steam", "Validation function not available.")
            except Exception as e2:
                QtWidgets.QMessageBox.warning(self, "Validate through Steam", str(e2))

        worker.done.connect(_done)
        worker.start()
    except Exception as e:
        QtWidgets.QMessageBox.warning(self, "Validate through Steam", str(e))

def _NONUWP_act_add_game(self):
    from PyQt6 import QtWidgets
    import os
    try:
        path, _ = QtWidgets.QFileDialog.getOpenFileName(self, "Select Game EXE", "", "Executables (*.exe);;All Files (*)")
        if not path:
            return
        # Build minimal entry
        name = os.path.splitext(os.path.basename(path))[0]
        entry = {"name": name, "exe": path, "source": "manual"}
        # Update in-memory list immediately
        try:
            self.games.append(entry)
        except Exception:
            pass
        # Persist via launcher helpers (signature-flexible)
        try:
            db = {"games": self.games}
            NONUWP_save_games_generic(db)
        except Exception:
            pass
        # Refresh the dropdown
        try:
            self._refresh_selector()
            # Focus/select the newly added game
            for i,g in enumerate(self.games):
                if g.get("exe") == path:
                    self.selector.setCurrentIndex(i); break
        except Exception:
            pass
        QtWidgets.QMessageBox.information(self, "Add Game", f"Added: {name}")
    except Exception as e:
        from PyQt6 import QtWidgets
        QtWidgets.QMessageBox.warning(self, "Add Game", str(e))

def _NONUWP_augment_settings(self):
    from PyQt6 import QtWidgets
    btn = getattr(self, "btn_actions_settings", None)
    if btn is None:
        for w in self.findChildren(QtWidgets.QToolButton):
            try:
                if str(w.text()).strip().lower() == "settings":
                    btn = w; break
            except Exception:
                pass
    if btn is None:
        return
    m = btn.menu()
    if m is None:
        m = QtWidgets.QMenu(self); btn.setMenu(m)
        try: btn.setPopupMode(QtWidgets.QToolButton.ToolButtonPopupMode.InstantPopup)
        except Exception: pass
    existing = {a.text() for a in m.actions()}
    # fast-validate toggle (default on)
    if not hasattr(self, "_fast_validate"):
        self._fast_validate = True
    if "Fast Steam validate" not in existing:
        a = m.addAction("Fast Steam validate"); a.setCheckable(True); a.setChecked(self._fast_validate)
        def _toggle_fast(state): self._fast_validate = bool(state)
        a.toggled.connect(_toggle_fast)

    if "Sign into Steam" not in existing:
        a = m.addAction("Sign into Steam"); a.triggered.connect(lambda: _NONUWP_act_sign_in(self))
    if "Sync Steam Library" not in existing:
        a = m.addAction("Sync Steam Library"); a.triggered.connect(lambda: _NONUWP_act_sync(self))
    if "Validate through Steam" not in existing:
        a = m.addAction("Validate through Steam"); a.triggered.connect(lambda: _NONUWP_act_validate(self))
    if "Add Game" not in existing:
        a = m.addAction("Add Game"); a.triggered.connect(lambda: _NONUWP_act_add_game(self))
# === END NONUWP HANDLERS + AUGMENT ===

if __name__ == "__main__":
    main()